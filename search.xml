<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/09/10/MySql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/09/10/MySql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>100.尚硅谷_JS基础_全选练习（三）P100 - 02:24</p><p>﻿</p><p>﻿</p><p>101.尚硅谷_JS基础_dom查询的剩余方法P101 - 00:16</p><p>﻿</p><p>Dom查询其它方法</p><p>获取body标签getElementByTagName(“body”)[0]</p><p>在document中有一个属性body，它保存的是body的引用</p><p>documentElement保存的是html的根标签</p><p>document.all代表页面中的所有元素</p><p>document.querySelector()这个方法很强大，需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查询一个元素节点对象。</p><p>使用该方法会返回唯一的一个元素，如果满足条件的元素有多个那么它只会返回第一个。</p><p>document.querySelectorAll()这个方法就可以查询到所有的classname的方法。不同的是符合条件的元素封装到一个数组中进行返回。即使只有一个也返回数组</p><p>字面量：都是一些不可改变的值</p><p>自变量都是可以直接使用，但是我们一般都不直接使用字面量<br>变量：可以用来保存字面量，变量的值是可以任意改变的</p><p>变量更加方便我们使用，所以开发中通过变量保存一个字面量<br>05.尚硅谷_JS基础_字面量和变量P5 - 01:53</p><p>标识符</p><p>在JS中自主命令的都称为标识符<br>例如：变量名、函数名、属性名都属于标识符<br>命名规则如下：<br>标识符可以含有字母、数字、__、$</p><p>标识符不能以数字开头。</p><p>标识符不能是ES中的关键字或保留字。</p><p>标识符一般采用驼峰命名法。helloWorld</p><p>JS底层保存标识符实际上是采用的Unicode编码，<br>07.尚硅谷_JS基础_字符串P7 - 00:26</p><p>JS中一共有六种数据类型</p><p>String 字符串<br>Number 数字<br>Boolean 布尔值<br>Null 控制<br>Undefinged 未定义<br>Object 对象<br>引用数据类型：Object，其它都是基本数据类型</p><p>字符串：</p><p>在JS中字符需要使用引号引起来（单双引号都可以）</p><p>引号不能嵌套，双引号不能放双引号，单引号不能放单引号（如果非要用就必须使用转义字符\）</p><p>当表示一些特殊符号时可以使用\进行转义</p><p>&quot;表示“ \‘表示’</p><p>﻿</p><p>07.尚硅谷_JS基础_字符串P7 - 14:42</p><p>﻿</p><p>﻿</p><p>08.尚硅谷_JS基础_NumberP8 - 00:40</p><p>﻿</p><p>数值类型，浮点整数都是</p><p>使用typeof来检查一个类型的变量</p><p>ptyeof a表示检查a变量的类型</p><p>JS表示Number的最大值number.MAX_VALUE</p><p>如果使用的Number表示的数字超过了最大值，则会返回一个Infinity无穷。</p><p>使用typeof检查Infinity也会返回Number他也是一个数字</p><p>NaN是一个特殊的数字，表示Not A Number不是一个数字</p><p>Number.MIN_VALUE表示0以上可表示的最小值5e-300</p><p>var c=0.1+0.2如果使用JS进行浮点元素，可能得到一个不精确的结果，所以千万不要使用JS进行对精确度要求较高的运算</p><p>﻿</p><p>09.尚硅谷_JS基础_布尔值P9 - 00:16</p><p>﻿</p><p>布尔值只有两个：</p><p>True和False</p><p>﻿</p><p>10.尚硅谷_JS基础_Null和UndefinedP10 - 00:45</p><p>﻿</p><p>Null类型的值只有一个，就是Null</p><p>Null值专门表示一个为空的对象</p><p>Null进行检查时返回的是Object的</p><p>Undefined类型的值只有一个，就undefined（未定义）</p><p>当声明一个变量，但并不给他赋值，那它就是undefined</p><p>使用typeof检查时也是undefined</p><p>﻿</p><p>11.尚硅谷_JS基础_强制类型转换-StringP11 - 00:03</p><p>﻿</p><p>强制类型转换：</p><p>指将一个类型数据强制转换为其它的数据类型</p><p>类型转换主要是指，将其它的数据类型，转换为</p><p>String Number Boolean</p><p>将其它的数据类型转换为String</p><p>方式1、调用被转换数据的ToSting（）方法（这种方法不会改变原始的数据类型）</p><p>Null和Undefined没有ToString方法如果硬调用会保存</p><p>方式2、调用String（）函数，并将被转换的数据作为参数传递给函数。</p><p>对于Number和Boolean实际上调用的ToString（）方法但是对于Null直接转换为“null”，将Undefined转换为“Undefined”</p><p>﻿</p><p>12.尚硅谷_JS基础_强制类型转换-NumberP12 - 00:00</p><p>﻿</p><p>将其它的数据类型转换为Number</p><p>转换方式一：</p><p>使用Number（）函数</p><p>-字符串转换为数字</p><p>1.如果是纯数字的字符串，则直接转换为纯数字的字符串</p><p>2.如果字符串中有非数字的内容，则转换为NaN</p><ol start="3"><li>如果字符串是空船或者是一个全是空格的字符，那么将转换为0</li></ol><p>-布尔值转换为数字</p><p>1.True转为1，False转为0</p><p>-Null转换为0</p><p>-Undefined转换数字为NaN</p><p>转换方式二：</p><p>例如：a=123px123，使用下面方法可以转出123来不转换出px后面的直接忽略掉</p><p>parseInt（）把一个字符串转换为一个整数</p><p>如果对非String使用parseInt（）或parseFloat（）先转换为String再转换成为number</p><p>parseFloat（）把一个字符串转换为一个浮点数</p><p>﻿</p><p>13.尚硅谷_JS基础_其他进制的数字P13 - 00:11</p><p>﻿</p><p>其它进制的数据</p><p>在js中，如果需要表示16进制的数字，则需要以0x开头</p><p>例如a=0x10；那么a的输出值就是16</p><p>如果需要表示8进制的数字，则需要以0开头</p><p>例如a=070；那么a的输出为56</p><p>如果需要表示2进制的数字，则需要以0b开头</p><p>例如a=0b10,；那么a的输出为2</p><p>a=parseInt(a,10)传递第二个参数，来指定数字的进制</p><p>﻿</p><p>14.尚硅谷_JS基础_转换为BooleanP14 - 00:12</p><p>﻿</p><p>转换为Boolean</p><p>方式：使用Boolean（）函数</p><p>var a=123;</p><p>a=Boolean(a)转换为True。</p><p>数字转Boolean规则为0和NaN为False其余为True</p><p>字符串转Boolean除了空串为false其余为True</p><p>Null和Undefined只能转换为False</p><p>对象也会转换为True</p><p>﻿</p><p>15.尚硅谷_JS基础_算数运算符P15 - 00:15</p><p>﻿</p><p>任何值和字符串相加都会转换为字符串再做拼接</p><p>隐式的类型转换，一个数值number+一个””空字符串，他就会自动调用ToString方法进行转换。</p><p>除了+法之外，其它都会把他转成Number形在进行</p><p>（隐式转换）可以通过一个值 -0 *1 /1来将其转换为Number</p><p>原理和Number()函数（显式转换）一样，使用起来更简单</p><p>﻿</p><p>16.尚硅谷_JS基础_一元运算符P16 - 00:03</p><p>﻿</p><p>单目运算符（一元运算符）：</p><p>+正号</p><p>不会对数字产生任何影响</p><p>-负号</p><p>对原来的数字进行取反</p><p>可以对一个其他的数据使用+，来将进行转换为Number</p><p>例如：a=1+(+”2”)+3，a就会输出为6</p><p>﻿</p><p>17.尚硅谷_JS基础_自增和自减P17 - 00:28</p><p>﻿</p><p>++通过自增可以使变量在自身的基础上加1</p><p>后++和前++，无论是哪个都会使原变量的值自增1，</p><p>不同的是a++和++a的值不同</p><p>a++的值等于原变量的值（自增前的值）后自增</p><p>++a的值等于原变量的值（自增后的值）先自增</p><p>–通过自减可以是变量在自身的基础上减1</p><p>前–和后–，无论是a–还是–a都会立即使原变量的值自减1</p><p>不同的是a–和–a的值不同（与前后++规则相同）</p><p>﻿</p><p>18.尚硅谷_JS基础_自增练习P18 - 00:20</p><p>﻿</p><p>﻿ ﻿</p><p>﻿</p><p>19.尚硅谷_JS基础_逻辑运算符P19 - 00:13</p><p>﻿</p><p>如果对非Boolean值进行取反，那么他就先转换为Boolean再进行取反</p><p>﻿</p><p>20.尚硅谷_JS基础_非布尔值的与或运算P20 - 00:02</p><p>﻿</p><p>对于非布尔值的与或运算，会将其转换为布尔值，然后再运算并且返回原值</p><p>与运算，如果两个都为True则返回后面的</p><p>如果有False则返回0，如果有两个False则返回靠前的False</p><p>﻿ ﻿</p><p>﻿</p><p>21.尚硅谷_JS基础_赋值运算符P21 - 00:11</p><p>﻿</p><p>﻿</p><p>23.尚硅谷_JS基础_Unicode编码表P23 - 00:12</p><p>﻿</p><p>在字符串中使用转移字符表\u</p><p>例如：我们要输出一个1就是\u2040</p><p>在网页中就是&amp;#；不过这儿需要的是十进制，需要把十六进制转为十进制</p><p>﻿</p><p>24尚硅谷_JS基础_相等运算符P24 - 00:24</p><p>﻿</p><p>﻿ ﻿</p><p>使用==是，他会自动转换类型，转换成什么不一定大部分会转换成为数字</p><p>NaN不和任何值相等（包括自身都不等）。Undefined衍生自Null所以他和Null相等</p><p>可以通过isNaN（）函数来判断是否是NaN返回true和False</p><p>===全等</p><p>判断两个值是否全等，它和相似相等，但是不会做相应转换</p><p>！==全等</p><p>判断两个值是否不全等，它和不相等相似，但不会进行转换</p><p>﻿</p><p>25.尚硅谷_JS基础_条件运算符P25 - 00:05</p><p>﻿</p><p>条件运算符也叫三元运算符</p><p>语法：</p><p>条件表达式?语句1：语句2;</p><p>﻿ ﻿</p><p>会将其条件表达式转换为布尔值之后再进行运算</p><p>﻿</p><p>26.尚硅谷_JS基础_运算符的优先级P26 - 00:41</p><p>﻿</p><p>，逗号可以同时声明多个变量</p><p>可以使用()来改变优先级</p><p>﻿</p><p>27.尚硅谷_JS基础_代码块P27 - 00:24</p><p>﻿</p><p>﻿ ﻿</p><p>JS中的代码块，只具有分组的作用，没有其他的用途</p><p>代码块内容的内容，在外部是完全可见的</p><p>﻿</p><p>28.尚硅谷_JS基础_if语句（一）P28 - 00:27</p><p>﻿</p><p>﻿</p><p>29.尚硅谷_JS基础_if语句（二）P29 - 00:06</p><p>﻿</p><p>prompt（）可以弹出一个提示框，该提示框会带有一个文本框，用户可以输入内容，该函数需要一个字符串作为阐述，该字符串将会提示框的提示文字</p><p>﻿</p><p>32.尚硅谷_JS基础_if练习二P32 - 12:06</p><p>﻿</p><p>var num1=+prompt(“请输入第一个数：”)//这样读取出来的是一个数字类型</p><p>﻿</p><p>33.尚硅谷_JS基础_条件分支语句P33 - 00:29</p><p>﻿</p><p>﻿</p><p>34.尚硅谷_JS基础_switch练习P34 - 07:18</p><p>﻿</p><p>Switch（）{</p><p>Case：</p><p>Case：</p><p>default：</p><p>}</p><p>﻿ ﻿</p><p>﻿</p><p>35.尚硅谷_JS基础_while循环P35 - 11:49</p><p>﻿</p><p>while和dowhile</p><p>﻿</p><p>36.尚硅谷_JS基础_while的练习P36 - 12:08</p><p>﻿</p><p>﻿</p><p>37.尚硅谷_JS基础_for循环P37 - 00:04</p><p>﻿</p><p>﻿ ﻿</p><p>﻿</p><p>38.尚硅谷_JS基础_for循环P38 - 00:10</p><p>﻿</p><p>﻿</p><p>39.尚硅谷_JS基础_质数练习P39 - 00:11</p><p>﻿</p><p>﻿</p><p>46.尚硅谷_JS基础_对象的简介P46 - 00:07</p><p>﻿</p><p>基本数据类型都是单一的值，值和值之间没有任何的联系。</p><p>在JS中表示一个人的信息</p><p>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。</p><p>对象的分类：</p><p>1、内建对象</p><p>在ES标准中定义的对象，在任何的ES的实现中都可以使用</p><p>2、宿主对象</p><p>由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象</p><p>比如BOM DOM</p><p>console.log()、Domcument对象都是浏览器搞好的</p><p>3、自定义对象</p><p>由开发人员创建的对象</p><p>﻿</p><p>47.尚硅谷_JS基础_对象的基本操作P47 - 00:04</p><p>﻿</p><p>创建对象</p><p>var obj=new Object();//使用new关键字调用的函数，是构造函数constructor。构造函数是专门用来创建对象的函数</p><p>使用typeof检查一个对象返回object。</p><p>//向对象中添加属性</p><p>语法：对象.属性名=属性值；</p><p>//读取对象中的属性</p><p>语法：对象.属性名</p><p>如果读取对象中没有的属性，不会报错而会返回undefined</p><p>//修改对象的属性值</p><p>语法：对象.属性名=新值</p><p>//删除对象的属性</p><p>语法：delete 对象.属性名</p><p>﻿</p><p>48.尚硅谷_JS基础_属性名和属性值P48 - 00:22</p><p>﻿</p><p>像对象中添加属性</p><p>属性名：</p><p>对象的属性名不强制要求遵守标识符的规（什么都可以用），但是尽量按照标识符的规范去做</p><p>如果确确实实需要使用特殊的属性名，不能采用.的方式来操作</p><p>需要使用另一种方式：</p><p>语法：对象【“属性名”】=属性值。取值的时候也需要采用对象【“属性名”】</p><p>使用【】这种形式去操作属性，更加灵活；</p><p>在【】中可以直接传递一个变量，这样变量是多少就会读取那个属性</p><p>﻿ ﻿</p><p>﻿ ﻿</p><p>﻿ ﻿</p><p>//属性值</p><p>JS对象的属性值，可以是任意的数据类型</p><p>//in运算符</p><p>通过该运算符可以检查一个对象中是否含有指定的属性</p><p>如果有返回true，没有返回的false</p><p>语法：“属性名” in 对象</p><p>﻿</p><p>49.尚硅谷_JS基础_基本数据类型和引用数据类型P49 - 00:08</p><p>﻿</p><p>JS中的变量都是保存在栈里面的</p><p>基本数据类型的值直接在栈内存中存储</p><p>值与值之间是独立存在的，修改一个变量不会影响其他的变量</p><p>对象是保存到堆内存中的，没创建一个新的对象，就会在堆内存中开辟出一个新的空间。。而变量中保存的是内存的地址（对象的引用），如果两个变量保存的是同一个对象的引用，当一个通过一个变量修改堆内存中的值之后另外的引用也会改变。</p><p>当比较两个基本数据类型的值时，就是直接去比较的值</p><p>而比较两个应用数据类型时，它是比较他们的内存地址。</p><p>两个对象，即使他们长得一模一样，他们也不是相等的（内存地址不一样）</p><p>﻿</p><p>50.尚硅谷_JS基础_对象字面量P50 - 00:06</p><p>﻿</p><p>使用字面量创建对象</p><p>var obj={}相等于var obj=new Object()；</p><p>使用对象字面量，可以在创建对象时，直接指定对象中的属性</p><p>语法：{属性名：属性值，属性名：属性值……}</p><p>对象字面量可以加引号也可以不加，建议不加</p><p>如果要使用一些特殊的名字，则必须加引号</p><p>属性名和属性值是一组一组的名值对结构，</p><p>名值对之间使用：冒号连接，多个名值对之间用，逗号隔开，最后一个不要写，逗号</p><p>﻿</p><p>51.尚硅谷_JS基础_函数的简介P51 - 00:21</p><p>﻿</p><p>函数：function</p><p>-函数也是一个对象</p><p>-函数中可以封装一些功能（代码），在需要时可以执行这些功能（代码）</p><p>-函数中可以保存代码需要时调用</p><p>//创建一个函数对象（构造方法）</p><p>var fun=new Function()</p><p>使用typeof检查一个函数对象时，会返回function</p><p>//封装到函数中的代码不会立即执行</p><p>//调用函数 语法：函数对象（）</p><p>//函数对象可以实现常用的对象功能</p><p>//我们在实际开发中很少使用构造函数来创建对象</p><p>直接使用函数声明来创建一个函数</p><p>语法：function 函数名（[形参1，形参2，形参N]）#带有中括号的代表着这个形参可以写也可以不写</p><p>匿名函数创造的方法：var func=function(){}</p><p>﻿</p><p>52.尚硅谷_JS基础_函数的参数P52 - 00:16</p><p>﻿</p><p>多个形参之间使用，逗号隔开，声明形参就相当于在函数内部声明了对应的变量但并不赋值</p><p>调用函数时不会检查实参的类型所以要注意是否有可能接收到非法的参数如果有可能则需要对类型的检查。</p><p>调用函数时，解析器也不会检查实参的数量，多余的实参不会被赋值（不用）如果实参少于形参的数量，没有被赋值的就为undefined</p><p>﻿</p><p>53.尚硅谷_JS基础_函数的返回值P53 - 00:37</p><p>﻿</p><p>return方法，可以作为结果返回（可以返回任何类型的值）</p><p>函数return之后的方法不会执行</p><p>﻿</p><p>54.尚硅谷_JS基础_实参可以是任何值P54 - 00:17</p><p>﻿</p><p>实参是任意的类型，也可以是一个对象</p><p>当我们的参数过多时，可以将参数封装到一个对象中，然后通过对象传递</p><p>实参可以是一个对象，也能是一个函数。将一个匿名函数作为实参传递给一个函数开发中经常遇到</p><p>如果不加括号传递一个函数的话传递的是那个函数处理的返回值在传递给他，如果加括号则传递的是函数这个对象，那么传入进去之后那个函数就可以使用被传入进来函数的方法</p><p>﻿</p><p>55.尚硅谷_JS基础_返回值的类型P55 - 00:19</p><p>﻿</p><p>continue跳过当次循环，但是还是要进行下一次循环</p><p>break跳出整个循环</p><p>return退出整个函数</p><p>返回值可以是任意的数据类型也可以是一个对象还可以是一个函数</p><p>可以在函数内部还可以声明函数，也可以作为返回值进行返回。</p><p>﻿</p><p>56.尚硅谷_JS基础_立即执行函数P56 - 00:11</p><p>﻿</p><p>调用一个匿名函数</p><p>(function(){alert(“我是一个匿名函数~~~”);})();</p><p>函数定义完就会被立即执行一次。</p><p>﻿</p><p>57.尚硅谷_JS基础_方法P57 - 00:07</p><p>﻿</p><p>对象的属性可以是任何的数据类型，也可以是个函数</p><p>函数也可以成为对象的属性，如果一个函数作为一个对象的属性保存，</p><p>那么我们成这个函数时这个对象的方法，调用函数就说调用对象的方法（method），但是它只是名称上的区别，没有其它的区别。</p><p>//调方法</p><p>obj.function()</p><p>//调函数</p><p>function()</p><p>枚举：</p><p>要知道对象中的所有属性。则需要使用枚举的方法，一个一个的取出来。使用for in语句</p><p>语法：for(var 变量 in 对象){}</p><p>还可以使用for(var n in boj){console.log(obj[n])}来输出属性值</p><p>﻿</p><p>58.尚硅谷_JS基础_全局作用域P58 - 00:08</p><p>﻿</p><p>作用域</p><p>-作用域指一个变量的作用范围</p><p>-在JS中一共有两种作用域：</p><p>全局作用域：</p><p>-直接编写在script中的JS代码，都作用在全局作用域</p><p>-全局作用域在页面打开的时候创建，页面关闭的时候销毁</p><p>-全局作用域中有一个全局对象window，我们可以直接使用。他代表的是一个浏览器的窗口。</p><p>-全局作用域中的变量都会作为window对象的属性保存</p><p>-全局作用域中的函数都会作为window对象的方法保存</p><p>1、变量的声明提前：</p><p>-使用var关键字声明的变量，会在所有的代码执行之前被声明，但是如果声明变量时不使用var关键字，则变量不会被声明提前。</p><p>2、函数的声明提前：</p><p>-使用函数声明形式创建的函数function函数（）{}。它会在所有的代码执行之前被创建。所以我们可以在函数声明前进行调用。</p><p>-使用函数表达式创建的函数var fun=function(){}。不会被提前创建。</p><p>-全局作用域中的变量都是全局变量，在我们的页面的任意部分都可以访问到</p><p>﻿</p><p>59.尚硅谷_JS基础_函数作用域P59 - 00:04</p><p>﻿</p><p>函数作用域：</p><p>-调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁</p><p>-每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的</p><p>-在函数作用域中可以访问到全局作用域的变量，但是在全局作用域中无法访问到函数作用域中的变量</p><p>-当在函数作用域中操作一个变量时，它会现在自身作用域中寻找，如果有就直接使用，如果没有则向上一级作用域中寻找（并不是指的是全局作用域）可以是上一级的函数中的变量。最后才会找到全局作用域中。如果全局作用域中都没有那就报错没有定义</p><p>﻿ ﻿</p><p>-在函数作用域中也有提前声明。类似于全局作用域的提前声明。</p><p>-在函数中如果不写var的话那就会成为全局变量（相当于window.变量名=变量值）</p><p>-定义形参就相当于在函数作用域中声明了变量。</p><p>﻿</p><p>60.尚硅谷_JS基础_debugP60 - 00:25</p><p>﻿</p><p>使用浏览器的Sources可以悬停一步一步的执行，可以验证var是否已经提前声明，添加进watch中就可以看到。</p><p>﻿</p><p>61.尚硅谷_JS基础_thisP61 - 00:03</p><p>﻿</p><p>解析器（浏览器）在调用函数每次都会向函数内部传递进一个隐含的参数。这个隐含的参数就是this。this指向的是一个对象。</p><p>这个对象我们称为函数执行的上下文对象。</p><p>根据函数的调用方式不同，this会指向不同的方向</p><p>1、以函数的形式调用时，this永远都是window。</p><p>2、以方法的形式调用时，this就是方法调用的对象</p><p>﻿</p><p>62.尚硅谷_JS基础_this补充P62 - 00:14</p><p>﻿</p><p>this可以根据调用者的不同来决定被调用的东西是什么，相当于java里面的父类</p><p>﻿</p><p>63.尚硅谷_JS基础_使用工厂方法创建对象P63 - 03:22</p><p>﻿</p><p>﻿</p><p>64.尚硅谷_JS基础_构造函数P64 - 17:57</p><p>﻿</p><p>1.立刻创建一个新的对象</p><p>2.将新建的对象设置为函数中this,在构造函数中可以使用this来引用新建的对象</p><p>3.逐行执行函数中的代码</p><p>4.将新建的对象作为返回值返回</p><p>使用同一个构造函数创建的对象，我们成为一类对象，也构造了一个类。创建的构造对象成为一个类的实例</p><p>﻿ ﻿</p><p>﻿</p><p>65.尚硅谷_JS基础_.构造函数修改P65 - 00:01</p><p>﻿</p><p>﻿ ﻿</p><p>直接在作用域中进行定义，让所有的构造方法都去调用同一个函数</p><p>﻿</p><p>66.尚硅谷_JS基础_原型对象P66 - 00:54</p><p>﻿</p><p>函数定义在全局作用域，污染全局作用域的命名空间，而且定义在全局作用域中也很不安全。</p><p>prototype圆形</p><p>我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype</p><p>-这个属性对应着一个对象，这个对象就是我们所谓的原型对象</p><p>﻿ ﻿</p><p>如果函数作为普通函数调用时prototype没有任何作用</p><p>当以构造对象进行调用时，它所创建的对象中都会有一个隐藏的属性指向该构造函数的原型对象，我们可以通过__proto__来访问该属性</p><p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，没我可以将对象中共有的内容，统一设置到原型对象中。</p><p>当我们访问对象的一个属性或方法时，它先在自身中寻找，如果没有则会去原型对象中寻找，如果找到则直接使用</p><p>-以后创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中。这样不用分别为每个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法</p><p>﻿</p><p>67.尚硅谷_JS基础_原型对象P67 - 00:03</p><p>﻿</p><p>使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true</p><p>可以使用对象的hasOwnProperty（）检查自身中是否含有该属性</p><p>原型对象也还有原型对象</p><p>-当我们在使用一个对象的属性或方法时，会先在自身中寻找，如果没有则去原型对象中寻找，如果原型对象中与他使用，再没有去原型的原型去寻找。</p><p>Object对象中的原型没有原型（最多两层），在Object中依然没有找到，则返回undefined。（原型链）</p><p>﻿</p><p>68.尚硅谷_JS基础_toString()P68 - 00:10</p><p>﻿</p><p>当直接在页面中打印一个对象时，事实上是输出对象的ToString（）方法的返回值（打印对象=打印返回值）</p><p>如果我们希望对象不输出【boject OBject】可以为对象添加一个ToString（）方法</p><p>﻿</p><p>69.尚硅谷_JS基础_垃圾回收P69 - 00:04</p><p>﻿</p><p>垃圾回收</p><p>对对象进行一系列操作之后，最后将对象的值改为object=null</p><p>当一个对象没有任何的变量或属性对它进行引用，此时我们永远无法操作该对象。</p><p>此时这种对象就是一个垃圾，导致程序变慢。在JS中拥有自动的垃圾回收机制。我们不需要也不能进行垃圾回收。如果需要回收就使用boject=null，让栈内存中的内存值设为null</p><p>﻿</p><p>70.尚硅谷_JS基础_数组简介P70 - 00:16</p><p>﻿</p><p>数组也是一个对象（Array）</p><p>和普通对象功能类似，也是用来储存一个值</p><p>不同的是普通对象是使用字符串作为属性名的，</p><p>-而数组时使用数字来作为索引操作元素</p><p>-索引：</p><p>从0开始的整数就是索引</p><p>数组的存储属性比普通对象好，在开发总我们经常使用数组来存储一些数据</p><p>使用typeof检查数组是返回object</p><p>语法：数组【索引】=值</p><p>arr[0]=10</p><p>读取数组中的元素</p><p>语法：数组【索引】</p><p>﻿ ﻿</p><p>像数组最后一个数组添加元素</p><p>语法：数组【数组.lenght】=值</p><p>﻿</p><p>71.尚硅谷_JS基础_数组字面量P71 - 00:49</p><p>﻿</p><p>可以直接使用var arr=[];创建数据</p><p>也可以使用构造函数的方法添加元素，将要添加元素构造函数的参数传递</p><p>var arr=new Array(10,20,30);</p><p>数组中的元素可以是任意的数据类型（包括对象）</p><p>arr=[“hello”,1,true,null,undefined]</p><p>﻿</p><p>72.尚硅谷_JS基础_数组的四个方法P72 - 00:15</p><p>﻿</p><p>push（）该方法可以想数组的末尾添加一个或多个元素，并返回数组的新的长度。这样这些元素将自动添加到数组的末尾</p><p>pop（）该方法可以删除数组的最后一个元素，并将删除的元素作为返回值返回</p><p>arr.unshift()往前面添加，想前面添加元素之后，其它的元素的下标都会调整。</p><p>arr.shift()删除数组的第一个元素并作返回值进行返回</p><p>﻿</p><p>73.尚硅谷_JS基础_数组的遍历P73 - 01:26</p><p>﻿</p><p>使用for循环来进行数组的遍历</p><p>arr.lenght</p><p>﻿</p><p>74.尚硅谷_JS基础_数组练习P74 - 01:07</p><p>﻿</p><p>﻿</p><p>75.尚硅谷_JS基础_forEachP75 - 00:07</p><p>﻿</p><p>了解一个forEach方法进行遍历数组</p><p>就是除了for循环的数组之外的遍历数组</p><p>arr.forEach(function(){})</p><p>forEach需要一个函数作为参数</p><p>-这种函数，由我们创建但是不由我们调用，我们成为回调函数</p><p>-数组中有几个数组就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以来定义形参，来读取这些内容</p><p>-浏览器会在回调函数中传递三个函数。</p><p>-第一个参数当前正在遍历的元素</p><p>-第二个参数当前正在遍历元素的索引</p><p>-第三个参数当前正在遍历的整个对象</p><p>支持IE8及以上的</p><p>﻿</p><p>76.尚硅谷_JS基础_slice和spliceP76 - 00:05</p><p>﻿</p><p>slice（）参数start，end开始和结束位置。该方法不会影响原数组。</p><p>截取位的索引包含开始不包含结束。前闭后开区间</p><p>-第二个参数可以省略不写。那就是全部截取</p><p>-索引也可以传递负值，如果传递一个负值那就是从后往前取</p><p>splice（）可以用于用于删除数组</p><p>splice（）会影响到原数组，会将制定元素从原数组中删除，并将删除的元素作为返回值返回。参数start，num。删除的从第几个开始以及删除的数量，第三个参数以后：可以传递新的元素，这些元素就会自动插入到开始位置索引前面</p><p>﻿</p><p>77.尚硅谷_JS基础_数组去重练习P77 - 00:06</p><p>﻿</p><p>﻿</p><p>78.尚硅谷_JS基础_数组的剩余方法P78 - 00:05</p><p>﻿</p><p>concat（）可以连接两个或多个数组，并将新的数组范围。该方法不会对原数组产生影响</p><p>join（）该方法可以将数组转换为一个字符串</p><p>-该方法不会对原数组产生影响，二十将转换后的字符串作为结果返回</p><p>-在join（）中可以指定一个字符串作为参数，这个字符串将成为数组中元素的连接符，如果不使用那就默认逗号，想要为空的话就改为一个空字符串</p><p>reverse（）该方法用来翻转数组，会直接修改原数组</p><p>sort（）对原数组进行排序，会影响原数组，按照Unicode编码进行排序。即使按照纯数字的数组排序，也会按照Unicode编码来排序，所以对数字排序的时候可能得到错误的结果</p><p>﻿ ﻿</p><p>﻿</p><p>79.尚硅谷_JS基础_call和applyP79 - 00:01</p><p>﻿</p><p>函数对象的方法call()和apply()</p><p>-这两个方法都是函数对象的方法，需要通过函数对象来调用</p><p>-当我们对函数进行调用call()和apply()和直接加()就可以使用</p><p>-使用call()和apply()可以将一个对象指定为一个参数</p><p>此时这个对象将会成为函数执行的this</p><p>-call()方法可以将实参在对象之后一次传递</p><p>-apply()方法需要将实参封装到一个数组中统一传递</p><p>-this的情况：</p><p>1、以函数形式调用时，this永远都是window</p><p>2、以方法的形式调用时，this是调用方法的对象</p><p>3、以构造函数的形式调用时，this是新创建的对象</p><p>4、使用call和apply调用时，this是指定的那个对象</p><p>﻿</p><p>80.尚硅谷_JS基础_argumentsP80 - 00:23</p><p>﻿</p><p>在调用函数时，浏览器每次都会传递进两个隐含的参数。</p><p>1、第一个是函数的上下文对象this。</p><p>2、第二个是封装实参的arguments</p><p>-arguments是一个类数组对象（但是不是一个数组），它也可以通过参数索引来操作数据，也可以获取长度。</p><p>-在调用函数时，我们所传递的实参都会在arguments中保存</p><p>-即使不定义形参，也可以通过arguments的下标来使用实参。</p><p>-它里面还有一个属性叫做callee，对应的一个函数对象，就是我们当前正在执行的函数对象</p><p>﻿</p><p>81.尚硅谷_JS基础_Date对象P81 - 00:12</p><p>﻿</p><p>Date对象</p><p>-在JS中使用Date对象来表示一个时间</p><p>如果直接使用构造函数去创建一个Date对象，则会封装为当前代码的执行时间</p><p>创建指定的一个时间对象：格式：月份/日/年 时：分：秒</p><p>getDay（）返回当前日期的周几0表示周日，1周一</p><p>getMonth（）返回当前日期的月份</p><p>0表示1月，1表示2月，2表示3月</p><p>getTime（）返回当前日期对象的时间戳</p><p>-时间戳，指的是从格林威治的标准时间到现在的毫秒数的及时（计算机底层在保存时间使用时间戳保存）</p><p>获取我们当前的时间戳Date.Now();</p><p>﻿</p><p>82.尚硅谷_JS基础_MathP82 - 00:05</p><p>﻿</p><p>Math</p><p>-Math和其它对象不同，它不算一个构造函数。</p><p>术语工具类不用创建对象，它里面封装数学计算的方法</p><p>Math.ceil()方法小数点只要有值都自动进1。向上取整</p><p>Math.floor()方法小数点只要有值都自动抹去。向下取整</p><p>﻿</p><p>96.尚硅谷_JS基础_DOM查询P96 - 00:37</p><p>﻿</p><p>获取某个元素下的子元素，需要使用该元素名在寻找子元素名。语法：元素名.getElementById()</p><p>childnodes获取包括文本节点在内的所有节点。</p><p>根据DOM的换行也会当成文本节点，但是在IE8一下的浏览器中，不会将空白文本当成子节点，</p><p>children属性可以获取当前元素的子元素（不会有空格）比childnodes好很多</p><p>firstChild第一个子节点</p><p>firstElementChild第一个子元素（不支持IE8以下）</p><p>﻿</p><p>97.尚硅谷_JS基础_DOM查询P97 - 00:40</p><p>﻿</p><p>定义一个函数，专门用来指定元素绑定单击响应函数</p><p>参数：</p><p>idStr要绑定单机相应函数的对象的id属性值</p><p>fun事件回调函数，当点击元素时，使用回调函数</p><p>父节点：parentNode</p><p>innerHTML获取到元素内部中的html代码。而innerText则获取到元素内部中的文字，去除了标签部分</p><p>.previousSibling前一个兄弟节点（包括空格）</p><p>.previousElementSibling前一个兄弟元素</p><p>文本框的value属性值就是文本框中填写的内容</p><p>文本中的nodeValue就是他文本的值。</p><p>﻿</p><p>98.尚硅谷_JS基础_全选练习（一）P98 - 00:17</p><p>﻿</p><p>﻿</p><p>99.尚硅谷_JS基础_全选练习（二）P99 - 12:15</p><p>﻿</p><p>在时间的响应函数中，响应函数是给谁绑定的this就是</p><p>﻿</p><p>﻿</p><p>102.尚硅谷_JS基础_dom增删改P102 - 00:10</p><p>﻿</p><p>createElement（）可以创建一个元素节点对象，需要一个标签名作为参数，将会根据标签名创建元素节点对象，并将创建好的对象作为返回值</p><p>createTextNode()创建文本节点，需要一个文本内容作为参数，会根据该内容创建文本节点，将新的节点返回</p><p>appendChild（）向一个父节点添加一个新的子节点。</p><p>用法：父节点.appendChild(子节点)</p><p>﻿</p><p>103.尚硅谷_JS基础_添加删除记录-删除P103 - 00:11</p><p>﻿</p><p>﻿</p><p>104.尚硅谷_JS基础_添加删除记录-添加P104 - 00:08</p><p>﻿</p><p>﻿</p><p>104.尚硅谷_JS基础_添加删除记录-添加P104 - 00:42</p><p>﻿</p><p>﻿</p><p>105.尚硅谷_JS基础_添加删除记录-修改P105 - 00:26</p><p>﻿﻿</p><p>108.尚硅谷_JS基础_获取元素的样式P108 - 00:37</p><p>﻿</p><p>document.style.样式获取的是内联样式并不是样式表中的样式</p><p>读取元素当前样式：</p><p>语法：元素.currentStyle.样式名</p><p>它可以用来读取当前正在显示的样式（虽然好用但是只有IE支持）</p><p>在其他浏览器中使用getComputedStyle()这个方法来获取当前的样式，这个方法是window的方法，可以直接使用。两个参数：第一个：要获取样式的元素，第二个：传递一个伪元素，一般都传null。该方法返回一个对象，对象中封装了当前元素的对应样式</p><p>该方法会返回一个对象，对象封装了当前元素对应的样式（该方法不支持IE8以下浏览器）</p><p>要做到都兼容自己写一个函数：</p><p>参数：obj获取样式的元素。name要获取的样式名。</p><p>通过currentStyle和getComputedStyle()读取到的样式都是只读的，不能修改，如果要修改必须通过style属性</p><p>﻿</p><p>109.尚硅谷_JS基础_getStyle()方法P109 - 00:04</p><p>﻿</p><p>找对象的属性而不是变量，找不到属性为undefined，所以他转换为false就是走else中的。但是如果找不到变量那就报错了</p><p>﻿</p><p>110.尚硅谷_JS基础_其他样式相关的属性P110 - 00:35</p><p>﻿</p><p>clientWidth可见宽度</p><p>clientHeight可见高度</p><p>-这些属性都不带PX，返回一个数字，可以直接计算</p><p>-获取元素宽度和高度，包括内容区和内边距</p><p>-这些属性都是只读的不能进行修改，只能通过style进行修改</p><p>offsetWidth</p><p>offsetHeight</p><p>-获取元素的整个的宽度和高度，包括内容与、内边距边框</p><p>offsetParent</p><p>-可以获取当前元素的定位父元素</p><p>-会获取到离当前元素最近的开启了定位的祖先元素</p><p>-如果所有的祖先元素都没有开启则返回body</p><p>offsetLeft</p><p>-当前元素相对于其定位元素的水平偏移量</p><p>OffsetTop</p><p>-当前元素相对于其定位元素的垂直偏移量</p><p>scrollWidth和scrollHeight</p><p>-当前元素的滚动区域的高度和宽度</p><p>scrollLeft</p><p>-可以获取水平滚动条滚动的距离</p><p>scrollTop</p><p>-可以获取垂直滚动条滚动的距离</p><p>当满足scrollHeight-scrollTop==clientHeight。说明垂直滚动条到底了。</p><p>当满足scrollWidth-scrollLeft==clientWidth。说明水平滚动条滚动到底</p><p>overflow：auto调出滚动条出来</p><p>﻿</p><p>111.尚硅谷_JS基础_事件对象P111 - 03:33</p><p>﻿</p><p>onmousemove</p><p>该事件会在鼠标在元素中移动时触发</p><p>事件对象</p><p>当事件的相应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数</p><p>在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标 键盘哪个按键被按下 鼠标的滚轮滚动方向。。。</p><p>在IE8中，响应函数被触发时，浏览器不会传递时间对象。</p><p>﻿</p><p>112.尚硅谷_JS基础_div跟随鼠标移动P112 - 01:45</p><p>﻿</p><p>div块鼠标跟着一起动</p><p>想要设置位置left和top就一定要开启绝对定位absolute</p><p>pageX和pageY可以获取相对于页面的定位</p><p>﻿</p><p>113.尚硅谷_JS基础_事件的冒泡P113 - 00:04</p><p>﻿</p><p>事件的冒泡（Bubble）</p><p>    -所谓的冒泡值的就是事件的向上传到，当后代的元素被触发时，祖先相同事件也会触发</p><p>    -在开发中大部分冒泡是有用的，如果不希望事件冒泡可以通过事件对象来取消冒泡</p><p>    </p><p>﻿</p><p>114.尚硅谷_JS基础_事件的委派P114 - 05:18</p><p>﻿</p><p>为每个超链接都绑定一个单击相应函数</p><p>这里我们为每一个超链接都绑定一个单机响应函数，这种操作麻烦，而且这些操作只能为已经有的添加设置时间，而重新添加的超链接必须重新绑定</p><p>我们希望，只绑定一次时间，即可应用到多个元素上，即使元素是后添加的，我们可以尝试绑定给元素共同的祖先元素</p><p>事件的委派：</p><p>-指将时间统一绑定给元素的共同的祖先元素，这样当后代元素的时间触发时，会一直冒泡到祖先元素从而通过祖先元素的响应函数来处理事件</p><p>-时间委派是利用了冒泡，通过委派可以减少时间绑定的次数，提高程序性能</p><p>﻿</p><p>115.尚硅谷_JS基础_事件的绑定P115 - 01:56</p><p>﻿</p><p>使用 对象.时间=函数 的形式绑定响应函数。</p><p>它只能同时为一个元素的一个事件绑定一个响应函数，不能绑定多个，如果绑定了多个，后面的会被覆盖</p><p>可以通过监听器的方法就可以addEventListener（）；</p><p>参数：1.时间的字符串，不要on。2.回调函数，3.是否在捕获阶段触发，需要一个布尔值，一般都传false。</p><p>使用addEventListener（）可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数会按照函数绑定的顺序执行。</p><p>在IE8中可以使用attachEvent（）来绑定事件，</p><p>参数：1.事件的字符串，要on，2.回调函数</p><p>-这个方法也可以同时为一个时间绑定多个处理函数。不同的是后绑定先执行，执行顺序和addEventListener（）相反。</p><p>﻿</p><p>116.尚硅谷_JS基础_完成bind函数P116 - 00:00</p><p>﻿</p><p>﻿</p><p>117.尚硅谷_JS基础_事件的传播P117 - 00:43</p><p>﻿</p><p>事件的传播</p><p>-关于时间的传播微软和网景不同的理解</p><p>-微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素的事件，然后再向前元素的祖先元素上传播，也就是说应该在冒泡上实行。</p><p>-网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素外层的祖先事件。事件的捕获</p><p>W3C综合了两个公司的方案，将事件传播分为了三个阶段：</p><p>-1、捕获阶段</p><p>在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件。</p><p>-2、目标阶段</p><p>事件捕获到目标元素，捕获结束开始在目标元素上触发事件</p><p>-3、冒泡阶段</p><p>事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件</p><p>-如果希望在捕获阶段就将addEventListener中第三个参数设置为true。一般情况下我们不会希望在捕获触发。IE8以下没有</p><p>﻿</p><p>118.尚硅谷_JS基础_拖拽（一）P118 - 00:21</p><p>﻿</p><p>拖拽的过程</p><p>    1、当鼠标被拖拽元素按下，开始拖拽onmousedown</p><p>    2、当鼠标移动时拖拽元素跟随移动onmousemove</p><p>    3、当鼠标松开时元素固定当前位置onmouseup</p><p>﻿</p><p>119.尚硅谷_JS基础_拖拽（二）P119 - 01:48</p><p>﻿</p><p>﻿ ﻿</p><p>﻿</p><p>120.尚硅谷_JS基础_拖拽（三）P120 - 04:54</p><p>﻿</p><p>﻿ ﻿</p><p>但是对IE8不起作用</p><p>当调用一个元素的setCapture()</p><p>﻿</p><p>121.尚硅谷_JS基础_滚轮的事件P121 - 00:11</p><p>﻿</p><p>鼠标滚轮滚动事件</p><p>onmousewheel（），在火狐中需要使用DOMMouseScroll来绑定滚动事件注意该事件需要通过addEventListener()函数来绑定火狐浏览器的滚动条时间，通过event.wheelDelta的正负值大小判断滑动轨迹</p><p>﻿</p><p>122.尚硅谷_JS基础_键盘事件P122 - 00:29</p><p>﻿</p><p>键盘事件：onkeydown、onkeyup键盘被按下、松开</p><p>键盘事件一般都会绑定到能够获取焦点的对象document</p><p>onkeydown：</p><p>-按键被按下</p><p>-对于onkeydown来说如果一直按着某个按键不松手，该事件会一直触发</p><p>-当onkeydown连续触发时，开始输入慢，防误操</p><p>altKey、ctrlKey、shiftKey公用按键用与方法判断是否被同时按下</p><p>﻿</p><p>124.尚硅谷_JS基础_NavigatorP124 - 01:19</p><p>﻿</p><p>Bom可以使我们通过JS来操作浏览器</p><p>在Bom中为我们提供了一组对象，用来完成浏览器的操作</p><p>Bom对象</p><p>-Window</p><p>代表的是整个浏览器的窗口，同时window也是网页中的全局对象</p><p>-Navigator</p><p>代表的当前浏览器的信息，通过该对象可以识别不同的浏览器。</p><p>由于历史原因Navigator对象</p><p>一般我们只会使用userAgent来判断浏览器的信息，就是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器有不同的userAgent</p><p>-Location</p><p>代表当前浏览器的地址栏信息，通过Location可以操作浏览器跳转页面</p><p>-History</p><p>代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页。</p><p>而且此操作只在当次访问有效</p><p>-Screen</p><p>代表用户的屏幕的信息，通过该对象获得显示器的相关信息</p><p>这些BOM对象在浏览器中都是作为window对象的属性保存的。可以通过window对象来使用，也可以直接使用</p><p>﻿</p><p>124.尚硅谷_JS基础_NavigatorP124 - 41:05</p><p>﻿</p><p>找出IE的方法具体在代码里</p><p>﻿</p><p>125.尚硅谷_JS基础_HistoryP125 - 04:30</p><p>﻿</p><p>-History</p><p>代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页。</p><p>而且此操作只在当次访问有效</p><p>﻿</p><p>126.尚硅谷_JS基础_LocationP126 - 00:07</p><p>﻿</p><p>-Location</p><p>该对象封装了对象中的地址栏信息</p><p>如果直接打印Location可以获取到地址栏完整信息如果直接将Location修改为一个完整路径或相对路径会自动跳转并生成响应历史记录</p><p>-assign()用以跳转，跟Location方法差不多</p><p>location..assign(“<a href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a>)</p><p>location.reload(true)进行强制清空缓存刷新</p><p>    location.replace()方法进行跳转不会生成历史记录不能回退</p><p>﻿</p><p>127.尚硅谷_JS基础_定时器简介P127 - 00:15</p><p>﻿</p><p>JS程序的执行速度是非常快的</p><p>定时调用，如果需要一段程序每间隔一段时间执行一次，可以使用定时调用</p><p>timer=setInterval()</p><p>-定时调用</p><p>-可以将一个函数，每隔一段时间事件执行一次</p><p>-参数：</p><p>1、回调函数，该函数每隔一段时间被调用一次</p><p>2、每次调用的时间间隔，单位是毫秒</p><p>关闭定时器：</p><p>返回一个Number类型的数据</p><p>clearInterval(timer)</p><p>128.尚硅谷_JS基础_切换图片练习P128 - 10:49</p><p>﻿</p><p>clearInterval（）可以接受任意参数</p><p>如果参数是一个有效的定时器的表示，则停止对应的定时器，如果参数是一个无效的不发生效果。</p><p>目前我们每次点一次按钮，则会开启一个定时器，</p><p>所以我们每次开启一个定时器之前都要关闭另一个当前元素的其它定时器</p><p>﻿</p><p>129.尚硅谷_JS基础_修改div移动练习P129 - 00:20</p><p>﻿</p><p>﻿</p><p>130.尚硅谷_JS基础_延时调用P130 - 00:03</p><p>﻿</p><p>延时调用</p><p>延时调用一个函数不马上执行，而是隔一段时间执行只执行一次</p><p>延时调用和定时调用的区别，定时调用会调用多次，延时调用只调用一次</p><p>延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要</p><p>﻿</p><p>131.尚硅谷_JS基础_定时器的应用（一）P131 - 00:03</p><p>﻿</p><p>把移动位置修改成为一个函数进行包装一下复用性强</p><p>﻿</p><p>133.尚硅谷_JS基础_定时器的应用（三）P133 - 00:18</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/09/10/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/09/10/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>100.尚硅谷_JS基础_全选练习（三）P100 - 02:24</p><p>﻿</p><p>﻿</p><p>101.尚硅谷_JS基础_dom查询的剩余方法P101 - 00:16</p><p>﻿</p><p>Dom查询其它方法</p><p>获取body标签getElementByTagName(“body”)[0]</p><p>在document中有一个属性body，它保存的是body的引用</p><p>documentElement保存的是html的根标签</p><p>document.all代表页面中的所有元素</p><p>document.querySelector()这个方法很强大，需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查询一个元素节点对象。</p><p>使用该方法会返回唯一的一个元素，如果满足条件的元素有多个那么它只会返回第一个。</p><p>document.querySelectorAll()这个方法就可以查询到所有的classname的方法。不同的是符合条件的元素封装到一个数组中进行返回。即使只有一个也返回数组</p><p>字面量：都是一些不可改变的值</p><p>自变量都是可以直接使用，但是我们一般都不直接使用字面量<br>变量：可以用来保存字面量，变量的值是可以任意改变的</p><p>变量更加方便我们使用，所以开发中通过变量保存一个字面量<br>05.尚硅谷_JS基础_字面量和变量P5 - 01:53</p><p>标识符</p><p>在JS中自主命令的都称为标识符<br>例如：变量名、函数名、属性名都属于标识符<br>命名规则如下：<br>标识符可以含有字母、数字、__、$</p><p>标识符不能以数字开头。</p><p>标识符不能是ES中的关键字或保留字。</p><p>标识符一般采用驼峰命名法。helloWorld</p><p>JS底层保存标识符实际上是采用的Unicode编码，<br>07.尚硅谷_JS基础_字符串P7 - 00:26</p><p>JS中一共有六种数据类型</p><p>String 字符串<br>Number 数字<br>Boolean 布尔值<br>Null 控制<br>Undefinged 未定义<br>Object 对象<br>引用数据类型：Object，其它都是基本数据类型</p><p>字符串：</p><p>在JS中字符需要使用引号引起来（单双引号都可以）</p><p>引号不能嵌套，双引号不能放双引号，单引号不能放单引号（如果非要用就必须使用转义字符\）</p><p>当表示一些特殊符号时可以使用\进行转义</p><p>&quot;表示“ \‘表示’</p><p>﻿</p><p>07.尚硅谷_JS基础_字符串P7 - 14:42</p><p>﻿</p><p>﻿</p><p>08.尚硅谷_JS基础_NumberP8 - 00:40</p><p>﻿</p><p>数值类型，浮点整数都是</p><p>使用typeof来检查一个类型的变量</p><p>ptyeof a表示检查a变量的类型</p><p>JS表示Number的最大值number.MAX_VALUE</p><p>如果使用的Number表示的数字超过了最大值，则会返回一个Infinity无穷。</p><p>使用typeof检查Infinity也会返回Number他也是一个数字</p><p>NaN是一个特殊的数字，表示Not A Number不是一个数字</p><p>Number.MIN_VALUE表示0以上可表示的最小值5e-300</p><p>var c=0.1+0.2如果使用JS进行浮点元素，可能得到一个不精确的结果，所以千万不要使用JS进行对精确度要求较高的运算</p><p>﻿</p><p>09.尚硅谷_JS基础_布尔值P9 - 00:16</p><p>﻿</p><p>布尔值只有两个：</p><p>True和False</p><p>﻿</p><p>10.尚硅谷_JS基础_Null和UndefinedP10 - 00:45</p><p>﻿</p><p>Null类型的值只有一个，就是Null</p><p>Null值专门表示一个为空的对象</p><p>Null进行检查时返回的是Object的</p><p>Undefined类型的值只有一个，就undefined（未定义）</p><p>当声明一个变量，但并不给他赋值，那它就是undefined</p><p>使用typeof检查时也是undefined</p><p>﻿</p><p>11.尚硅谷_JS基础_强制类型转换-StringP11 - 00:03</p><p>﻿</p><p>强制类型转换：</p><p>指将一个类型数据强制转换为其它的数据类型</p><p>类型转换主要是指，将其它的数据类型，转换为</p><p>String Number Boolean</p><p>将其它的数据类型转换为String</p><p>方式1、调用被转换数据的ToSting（）方法（这种方法不会改变原始的数据类型）</p><p>Null和Undefined没有ToString方法如果硬调用会保存</p><p>方式2、调用String（）函数，并将被转换的数据作为参数传递给函数。</p><p>对于Number和Boolean实际上调用的ToString（）方法但是对于Null直接转换为“null”，将Undefined转换为“Undefined”</p><p>﻿</p><p>12.尚硅谷_JS基础_强制类型转换-NumberP12 - 00:00</p><p>﻿</p><p>将其它的数据类型转换为Number</p><p>转换方式一：</p><p>使用Number（）函数</p><p>-字符串转换为数字</p><p>1.如果是纯数字的字符串，则直接转换为纯数字的字符串</p><p>2.如果字符串中有非数字的内容，则转换为NaN</p><ol start="3"><li>如果字符串是空船或者是一个全是空格的字符，那么将转换为0</li></ol><p>-布尔值转换为数字</p><p>1.True转为1，False转为0</p><p>-Null转换为0</p><p>-Undefined转换数字为NaN</p><p>转换方式二：</p><p>例如：a=123px123，使用下面方法可以转出123来不转换出px后面的直接忽略掉</p><p>parseInt（）把一个字符串转换为一个整数</p><p>如果对非String使用parseInt（）或parseFloat（）先转换为String再转换成为number</p><p>parseFloat（）把一个字符串转换为一个浮点数</p><p>﻿</p><p>13.尚硅谷_JS基础_其他进制的数字P13 - 00:11</p><p>﻿</p><p>其它进制的数据</p><p>在js中，如果需要表示16进制的数字，则需要以0x开头</p><p>例如a=0x10；那么a的输出值就是16</p><p>如果需要表示8进制的数字，则需要以0开头</p><p>例如a=070；那么a的输出为56</p><p>如果需要表示2进制的数字，则需要以0b开头</p><p>例如a=0b10,；那么a的输出为2</p><p>a=parseInt(a,10)传递第二个参数，来指定数字的进制</p><p>﻿</p><p>14.尚硅谷_JS基础_转换为BooleanP14 - 00:12</p><p>﻿</p><p>转换为Boolean</p><p>方式：使用Boolean（）函数</p><p>var a=123;</p><p>a=Boolean(a)转换为True。</p><p>数字转Boolean规则为0和NaN为False其余为True</p><p>字符串转Boolean除了空串为false其余为True</p><p>Null和Undefined只能转换为False</p><p>对象也会转换为True</p><p>﻿</p><p>15.尚硅谷_JS基础_算数运算符P15 - 00:15</p><p>﻿</p><p>任何值和字符串相加都会转换为字符串再做拼接</p><p>隐式的类型转换，一个数值number+一个””空字符串，他就会自动调用ToString方法进行转换。</p><p>除了+法之外，其它都会把他转成Number形在进行</p><p>（隐式转换）可以通过一个值 -0 *1 /1来将其转换为Number</p><p>原理和Number()函数（显式转换）一样，使用起来更简单</p><p>﻿</p><p>16.尚硅谷_JS基础_一元运算符P16 - 00:03</p><p>﻿</p><p>单目运算符（一元运算符）：</p><p>+正号</p><p>不会对数字产生任何影响</p><p>-负号</p><p>对原来的数字进行取反</p><p>可以对一个其他的数据使用+，来将进行转换为Number</p><p>例如：a=1+(+”2”)+3，a就会输出为6</p><p>﻿</p><p>17.尚硅谷_JS基础_自增和自减P17 - 00:28</p><p>﻿</p><p>++通过自增可以使变量在自身的基础上加1</p><p>后++和前++，无论是哪个都会使原变量的值自增1，</p><p>不同的是a++和++a的值不同</p><p>a++的值等于原变量的值（自增前的值）后自增</p><p>++a的值等于原变量的值（自增后的值）先自增</p><p>–通过自减可以是变量在自身的基础上减1</p><p>前–和后–，无论是a–还是–a都会立即使原变量的值自减1</p><p>不同的是a–和–a的值不同（与前后++规则相同）</p><p>﻿</p><p>18.尚硅谷_JS基础_自增练习P18 - 00:20</p><p>﻿</p><p>﻿ ﻿</p><p>﻿</p><p>19.尚硅谷_JS基础_逻辑运算符P19 - 00:13</p><p>﻿</p><p>如果对非Boolean值进行取反，那么他就先转换为Boolean再进行取反</p><p>﻿</p><p>20.尚硅谷_JS基础_非布尔值的与或运算P20 - 00:02</p><p>﻿</p><p>对于非布尔值的与或运算，会将其转换为布尔值，然后再运算并且返回原值</p><p>与运算，如果两个都为True则返回后面的</p><p>如果有False则返回0，如果有两个False则返回靠前的False</p><p>﻿ ﻿</p><p>﻿</p><p>21.尚硅谷_JS基础_赋值运算符P21 - 00:11</p><p>﻿</p><p>﻿</p><p>23.尚硅谷_JS基础_Unicode编码表P23 - 00:12</p><p>﻿</p><p>在字符串中使用转移字符表\u</p><p>例如：我们要输出一个1就是\u2040</p><p>在网页中就是&amp;#；不过这儿需要的是十进制，需要把十六进制转为十进制</p><p>﻿</p><p>24尚硅谷_JS基础_相等运算符P24 - 00:24</p><p>﻿</p><p>﻿ ﻿</p><p>使用==是，他会自动转换类型，转换成什么不一定大部分会转换成为数字</p><p>NaN不和任何值相等（包括自身都不等）。Undefined衍生自Null所以他和Null相等</p><p>可以通过isNaN（）函数来判断是否是NaN返回true和False</p><p>===全等</p><p>判断两个值是否全等，它和相似相等，但是不会做相应转换</p><p>！==全等</p><p>判断两个值是否不全等，它和不相等相似，但不会进行转换</p><p>﻿</p><p>25.尚硅谷_JS基础_条件运算符P25 - 00:05</p><p>﻿</p><p>条件运算符也叫三元运算符</p><p>语法：</p><p>条件表达式?语句1：语句2;</p><p>﻿ ﻿</p><p>会将其条件表达式转换为布尔值之后再进行运算</p><p>﻿</p><p>26.尚硅谷_JS基础_运算符的优先级P26 - 00:41</p><p>﻿</p><p>，逗号可以同时声明多个变量</p><p>可以使用()来改变优先级</p><p>﻿</p><p>27.尚硅谷_JS基础_代码块P27 - 00:24</p><p>﻿</p><p>﻿ ﻿</p><p>JS中的代码块，只具有分组的作用，没有其他的用途</p><p>代码块内容的内容，在外部是完全可见的</p><p>﻿</p><p>28.尚硅谷_JS基础_if语句（一）P28 - 00:27</p><p>﻿</p><p>﻿</p><p>29.尚硅谷_JS基础_if语句（二）P29 - 00:06</p><p>﻿</p><p>prompt（）可以弹出一个提示框，该提示框会带有一个文本框，用户可以输入内容，该函数需要一个字符串作为阐述，该字符串将会提示框的提示文字</p><p>﻿</p><p>32.尚硅谷_JS基础_if练习二P32 - 12:06</p><p>﻿</p><p>var num1=+prompt(“请输入第一个数：”)//这样读取出来的是一个数字类型</p><p>﻿</p><p>33.尚硅谷_JS基础_条件分支语句P33 - 00:29</p><p>﻿</p><p>﻿</p><p>34.尚硅谷_JS基础_switch练习P34 - 07:18</p><p>﻿</p><p>Switch（）{</p><p>Case：</p><p>Case：</p><p>default：</p><p>}</p><p>﻿ ﻿</p><p>﻿</p><p>35.尚硅谷_JS基础_while循环P35 - 11:49</p><p>﻿</p><p>while和dowhile</p><p>﻿</p><p>36.尚硅谷_JS基础_while的练习P36 - 12:08</p><p>﻿</p><p>﻿</p><p>37.尚硅谷_JS基础_for循环P37 - 00:04</p><p>﻿</p><p>﻿ ﻿</p><p>﻿</p><p>38.尚硅谷_JS基础_for循环P38 - 00:10</p><p>﻿</p><p>﻿</p><p>39.尚硅谷_JS基础_质数练习P39 - 00:11</p><p>﻿</p><p>﻿</p><p>46.尚硅谷_JS基础_对象的简介P46 - 00:07</p><p>﻿</p><p>基本数据类型都是单一的值，值和值之间没有任何的联系。</p><p>在JS中表示一个人的信息</p><p>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。</p><p>对象的分类：</p><p>1、内建对象</p><p>在ES标准中定义的对象，在任何的ES的实现中都可以使用</p><p>2、宿主对象</p><p>由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象</p><p>比如BOM DOM</p><p>console.log()、Domcument对象都是浏览器搞好的</p><p>3、自定义对象</p><p>由开发人员创建的对象</p><p>﻿</p><p>47.尚硅谷_JS基础_对象的基本操作P47 - 00:04</p><p>﻿</p><p>创建对象</p><p>var obj=new Object();//使用new关键字调用的函数，是构造函数constructor。构造函数是专门用来创建对象的函数</p><p>使用typeof检查一个对象返回object。</p><p>//向对象中添加属性</p><p>语法：对象.属性名=属性值；</p><p>//读取对象中的属性</p><p>语法：对象.属性名</p><p>如果读取对象中没有的属性，不会报错而会返回undefined</p><p>//修改对象的属性值</p><p>语法：对象.属性名=新值</p><p>//删除对象的属性</p><p>语法：delete 对象.属性名</p><p>﻿</p><p>48.尚硅谷_JS基础_属性名和属性值P48 - 00:22</p><p>﻿</p><p>像对象中添加属性</p><p>属性名：</p><p>对象的属性名不强制要求遵守标识符的规（什么都可以用），但是尽量按照标识符的规范去做</p><p>如果确确实实需要使用特殊的属性名，不能采用.的方式来操作</p><p>需要使用另一种方式：</p><p>语法：对象【“属性名”】=属性值。取值的时候也需要采用对象【“属性名”】</p><p>使用【】这种形式去操作属性，更加灵活；</p><p>在【】中可以直接传递一个变量，这样变量是多少就会读取那个属性</p><p>﻿ ﻿</p><p>﻿ ﻿</p><p>﻿ ﻿</p><p>//属性值</p><p>JS对象的属性值，可以是任意的数据类型</p><p>//in运算符</p><p>通过该运算符可以检查一个对象中是否含有指定的属性</p><p>如果有返回true，没有返回的false</p><p>语法：“属性名” in 对象</p><p>﻿</p><p>49.尚硅谷_JS基础_基本数据类型和引用数据类型P49 - 00:08</p><p>﻿</p><p>JS中的变量都是保存在栈里面的</p><p>基本数据类型的值直接在栈内存中存储</p><p>值与值之间是独立存在的，修改一个变量不会影响其他的变量</p><p>对象是保存到堆内存中的，没创建一个新的对象，就会在堆内存中开辟出一个新的空间。。而变量中保存的是内存的地址（对象的引用），如果两个变量保存的是同一个对象的引用，当一个通过一个变量修改堆内存中的值之后另外的引用也会改变。</p><p>当比较两个基本数据类型的值时，就是直接去比较的值</p><p>而比较两个应用数据类型时，它是比较他们的内存地址。</p><p>两个对象，即使他们长得一模一样，他们也不是相等的（内存地址不一样）</p><p>﻿</p><p>50.尚硅谷_JS基础_对象字面量P50 - 00:06</p><p>﻿</p><p>使用字面量创建对象</p><p>var obj={}相等于var obj=new Object()；</p><p>使用对象字面量，可以在创建对象时，直接指定对象中的属性</p><p>语法：{属性名：属性值，属性名：属性值……}</p><p>对象字面量可以加引号也可以不加，建议不加</p><p>如果要使用一些特殊的名字，则必须加引号</p><p>属性名和属性值是一组一组的名值对结构，</p><p>名值对之间使用：冒号连接，多个名值对之间用，逗号隔开，最后一个不要写，逗号</p><p>﻿</p><p>51.尚硅谷_JS基础_函数的简介P51 - 00:21</p><p>﻿</p><p>函数：function</p><p>-函数也是一个对象</p><p>-函数中可以封装一些功能（代码），在需要时可以执行这些功能（代码）</p><p>-函数中可以保存代码需要时调用</p><p>//创建一个函数对象（构造方法）</p><p>var fun=new Function()</p><p>使用typeof检查一个函数对象时，会返回function</p><p>//封装到函数中的代码不会立即执行</p><p>//调用函数 语法：函数对象（）</p><p>//函数对象可以实现常用的对象功能</p><p>//我们在实际开发中很少使用构造函数来创建对象</p><p>直接使用函数声明来创建一个函数</p><p>语法：function 函数名（[形参1，形参2，形参N]）#带有中括号的代表着这个形参可以写也可以不写</p><p>匿名函数创造的方法：var func=function(){}</p><p>﻿</p><p>52.尚硅谷_JS基础_函数的参数P52 - 00:16</p><p>﻿</p><p>多个形参之间使用，逗号隔开，声明形参就相当于在函数内部声明了对应的变量但并不赋值</p><p>调用函数时不会检查实参的类型所以要注意是否有可能接收到非法的参数如果有可能则需要对类型的检查。</p><p>调用函数时，解析器也不会检查实参的数量，多余的实参不会被赋值（不用）如果实参少于形参的数量，没有被赋值的就为undefined</p><p>﻿</p><p>53.尚硅谷_JS基础_函数的返回值P53 - 00:37</p><p>﻿</p><p>return方法，可以作为结果返回（可以返回任何类型的值）</p><p>函数return之后的方法不会执行</p><p>﻿</p><p>54.尚硅谷_JS基础_实参可以是任何值P54 - 00:17</p><p>﻿</p><p>实参是任意的类型，也可以是一个对象</p><p>当我们的参数过多时，可以将参数封装到一个对象中，然后通过对象传递</p><p>实参可以是一个对象，也能是一个函数。将一个匿名函数作为实参传递给一个函数开发中经常遇到</p><p>如果不加括号传递一个函数的话传递的是那个函数处理的返回值在传递给他，如果加括号则传递的是函数这个对象，那么传入进去之后那个函数就可以使用被传入进来函数的方法</p><p>﻿</p><p>55.尚硅谷_JS基础_返回值的类型P55 - 00:19</p><p>﻿</p><p>continue跳过当次循环，但是还是要进行下一次循环</p><p>break跳出整个循环</p><p>return退出整个函数</p><p>返回值可以是任意的数据类型也可以是一个对象还可以是一个函数</p><p>可以在函数内部还可以声明函数，也可以作为返回值进行返回。</p><p>﻿</p><p>56.尚硅谷_JS基础_立即执行函数P56 - 00:11</p><p>﻿</p><p>调用一个匿名函数</p><p>(function(){alert(“我是一个匿名函数~~~”);})();</p><p>函数定义完就会被立即执行一次。</p><p>﻿</p><p>57.尚硅谷_JS基础_方法P57 - 00:07</p><p>﻿</p><p>对象的属性可以是任何的数据类型，也可以是个函数</p><p>函数也可以成为对象的属性，如果一个函数作为一个对象的属性保存，</p><p>那么我们成这个函数时这个对象的方法，调用函数就说调用对象的方法（method），但是它只是名称上的区别，没有其它的区别。</p><p>//调方法</p><p>obj.function()</p><p>//调函数</p><p>function()</p><p>枚举：</p><p>要知道对象中的所有属性。则需要使用枚举的方法，一个一个的取出来。使用for in语句</p><p>语法：for(var 变量 in 对象){}</p><p>还可以使用for(var n in boj){console.log(obj[n])}来输出属性值</p><p>﻿</p><p>58.尚硅谷_JS基础_全局作用域P58 - 00:08</p><p>﻿</p><p>作用域</p><p>-作用域指一个变量的作用范围</p><p>-在JS中一共有两种作用域：</p><p>全局作用域：</p><p>-直接编写在script中的JS代码，都作用在全局作用域</p><p>-全局作用域在页面打开的时候创建，页面关闭的时候销毁</p><p>-全局作用域中有一个全局对象window，我们可以直接使用。他代表的是一个浏览器的窗口。</p><p>-全局作用域中的变量都会作为window对象的属性保存</p><p>-全局作用域中的函数都会作为window对象的方法保存</p><p>1、变量的声明提前：</p><p>-使用var关键字声明的变量，会在所有的代码执行之前被声明，但是如果声明变量时不使用var关键字，则变量不会被声明提前。</p><p>2、函数的声明提前：</p><p>-使用函数声明形式创建的函数function函数（）{}。它会在所有的代码执行之前被创建。所以我们可以在函数声明前进行调用。</p><p>-使用函数表达式创建的函数var fun=function(){}。不会被提前创建。</p><p>-全局作用域中的变量都是全局变量，在我们的页面的任意部分都可以访问到</p><p>﻿</p><p>59.尚硅谷_JS基础_函数作用域P59 - 00:04</p><p>﻿</p><p>函数作用域：</p><p>-调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁</p><p>-每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的</p><p>-在函数作用域中可以访问到全局作用域的变量，但是在全局作用域中无法访问到函数作用域中的变量</p><p>-当在函数作用域中操作一个变量时，它会现在自身作用域中寻找，如果有就直接使用，如果没有则向上一级作用域中寻找（并不是指的是全局作用域）可以是上一级的函数中的变量。最后才会找到全局作用域中。如果全局作用域中都没有那就报错没有定义</p><p>﻿ ﻿</p><p>-在函数作用域中也有提前声明。类似于全局作用域的提前声明。</p><p>-在函数中如果不写var的话那就会成为全局变量（相当于window.变量名=变量值）</p><p>-定义形参就相当于在函数作用域中声明了变量。</p><p>﻿</p><p>60.尚硅谷_JS基础_debugP60 - 00:25</p><p>﻿</p><p>使用浏览器的Sources可以悬停一步一步的执行，可以验证var是否已经提前声明，添加进watch中就可以看到。</p><p>﻿</p><p>61.尚硅谷_JS基础_thisP61 - 00:03</p><p>﻿</p><p>解析器（浏览器）在调用函数每次都会向函数内部传递进一个隐含的参数。这个隐含的参数就是this。this指向的是一个对象。</p><p>这个对象我们称为函数执行的上下文对象。</p><p>根据函数的调用方式不同，this会指向不同的方向</p><p>1、以函数的形式调用时，this永远都是window。</p><p>2、以方法的形式调用时，this就是方法调用的对象</p><p>﻿</p><p>62.尚硅谷_JS基础_this补充P62 - 00:14</p><p>﻿</p><p>this可以根据调用者的不同来决定被调用的东西是什么，相当于java里面的父类</p><p>﻿</p><p>63.尚硅谷_JS基础_使用工厂方法创建对象P63 - 03:22</p><p>﻿</p><p>﻿</p><p>64.尚硅谷_JS基础_构造函数P64 - 17:57</p><p>﻿</p><p>1.立刻创建一个新的对象</p><p>2.将新建的对象设置为函数中this,在构造函数中可以使用this来引用新建的对象</p><p>3.逐行执行函数中的代码</p><p>4.将新建的对象作为返回值返回</p><p>使用同一个构造函数创建的对象，我们成为一类对象，也构造了一个类。创建的构造对象成为一个类的实例</p><p>﻿ ﻿</p><p>﻿</p><p>65.尚硅谷_JS基础_.构造函数修改P65 - 00:01</p><p>﻿</p><p>﻿ ﻿</p><p>直接在作用域中进行定义，让所有的构造方法都去调用同一个函数</p><p>﻿</p><p>66.尚硅谷_JS基础_原型对象P66 - 00:54</p><p>﻿</p><p>函数定义在全局作用域，污染全局作用域的命名空间，而且定义在全局作用域中也很不安全。</p><p>prototype圆形</p><p>我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype</p><p>-这个属性对应着一个对象，这个对象就是我们所谓的原型对象</p><p>﻿ ﻿</p><p>如果函数作为普通函数调用时prototype没有任何作用</p><p>当以构造对象进行调用时，它所创建的对象中都会有一个隐藏的属性指向该构造函数的原型对象，我们可以通过__proto__来访问该属性</p><p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，没我可以将对象中共有的内容，统一设置到原型对象中。</p><p>当我们访问对象的一个属性或方法时，它先在自身中寻找，如果没有则会去原型对象中寻找，如果找到则直接使用</p><p>-以后创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中。这样不用分别为每个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法</p><p>﻿</p><p>67.尚硅谷_JS基础_原型对象P67 - 00:03</p><p>﻿</p><p>使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true</p><p>可以使用对象的hasOwnProperty（）检查自身中是否含有该属性</p><p>原型对象也还有原型对象</p><p>-当我们在使用一个对象的属性或方法时，会先在自身中寻找，如果没有则去原型对象中寻找，如果原型对象中与他使用，再没有去原型的原型去寻找。</p><p>Object对象中的原型没有原型（最多两层），在Object中依然没有找到，则返回undefined。（原型链）</p><p>﻿</p><p>68.尚硅谷_JS基础_toString()P68 - 00:10</p><p>﻿</p><p>当直接在页面中打印一个对象时，事实上是输出对象的ToString（）方法的返回值（打印对象=打印返回值）</p><p>如果我们希望对象不输出【boject OBject】可以为对象添加一个ToString（）方法</p><p>﻿</p><p>69.尚硅谷_JS基础_垃圾回收P69 - 00:04</p><p>﻿</p><p>垃圾回收</p><p>对对象进行一系列操作之后，最后将对象的值改为object=null</p><p>当一个对象没有任何的变量或属性对它进行引用，此时我们永远无法操作该对象。</p><p>此时这种对象就是一个垃圾，导致程序变慢。在JS中拥有自动的垃圾回收机制。我们不需要也不能进行垃圾回收。如果需要回收就使用boject=null，让栈内存中的内存值设为null</p><p>﻿</p><p>70.尚硅谷_JS基础_数组简介P70 - 00:16</p><p>﻿</p><p>数组也是一个对象（Array）</p><p>和普通对象功能类似，也是用来储存一个值</p><p>不同的是普通对象是使用字符串作为属性名的，</p><p>-而数组时使用数字来作为索引操作元素</p><p>-索引：</p><p>从0开始的整数就是索引</p><p>数组的存储属性比普通对象好，在开发总我们经常使用数组来存储一些数据</p><p>使用typeof检查数组是返回object</p><p>语法：数组【索引】=值</p><p>arr[0]=10</p><p>读取数组中的元素</p><p>语法：数组【索引】</p><p>﻿ ﻿</p><p>像数组最后一个数组添加元素</p><p>语法：数组【数组.lenght】=值</p><p>﻿</p><p>71.尚硅谷_JS基础_数组字面量P71 - 00:49</p><p>﻿</p><p>可以直接使用var arr=[];创建数据</p><p>也可以使用构造函数的方法添加元素，将要添加元素构造函数的参数传递</p><p>var arr=new Array(10,20,30);</p><p>数组中的元素可以是任意的数据类型（包括对象）</p><p>arr=[“hello”,1,true,null,undefined]</p><p>﻿</p><p>72.尚硅谷_JS基础_数组的四个方法P72 - 00:15</p><p>﻿</p><p>push（）该方法可以想数组的末尾添加一个或多个元素，并返回数组的新的长度。这样这些元素将自动添加到数组的末尾</p><p>pop（）该方法可以删除数组的最后一个元素，并将删除的元素作为返回值返回</p><p>arr.unshift()往前面添加，想前面添加元素之后，其它的元素的下标都会调整。</p><p>arr.shift()删除数组的第一个元素并作返回值进行返回</p><p>﻿</p><p>73.尚硅谷_JS基础_数组的遍历P73 - 01:26</p><p>﻿</p><p>使用for循环来进行数组的遍历</p><p>arr.lenght</p><p>﻿</p><p>74.尚硅谷_JS基础_数组练习P74 - 01:07</p><p>﻿</p><p>﻿</p><p>75.尚硅谷_JS基础_forEachP75 - 00:07</p><p>﻿</p><p>了解一个forEach方法进行遍历数组</p><p>就是除了for循环的数组之外的遍历数组</p><p>arr.forEach(function(){})</p><p>forEach需要一个函数作为参数</p><p>-这种函数，由我们创建但是不由我们调用，我们成为回调函数</p><p>-数组中有几个数组就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以来定义形参，来读取这些内容</p><p>-浏览器会在回调函数中传递三个函数。</p><p>-第一个参数当前正在遍历的元素</p><p>-第二个参数当前正在遍历元素的索引</p><p>-第三个参数当前正在遍历的整个对象</p><p>支持IE8及以上的</p><p>﻿</p><p>76.尚硅谷_JS基础_slice和spliceP76 - 00:05</p><p>﻿</p><p>slice（）参数start，end开始和结束位置。该方法不会影响原数组。</p><p>截取位的索引包含开始不包含结束。前闭后开区间</p><p>-第二个参数可以省略不写。那就是全部截取</p><p>-索引也可以传递负值，如果传递一个负值那就是从后往前取</p><p>splice（）可以用于用于删除数组</p><p>splice（）会影响到原数组，会将制定元素从原数组中删除，并将删除的元素作为返回值返回。参数start，num。删除的从第几个开始以及删除的数量，第三个参数以后：可以传递新的元素，这些元素就会自动插入到开始位置索引前面</p><p>﻿</p><p>77.尚硅谷_JS基础_数组去重练习P77 - 00:06</p><p>﻿</p><p>﻿</p><p>78.尚硅谷_JS基础_数组的剩余方法P78 - 00:05</p><p>﻿</p><p>concat（）可以连接两个或多个数组，并将新的数组范围。该方法不会对原数组产生影响</p><p>join（）该方法可以将数组转换为一个字符串</p><p>-该方法不会对原数组产生影响，二十将转换后的字符串作为结果返回</p><p>-在join（）中可以指定一个字符串作为参数，这个字符串将成为数组中元素的连接符，如果不使用那就默认逗号，想要为空的话就改为一个空字符串</p><p>reverse（）该方法用来翻转数组，会直接修改原数组</p><p>sort（）对原数组进行排序，会影响原数组，按照Unicode编码进行排序。即使按照纯数字的数组排序，也会按照Unicode编码来排序，所以对数字排序的时候可能得到错误的结果</p><p>﻿ ﻿</p><p>﻿</p><p>79.尚硅谷_JS基础_call和applyP79 - 00:01</p><p>﻿</p><p>函数对象的方法call()和apply()</p><p>-这两个方法都是函数对象的方法，需要通过函数对象来调用</p><p>-当我们对函数进行调用call()和apply()和直接加()就可以使用</p><p>-使用call()和apply()可以将一个对象指定为一个参数</p><p>此时这个对象将会成为函数执行的this</p><p>-call()方法可以将实参在对象之后一次传递</p><p>-apply()方法需要将实参封装到一个数组中统一传递</p><p>-this的情况：</p><p>1、以函数形式调用时，this永远都是window</p><p>2、以方法的形式调用时，this是调用方法的对象</p><p>3、以构造函数的形式调用时，this是新创建的对象</p><p>4、使用call和apply调用时，this是指定的那个对象</p><p>﻿</p><p>80.尚硅谷_JS基础_argumentsP80 - 00:23</p><p>﻿</p><p>在调用函数时，浏览器每次都会传递进两个隐含的参数。</p><p>1、第一个是函数的上下文对象this。</p><p>2、第二个是封装实参的arguments</p><p>-arguments是一个类数组对象（但是不是一个数组），它也可以通过参数索引来操作数据，也可以获取长度。</p><p>-在调用函数时，我们所传递的实参都会在arguments中保存</p><p>-即使不定义形参，也可以通过arguments的下标来使用实参。</p><p>-它里面还有一个属性叫做callee，对应的一个函数对象，就是我们当前正在执行的函数对象</p><p>﻿</p><p>81.尚硅谷_JS基础_Date对象P81 - 00:12</p><p>﻿</p><p>Date对象</p><p>-在JS中使用Date对象来表示一个时间</p><p>如果直接使用构造函数去创建一个Date对象，则会封装为当前代码的执行时间</p><p>创建指定的一个时间对象：格式：月份/日/年 时：分：秒</p><p>getDay（）返回当前日期的周几0表示周日，1周一</p><p>getMonth（）返回当前日期的月份</p><p>0表示1月，1表示2月，2表示3月</p><p>getTime（）返回当前日期对象的时间戳</p><p>-时间戳，指的是从格林威治的标准时间到现在的毫秒数的及时（计算机底层在保存时间使用时间戳保存）</p><p>获取我们当前的时间戳Date.Now();</p><p>﻿</p><p>82.尚硅谷_JS基础_MathP82 - 00:05</p><p>﻿</p><p>Math</p><p>-Math和其它对象不同，它不算一个构造函数。</p><p>术语工具类不用创建对象，它里面封装数学计算的方法</p><p>Math.ceil()方法小数点只要有值都自动进1。向上取整</p><p>Math.floor()方法小数点只要有值都自动抹去。向下取整</p><p>﻿</p><p>96.尚硅谷_JS基础_DOM查询P96 - 00:37</p><p>﻿</p><p>获取某个元素下的子元素，需要使用该元素名在寻找子元素名。语法：元素名.getElementById()</p><p>childnodes获取包括文本节点在内的所有节点。</p><p>根据DOM的换行也会当成文本节点，但是在IE8一下的浏览器中，不会将空白文本当成子节点，</p><p>children属性可以获取当前元素的子元素（不会有空格）比childnodes好很多</p><p>firstChild第一个子节点</p><p>firstElementChild第一个子元素（不支持IE8以下）</p><p>﻿</p><p>97.尚硅谷_JS基础_DOM查询P97 - 00:40</p><p>﻿</p><p>定义一个函数，专门用来指定元素绑定单击响应函数</p><p>参数：</p><p>idStr要绑定单机相应函数的对象的id属性值</p><p>fun事件回调函数，当点击元素时，使用回调函数</p><p>父节点：parentNode</p><p>innerHTML获取到元素内部中的html代码。而innerText则获取到元素内部中的文字，去除了标签部分</p><p>.previousSibling前一个兄弟节点（包括空格）</p><p>.previousElementSibling前一个兄弟元素</p><p>文本框的value属性值就是文本框中填写的内容</p><p>文本中的nodeValue就是他文本的值。</p><p>﻿</p><p>98.尚硅谷_JS基础_全选练习（一）P98 - 00:17</p><p>﻿</p><p>﻿</p><p>99.尚硅谷_JS基础_全选练习（二）P99 - 12:15</p><p>﻿</p><p>在时间的响应函数中，响应函数是给谁绑定的this就是</p><p>﻿</p><p>﻿</p><p>102.尚硅谷_JS基础_dom增删改P102 - 00:10</p><p>﻿</p><p>createElement（）可以创建一个元素节点对象，需要一个标签名作为参数，将会根据标签名创建元素节点对象，并将创建好的对象作为返回值</p><p>createTextNode()创建文本节点，需要一个文本内容作为参数，会根据该内容创建文本节点，将新的节点返回</p><p>appendChild（）向一个父节点添加一个新的子节点。</p><p>用法：父节点.appendChild(子节点)</p><p>﻿</p><p>103.尚硅谷_JS基础_添加删除记录-删除P103 - 00:11</p><p>﻿</p><p>﻿</p><p>104.尚硅谷_JS基础_添加删除记录-添加P104 - 00:08</p><p>﻿</p><p>﻿</p><p>104.尚硅谷_JS基础_添加删除记录-添加P104 - 00:42</p><p>﻿</p><p>﻿</p><p>105.尚硅谷_JS基础_添加删除记录-修改P105 - 00:26</p><p>﻿﻿</p><p>108.尚硅谷_JS基础_获取元素的样式P108 - 00:37</p><p>﻿</p><p>document.style.样式获取的是内联样式并不是样式表中的样式</p><p>读取元素当前样式：</p><p>语法：元素.currentStyle.样式名</p><p>它可以用来读取当前正在显示的样式（虽然好用但是只有IE支持）</p><p>在其他浏览器中使用getComputedStyle()这个方法来获取当前的样式，这个方法是window的方法，可以直接使用。两个参数：第一个：要获取样式的元素，第二个：传递一个伪元素，一般都传null。该方法返回一个对象，对象中封装了当前元素的对应样式</p><p>该方法会返回一个对象，对象封装了当前元素对应的样式（该方法不支持IE8以下浏览器）</p><p>要做到都兼容自己写一个函数：</p><p>参数：obj获取样式的元素。name要获取的样式名。</p><p>通过currentStyle和getComputedStyle()读取到的样式都是只读的，不能修改，如果要修改必须通过style属性</p><p>﻿</p><p>109.尚硅谷_JS基础_getStyle()方法P109 - 00:04</p><p>﻿</p><p>找对象的属性而不是变量，找不到属性为undefined，所以他转换为false就是走else中的。但是如果找不到变量那就报错了</p><p>﻿</p><p>110.尚硅谷_JS基础_其他样式相关的属性P110 - 00:35</p><p>﻿</p><p>clientWidth可见宽度</p><p>clientHeight可见高度</p><p>-这些属性都不带PX，返回一个数字，可以直接计算</p><p>-获取元素宽度和高度，包括内容区和内边距</p><p>-这些属性都是只读的不能进行修改，只能通过style进行修改</p><p>offsetWidth</p><p>offsetHeight</p><p>-获取元素的整个的宽度和高度，包括内容与、内边距边框</p><p>offsetParent</p><p>-可以获取当前元素的定位父元素</p><p>-会获取到离当前元素最近的开启了定位的祖先元素</p><p>-如果所有的祖先元素都没有开启则返回body</p><p>offsetLeft</p><p>-当前元素相对于其定位元素的水平偏移量</p><p>OffsetTop</p><p>-当前元素相对于其定位元素的垂直偏移量</p><p>scrollWidth和scrollHeight</p><p>-当前元素的滚动区域的高度和宽度</p><p>scrollLeft</p><p>-可以获取水平滚动条滚动的距离</p><p>scrollTop</p><p>-可以获取垂直滚动条滚动的距离</p><p>当满足scrollHeight-scrollTop==clientHeight。说明垂直滚动条到底了。</p><p>当满足scrollWidth-scrollLeft==clientWidth。说明水平滚动条滚动到底</p><p>overflow：auto调出滚动条出来</p><p>﻿</p><p>111.尚硅谷_JS基础_事件对象P111 - 03:33</p><p>﻿</p><p>onmousemove</p><p>该事件会在鼠标在元素中移动时触发</p><p>事件对象</p><p>当事件的相应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数</p><p>在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标 键盘哪个按键被按下 鼠标的滚轮滚动方向。。。</p><p>在IE8中，响应函数被触发时，浏览器不会传递时间对象。</p><p>﻿</p><p>112.尚硅谷_JS基础_div跟随鼠标移动P112 - 01:45</p><p>﻿</p><p>div块鼠标跟着一起动</p><p>想要设置位置left和top就一定要开启绝对定位absolute</p><p>pageX和pageY可以获取相对于页面的定位</p><p>﻿</p><p>113.尚硅谷_JS基础_事件的冒泡P113 - 00:04</p><p>﻿</p><p>事件的冒泡（Bubble）</p><p>    -所谓的冒泡值的就是事件的向上传到，当后代的元素被触发时，祖先相同事件也会触发</p><p>    -在开发中大部分冒泡是有用的，如果不希望事件冒泡可以通过事件对象来取消冒泡</p><p>    </p><p>﻿</p><p>114.尚硅谷_JS基础_事件的委派P114 - 05:18</p><p>﻿</p><p>为每个超链接都绑定一个单击相应函数</p><p>这里我们为每一个超链接都绑定一个单机响应函数，这种操作麻烦，而且这些操作只能为已经有的添加设置时间，而重新添加的超链接必须重新绑定</p><p>我们希望，只绑定一次时间，即可应用到多个元素上，即使元素是后添加的，我们可以尝试绑定给元素共同的祖先元素</p><p>事件的委派：</p><p>-指将时间统一绑定给元素的共同的祖先元素，这样当后代元素的时间触发时，会一直冒泡到祖先元素从而通过祖先元素的响应函数来处理事件</p><p>-时间委派是利用了冒泡，通过委派可以减少时间绑定的次数，提高程序性能</p><p>﻿</p><p>115.尚硅谷_JS基础_事件的绑定P115 - 01:56</p><p>﻿</p><p>使用 对象.时间=函数 的形式绑定响应函数。</p><p>它只能同时为一个元素的一个事件绑定一个响应函数，不能绑定多个，如果绑定了多个，后面的会被覆盖</p><p>可以通过监听器的方法就可以addEventListener（）；</p><p>参数：1.时间的字符串，不要on。2.回调函数，3.是否在捕获阶段触发，需要一个布尔值，一般都传false。</p><p>使用addEventListener（）可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数会按照函数绑定的顺序执行。</p><p>在IE8中可以使用attachEvent（）来绑定事件，</p><p>参数：1.事件的字符串，要on，2.回调函数</p><p>-这个方法也可以同时为一个时间绑定多个处理函数。不同的是后绑定先执行，执行顺序和addEventListener（）相反。</p><p>﻿</p><p>116.尚硅谷_JS基础_完成bind函数P116 - 00:00</p><p>﻿</p><p>﻿</p><p>117.尚硅谷_JS基础_事件的传播P117 - 00:43</p><p>﻿</p><p>事件的传播</p><p>-关于时间的传播微软和网景不同的理解</p><p>-微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素的事件，然后再向前元素的祖先元素上传播，也就是说应该在冒泡上实行。</p><p>-网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素外层的祖先事件。事件的捕获</p><p>W3C综合了两个公司的方案，将事件传播分为了三个阶段：</p><p>-1、捕获阶段</p><p>在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件。</p><p>-2、目标阶段</p><p>事件捕获到目标元素，捕获结束开始在目标元素上触发事件</p><p>-3、冒泡阶段</p><p>事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件</p><p>-如果希望在捕获阶段就将addEventListener中第三个参数设置为true。一般情况下我们不会希望在捕获触发。IE8以下没有</p><p>﻿</p><p>118.尚硅谷_JS基础_拖拽（一）P118 - 00:21</p><p>﻿</p><p>拖拽的过程</p><p>    1、当鼠标被拖拽元素按下，开始拖拽onmousedown</p><p>    2、当鼠标移动时拖拽元素跟随移动onmousemove</p><p>    3、当鼠标松开时元素固定当前位置onmouseup</p><p>﻿</p><p>119.尚硅谷_JS基础_拖拽（二）P119 - 01:48</p><p>﻿</p><p>﻿ ﻿</p><p>﻿</p><p>120.尚硅谷_JS基础_拖拽（三）P120 - 04:54</p><p>﻿</p><p>﻿ ﻿</p><p>但是对IE8不起作用</p><p>当调用一个元素的setCapture()</p><p>﻿</p><p>121.尚硅谷_JS基础_滚轮的事件P121 - 00:11</p><p>﻿</p><p>鼠标滚轮滚动事件</p><p>onmousewheel（），在火狐中需要使用DOMMouseScroll来绑定滚动事件注意该事件需要通过addEventListener()函数来绑定火狐浏览器的滚动条时间，通过event.wheelDelta的正负值大小判断滑动轨迹</p><p>﻿</p><p>122.尚硅谷_JS基础_键盘事件P122 - 00:29</p><p>﻿</p><p>键盘事件：onkeydown、onkeyup键盘被按下、松开</p><p>键盘事件一般都会绑定到能够获取焦点的对象document</p><p>onkeydown：</p><p>-按键被按下</p><p>-对于onkeydown来说如果一直按着某个按键不松手，该事件会一直触发</p><p>-当onkeydown连续触发时，开始输入慢，防误操</p><p>altKey、ctrlKey、shiftKey公用按键用与方法判断是否被同时按下</p><p>﻿</p><p>124.尚硅谷_JS基础_NavigatorP124 - 01:19</p><p>﻿</p><p>Bom可以使我们通过JS来操作浏览器</p><p>在Bom中为我们提供了一组对象，用来完成浏览器的操作</p><p>Bom对象</p><p>-Window</p><p>代表的是整个浏览器的窗口，同时window也是网页中的全局对象</p><p>-Navigator</p><p>代表的当前浏览器的信息，通过该对象可以识别不同的浏览器。</p><p>由于历史原因Navigator对象</p><p>一般我们只会使用userAgent来判断浏览器的信息，就是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器有不同的userAgent</p><p>-Location</p><p>代表当前浏览器的地址栏信息，通过Location可以操作浏览器跳转页面</p><p>-History</p><p>代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页。</p><p>而且此操作只在当次访问有效</p><p>-Screen</p><p>代表用户的屏幕的信息，通过该对象获得显示器的相关信息</p><p>这些BOM对象在浏览器中都是作为window对象的属性保存的。可以通过window对象来使用，也可以直接使用</p><p>﻿</p><p>124.尚硅谷_JS基础_NavigatorP124 - 41:05</p><p>﻿</p><p>找出IE的方法具体在代码里</p><p>﻿</p><p>125.尚硅谷_JS基础_HistoryP125 - 04:30</p><p>﻿</p><p>-History</p><p>代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页。</p><p>而且此操作只在当次访问有效</p><p>﻿</p><p>126.尚硅谷_JS基础_LocationP126 - 00:07</p><p>﻿</p><p>-Location</p><p>该对象封装了对象中的地址栏信息</p><p>如果直接打印Location可以获取到地址栏完整信息如果直接将Location修改为一个完整路径或相对路径会自动跳转并生成响应历史记录</p><p>-assign()用以跳转，跟Location方法差不多</p><p>location..assign(“<a href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a>)</p><p>location.reload(true)进行强制清空缓存刷新</p><p>    location.replace()方法进行跳转不会生成历史记录不能回退</p><p>﻿</p><p>127.尚硅谷_JS基础_定时器简介P127 - 00:15</p><p>﻿</p><p>JS程序的执行速度是非常快的</p><p>定时调用，如果需要一段程序每间隔一段时间执行一次，可以使用定时调用</p><p>timer=setInterval()</p><p>-定时调用</p><p>-可以将一个函数，每隔一段时间事件执行一次</p><p>-参数：</p><p>1、回调函数，该函数每隔一段时间被调用一次</p><p>2、每次调用的时间间隔，单位是毫秒</p><p>关闭定时器：</p><p>返回一个Number类型的数据</p><p>clearInterval(timer)</p><p>128.尚硅谷_JS基础_切换图片练习P128 - 10:49</p><p>﻿</p><p>clearInterval（）可以接受任意参数</p><p>如果参数是一个有效的定时器的表示，则停止对应的定时器，如果参数是一个无效的不发生效果。</p><p>目前我们每次点一次按钮，则会开启一个定时器，</p><p>所以我们每次开启一个定时器之前都要关闭另一个当前元素的其它定时器</p><p>﻿</p><p>129.尚硅谷_JS基础_修改div移动练习P129 - 00:20</p><p>﻿</p><p>﻿</p><p>130.尚硅谷_JS基础_延时调用P130 - 00:03</p><p>﻿</p><p>延时调用</p><p>延时调用一个函数不马上执行，而是隔一段时间执行只执行一次</p><p>延时调用和定时调用的区别，定时调用会调用多次，延时调用只调用一次</p><p>延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要</p><p>﻿</p><p>131.尚硅谷_JS基础_定时器的应用（一）P131 - 00:03</p><p>﻿</p><p>把移动位置修改成为一个函数进行包装一下复用性强</p><p>﻿</p><p>133.尚硅谷_JS基础_定时器的应用（三）P133 - 00:18</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/09/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/09/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ol><li>类：公共的属性（特征），公共的方法（动作）</li><li>类和对象：<br> （1）类是整体，是抽象，是概念<br> （2）对象是个体，是具体，是实例</li><li>类的定义<br> class类名{<br> 公共的属性<br> 公共的方法<br>  }     </li><li>对象的定义<br> 类 对象=new 类的构造方法（）</li></ol><p>5.构造方法：<br> （1）特征：a.没有类型  b.方法名与类名完全一致<br> （2）用途：读新分配的内存空间赋值<br> （3）特殊情况：当类的定义中没有任何一个构造方法，系统会提供一个默认的构造方法。<br>              空参的构造方法：每一个属性都赋值为默认值。<br>    int 0<br>    double 0.0<br>    boolean false<br>    char ‘\0’<br>    string null           </p><p>    变量的类型：局部变量，类的成员变量<br>    局部变量：方法内定义的变量，（1）方法的形参（2）方法内定义的变量<br>    类的成员变量：类中定义的变量<br>         （1）static：静态变量，类变量。<br>         （2）实例变量，对象变量         </p><p>    变量和方法的调用问题<br>     1.在实例方法中，可以直接调用实例变量，也可以直接利用调用类变量。<br>     2.在类方法中，可以直接调用类变量，但是不能调用实例变量。<br>     3.在实例方法中，可以直接调用其他的实例方法，也可以调用类方法。<br>     4.在类方法中，可以直接调用其他的类方法，但是不能调用实例方法。</p><p>     对象能调用实例变量，也可以调用类变量，也可以调用实例方法，也可以调用类方法<br>     类能够调用类变量，也可以调用类方法，但是不能调用实例变量和实例方法</p><p>   二 、封装（实例变量私有化、getter和setter）<br>       实例变量私有化：<br>      class Student{<br>          private String stuID;<br>          private String stuName;<br>          private int stuAge;<br>          }</p><p>       1、private 私有 ：仅在本类有效。<br>       2、默认：在本类、本包中的其他类。<br>          私有的好处：<br>            （1）保护内部的数据不被外界随意访问和修改<br>            （2）简化操作。<br>      封装后，一般要对外提供接口，方便操作。</p><p>      这个接口就是Getter和Setter。<br>        1、Getter:访问器的特征<br>           （1）一get开头。<br>           （2）有返回值，所以方法有类型。<br>           （3）方法没有参数。<br>        2、Setter：设置器的特征<br>           （1）一set开头。<br>           （2）方法的类型为void。<br>           （3）方法有参数。</p><p>    面向对象的三大特征<br>      1、封装<br>      2、继承<br>      3、多态</p><p>      继承：<br>          class 子类 extends 父类{<br>            //定义自己特有的属性和方法<br>        }<br>        继承的效果：子类拥有了父类的所有的方法和属性、但是结构方法除外</p><p>      构造方法：<br>             当继承存在时，子类的构造方法第一句一定是super()。<br>             它体现一种分工的思想<br>    三、super的三种使用场合<br>       1、super（）；表示调用父类的构造方法<br>       2、super。实例变量：调用父类中的实例变量<br>       3、super。实例方法：调用父类中的实例方法<br>      方法的重载<br>       1、方法名相同，类型相同，但是参数不同。<br>       2、所谓参数不同：<br>        （1）个数不同；<br>        （2）类别不同；<br>      方法的重写（覆盖）<br>       1、只有继承存在时，才有可能出现方法的重写。<br>      父类和子类的关系是is-a的关系<br>    人 对象=new Student（）；<br>    人 对象=new Worker（）；<br>    人 对象=new 之类）（）；<br>    3.方法是一子类为准；属性是以父类为准<br>    4.在面向对象语言中，对象之间的交互通过消息实现<br>     四、多态<br>    1.静态的多态：Person p=new Student（）；<br>    2.动态的多态：p.show（）<br>    3.多态的目的：<br>        同一个动作，不同类型的对象，作出不同的反映；<br>        规律：<br>         （1）方法的重写存在时，父类声明，子类构造时<br>            对象.方法（）//是以子类的为准<br>         （2）对象.变量//是以父类为准</p><p>     五、抽象类<br>    1.一般修饰方法和类<br>     （1）修饰方法时被成为抽象方法<br>     （2）抽象类时被称为抽象类<br>    2.抽象方法和抽象类的关系<br>     （1）抽象方法所在的类，一定是抽象类<br>     （2）抽象类中可以没有抽象方法<br>    3.抽象类不能生成对象<br>        一般抽象类都有子类，子类实现了父类的抽象方法后，就可以是非抽象类，就可以生成对象<br>     六、接口<br>    1.一般一个类为了扩展功能，优先实用接口<br>    2.接口：是规范，是标准<br>    3.定义：<br>     interface接口名（）｛//1.定义常量 //2.定义方法｝<br>     注意：接口中的方法都是public，abstract<br>     接口的实现：<br>      class 类名 implements 接口名｛//重写接口的方法｝<br>     （接口的现实意义：<br>     国家或行业制定制度、制定标准<br>     公司/企业来具体实现）<br>    4.抽象类与接口的对比<br>     （1）相同点：都能扩充子类的功能<br>     （2.1）不同点：抽象类中可以定义实例变量，类变量，接口中只能定义静态、公共的常量。<br>     （2.2）抽象类中可以定义正常的实例方法，类方法，接口中只能定义public、abstract的方法<br>     （3）子类继承抽象类，改变子类的体系结构；<br>          子类实现接口，不会改变原有的体系结构。<br>     （4）接口更具有通用性和普遍性</p><p>      七、集合<br>    List list=new List（）；错误的</p><p>    1.List的集合唯一一个有序的集合；<br>    2.List集合可以添加重复的元素<br>    3.size();得到List集合对象的长度，元素个数；<br>      get(int index);得到index下标对应元素；<br>      add(Object o);在List集合的尾部添加一个新的元素；<br>      add(int inde,Object o);在I下标插入元素o<br>      addAll（List other）;添加other中所有的元素。<br>      addAll(int index,List other):插入。<br>      contains(Object o):判断集合中是否包含元素o。<br>      clear（）；清空List集合<br>      八、GUI<br>    java.awt包和javax.swing包<br>     1.java.wat包：重量级组件，包括按钮，文本框，列表框，字体，颜色，布局等等这些都在awt包中而swing中没有<br>      窗体：Frame类<br>      构造方法<br>     Frame f=new Frame（）；要用import<br>    Button button1=new Button(“登陆”);<br>    button1.setFont(new Font(“宋体”,Font.PLAIN,60));<br>    //设置标题<br>    f.setTitle(“我的第一个窗体”);<br>    //设置大小<br>    f.setSize(400,300);<br>    //f.setSize(new Dimension(400,300));<br>    //设置窗体的位置<br>    f.setLocation(new Point(300,300));//等价于f.setLocation（300，300）<br>    //添加其它的组件<br>    f.add(button1);<br>    //设置窗体可见<br>    f.setVisible(true);<br>     2.java.swing包：轻量级组件，包括按钮，文本框<br>    3.窗体的布局<br>     窗体的默认布局是：<br>     BorderLayout 边框布局<br>     边框布局把窗体分为五个部分，分别是上北下南，左西右东，中<br>     North，South，East，West，Center</p><p>    流式布局<br>     FlowLayout<br>     特点：先把第一个空间放在第一行的中央，以此类推，知道第一行占满，然后第二行参照第一行排列；<br>     <br>    网格布局<br>    GridLyout（行数，列数）<br>     特点：把窗体划分为若干行，若干列，从第一行第一列开始放控件，以此类推<br>     Label（标签）和JLabel<br>     构造方法<br>     文字的修改：setText（String text）运行期间不能被修改<br>    TextField 文本框和JTextFieid<br>     内容的修改：setText（String text）<br>     内容的获取：getText</p><p>    null布局<br>     没有布局，但是要求每个组件都必须要设置<br>     setBounds（x（左上角的宽），y（左上角的长），width（长），heigth（宽））方法<br>     <br>    <br>    事件：event<br>     java中事件是通过接口来实现的。<br>     比如ActionListener接口中定义了一个方法actionperformed（ActionEvent e）     <br>     事件的监听情形有四种<br>     第一种：警察模式。（）<br>     第二种：自救模式。<br>     第三种：保安模式。<br>     第四种：秘书模式。<br>         <br>    如何关闭窗口</p><p>    匿名内部类的表现形式<br>     new 接口名（）｛<br>        …// 类的定义<br>    ｝</p><p>     <br>    对话框：JOptionPane<br>    showMessageDialog():消息对话框<br>    parentCompanent:父窗体<br>    showConfirmDialog():确认对话框<br>    message:提示内容<br>    title:对话框标题<br>    option_Type:按钮选项<br>    常用的option_Type主要有：<br>    JOptionPane.YES_OPTION JOptionPane.NO_OPTION<br>    JOptionPane.YES_OPTION JOptionPane.CANCEL_OPTION<br>    JOptionPane.YES_OPTION JOptionPane.OK_OPTION<br>    JOptionPane.YES_OPTION JOptionPane.OK_CANCEL_OPTION<br>    JOptionPane.YES_OPTION JOptionPane.YES_NO_OPTION<br>    <br>    message_type:消息类型<br>    JOptionpane.PLAIN_MESSAGE:平面消息<br>    JOptionpane.INFORMATION_MESSAGE:信息消息<br>    JOptionpane:WARNING MESSAGE:警告消息<br>    JOptionpane:QUESTION_MESSAGE:问题消息<br>    JOptionpaneERROR_MESSAGE:错误消息<br>    <br>    JDBC编程的详细步骤<br>    1.注册数据库的驱动程序<br>    Class.forName（“包名.类名”）;<br>    比如：Class.forName(“com.mysql.jdbc.Driver//驱动”)//展开jar，第一个就是包名<br>    2.创建连接对象.（需要引入一个包java.sql.*）<br>     Connection<br>      conn=DruverManger.getConnection(url.user.password);<br>      getConnection(url,user,password)</p><p>    3.创建语句<br>    Statement st=conn.createStatement();<br>    4.执行这条语句<br>     （1）如果是查询语句<br>     ResultSet rs=st.executeQuery(“select语句”);然后遍历re<br>     （2）如果是增上盖语句<br>     int row=st.executeUpdate(“insert/update/“)<br>     关闭服务器<br>     conn.close();     </p><p>    项目的创建步骤（一）<br>    1.新建一个java project，将其命名<br>    2.选择该工程，点击右键，新建一个Folder，命名为lib（依赖的包）jar<br>    3.吧myssql的jar包，赋值在lib中<br>    4.崩工程要营业这个jar包，选中工程，点击右键，选择properties，找到java build<br> path选项，找到libaries，点击add jars，选择本工程的lib的jar文件，点击OK<br>    项目创建步骤（二）<br>    项目创建步骤（三）</p><p>    项目的结构<br>    1.beans(entity)：主要用来创建实体类，<br>    2.dao：主要用来创建操作数据库的接口，<br>    3.impl：主要用来创建实现接口的类的定义，<br>    4.service：主要是用来定义业务逻辑类，<br>    5.ui：用来定义图形界面类，<br>    6.util：用来定义本项目中所有的公共的，全局的帮助类</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/09/10/Swagger%E4%B8%AD%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%8E%A5%E5%8F%A3/"/>
      <url>2021/09/10/Swagger%E4%B8%AD%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>有几种原因：<br>1.由于自动注入@Value的问题导致接口被正常扫描到，但是Swagger UI能够正常访问到。<br>2.由于包名不正确的问题，在扫描包的时候必须指定包</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/09/10/Can%20not%20find%20%E2%80%98Converter%E2%80%98%20support%20class%20List%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>2021/09/10/Can%20not%20find%20%E2%80%98Converter%E2%80%98%20support%20class%20List%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>com.alibaba.excel.exception.ExcelDataConvertException: Can not find ‘Converter’ support class List.</p><h1 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h1><p>EasyExcel开源框架中Converter接口的convertToExcelData只实现了转换BigDecimal、Bolean、Byte[]、btye[]、Byte、Date、Double、File、Float、InputStream、Integer、Long、Short、URL这些类型，意味着参数data最多只能是个二维数据，但是本次业务逻辑需要转换List&lt; String &gt;的数据。</p><h1 id="实体类数据"><a href="#实体类数据" class="headerlink" title="实体类数据"></a>实体类数据</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 名下企业名称</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@ExcelProperty(value = &quot;名下企业名称&quot;,index = 12)</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;String&gt; enterpriseList;</span><br></pre></td></tr></table></figure><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>编写自定义Converter转换器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">List</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">supportJavaTypeKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> List.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CellDataTypeEnum <span class="title">supportExcelTypeKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CellDataTypeEnum.STRING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">convertToJavaData</span><span class="params">(CellData cellData, ExcelContentProperty excelContentProperty, GlobalConfiguration globalConfiguration)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String stringValue = cellData.getStringValue();</span><br><span class="line">        String[] split = stringValue.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        List&lt;String&gt; enterpriseList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; split.length; i++)&#123;</span><br><span class="line">            enterpriseList.add(split[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enterpriseList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CellData <span class="title">convertToExcelData</span><span class="params">(List list, ExcelContentProperty excelContentProperty, GlobalConfiguration globalConfiguration)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        list.forEach(o -&gt; &#123;</span><br><span class="line">            String s = o.toString();</span><br><span class="line">            stringBuilder.append(s+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CellData(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/09/10/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8F%91%E9%80%81/"/>
      <url>2021/09/10/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8F%91%E9%80%81/</url>
      
        <content type="html"><![CDATA[<p>本文实现于登录短信验证，由于资金问题，使用邮箱作为登录验证验证码。</p><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><p>导入相关短信发送依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;commons-email&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.4&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="编写方法"><a href="#编写方法" class="headerlink" title="编写方法"></a>编写方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 发送邮箱验证码</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> Email 发送的邮箱</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> code 随机验证码</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendEmailCode</span><span class="params">(String Email, String code)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//创建HtmlEmail实例</span></span><br><span class="line">           HtmlEmail email = <span class="keyword">new</span> HtmlEmail();</span><br><span class="line">           <span class="comment">//邮箱的SMTP服务器</span></span><br><span class="line">           email.setHostName(<span class="string">&quot;smtp.qq.com&quot;</span>);</span><br><span class="line">           <span class="comment">//发送的字符类型</span></span><br><span class="line">           email.setCharset(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">           <span class="comment">//收件人</span></span><br><span class="line">           email.addTo(Email);</span><br><span class="line">           email.setFrom(<span class="string">&quot;自己的邮箱&quot;</span>, <span class="string">&quot;用户名&quot;</span>);</span><br><span class="line">           <span class="comment">//发送人到的邮箱以及用户名和授权码(授权码是自己设置的)</span></span><br><span class="line">           email.setAuthentication(<span class="string">&quot;发送的邮箱&quot;</span>, <span class="string">&quot;邮箱的授权码&quot;</span>);</span><br><span class="line">           <span class="comment">//发送主题</span></span><br><span class="line">           email.setSubject(<span class="string">&quot;主题&quot;</span>);</span><br><span class="line">           <span class="comment">//发送内容</span></span><br><span class="line">           email.setMsg(<span class="string">&quot;尊敬的用户您好，您的验证码为：&quot;</span> + code + <span class="string">&quot;。该验证码五分钟内有效！请勿泄露于他人！&quot;</span>);</span><br><span class="line">           <span class="comment">//进行发送</span></span><br><span class="line">           String send = email.send();</span><br><span class="line">           System.out.println(send);</span><br><span class="line">           <span class="keyword">if</span> (send != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (EmailException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MsmServiceImpl msmService = <span class="keyword">new</span> MsmServiceImpl();</span><br><span class="line">        <span class="keyword">boolean</span> b = msmService.sendEmailCode(<span class="string">&quot;将要发送的邮箱&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hystrix断路器</title>
      <link href="2021/04/30/Hystrix%E6%96%AD%E8%B7%AF%E5%99%A8/"/>
      <url>2021/04/30/Hystrix%E6%96%AD%E8%B7%AF%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="1-1、Hystrix是什么？"><a href="#1-1、Hystrix是什么？" class="headerlink" title="1.1、Hystrix是什么？"></a>1.1、Hystrix是什么？</h2><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</p><p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。<br><strong>Hystrix官网</strong>地址：<a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">https://github.com/Netflix/Hystrix/wiki/How-To-Use</a></p><h2 id="1-2、Hystrix重要概念"><a href="#1-2、Hystrix重要概念" class="headerlink" title="1.2、Hystrix重要概念"></a>1.2、Hystrix重要概念</h2><h3 id="1-2-1、服务降级"><a href="#1-2-1、服务降级" class="headerlink" title="1.2.1、服务降级"></a>1.2.1、服务降级</h3><p>服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback<br><strong>哪些情况会出现限流</strong>？<br>程序运行异常、超时、服务熔断触发服务降级、线程池/信号量打满也会导致服务降级</p><h3 id="1-2-1、服务熔断"><a href="#1-2-1、服务熔断" class="headerlink" title="1.2.1、服务熔断"></a>1.2.1、服务熔断</h3><p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。<br>通俗的说就是保险丝====服务的降级-&gt;进而熔断-&gt;恢复调用链路</p><h3 id="1-2-1、服务限流"><a href="#1-2-1、服务限流" class="headerlink" title="1.2.1、服务限流"></a>1.2.1、服务限流</h3><p><strong>秒杀高并发</strong>等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p><h1 id="2、Hystrix使用"><a href="#2、Hystrix使用" class="headerlink" title="2、Hystrix使用"></a>2、Hystrix使用</h1><h2 id="2-1、服务降级"><a href="#2-1、服务降级" class="headerlink" title="2.1、服务降级"></a>2.1、服务降级</h2><h3 id="2-1-1、构建服务端"><a href="#2-1-1、构建服务端" class="headerlink" title="2.1.1、构建服务端"></a>2.1.1、构建服务端</h3><p><strong>引入依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--hystrix--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>yml配置文件注册进Eureka服务发现中心</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    fetch-registry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka</span><br></pre></td></tr></table></figure><p><strong>业务方法service层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_OK</span>(<span class="params">Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程是：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;    paymentInfo_OK   &quot;</span> + id + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;嘻嘻&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">@HystrixCommand(fallbackMethod = <span class="string">&quot;paymentInfo_TimeOutHandler&quot;</span>, commandProperties = &#123;</span><br><span class="line">            @HystrixProperty(name = <span class="string">&quot;execution.isolation.thread.timeoutInMilliseconds&quot;</span>, value = <span class="string">&quot;3000&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_TimeOut</span>(<span class="params">Integer id</span>)</span> &#123;</span><br><span class="line">        int timeNum = <span class="number">4000</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(timeNum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程是：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;    paymentInfo_TimeOut   &quot;</span> + id + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 嘻嘻&quot;</span> + <span class="string">&quot;    耗时&quot;</span> + timeNum / <span class="number">1000</span> + <span class="string">&quot;秒钟&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_TimeOutHandler</span>(<span class="params">Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程是：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;    paymentInfo_TimeOutHandler   &quot;</span> + id + <span class="string">&quot;\t，8001运行报错或超时请稍后再试&quot;</span> + <span class="string">&quot; ┭┮﹏┭┮&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>业务方法Controller层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">  private PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">  @Value(<span class="string">&quot;$&#123;server.port&#125;&quot;</span>)</span><br><span class="line">  private <span class="built_in">String</span> serverPort;</span><br><span class="line"></span><br><span class="line">  @GetMapping(<span class="string">&quot;/payment/hystrix/ok/&#123;id&#125;&quot;</span>)</span><br><span class="line">  public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_OK</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">String</span> s = paymentService.paymentInfo_OK(id);</span><br><span class="line">      log.info(<span class="string">&quot;========结果：&quot;</span> + s);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @GetMapping(<span class="string">&quot;/payment/hystrix/timeOut/&#123;id&#125;&quot;</span>)</span><br><span class="line">  public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_TimeOut</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">String</span> s = paymentService.paymentInfo_TimeOut(id);</span><br><span class="line">      log.info(<span class="string">&quot;========结果：&quot;</span> + s);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>启动主类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-2、构建客户端"><a href="#2-2-2、构建客户端" class="headerlink" title="2.2.2、构建客户端"></a>2.2.2、构建客户端</h2><p><strong>引入依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--hystrix--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>yml配置文件注册进Eureka服务发现中心</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;</span><br><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure><p><strong>业务方法service层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@FeignClient(value = <span class="string">&quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;</span>)</span><br><span class="line">public interface PaymentHystrixService &#123;</span><br><span class="line">    @GetMapping(<span class="string">&quot;/payment/hystrix/ok/&#123;id&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">String</span> paymentInfo_OK(@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id);</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">String</span> paymentInfo_TimeOut(@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>业务方法Controller层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">  private PaymentHystrixService paymentHystrixService;</span><br><span class="line"></span><br><span class="line">  @GetMapping(<span class="string">&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;</span>)</span><br><span class="line">  public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_OK</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">String</span> result = paymentHystrixService.paymentInfo_OK(id);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  @GetMapping(<span class="string">&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;</span>)</span><br><span class="line">  @HystrixCommand(fallbackMethod = <span class="string">&quot;paymentInfo_TimeOutHandler&quot;</span>, commandProperties = &#123;</span><br><span class="line">          @HystrixProperty(name = <span class="string">&quot;execution.isolation.thread.timeoutInMilliseconds&quot;</span>, value = <span class="string">&quot;4000&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//@HystrixCommand //加了@DefaultProperties属性注解，并且没有写具体方法名字，就用统一全局的</span></span><br><span class="line">  public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_TimeOut</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">String</span> result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>启动主类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixMain80</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderHystrixMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-3、测试"><a href="#2-2-3、测试" class="headerlink" title="2.2.3、测试"></a>2.2.3、测试</h2><p>微服务启动注册进入Eureka中，只要超过@HystrixCommand-&gt;@HystrixProperty注解中参数的3秒钟就会自动跳转到服务降级方法paymentInfo_TimeOutHandler中去。</p><h2 id="2-3、以上服务降级所存在的问题"><a href="#2-3、以上服务降级所存在的问题" class="headerlink" title="2.3、以上服务降级所存在的问题"></a>2.3、以上服务降级所存在的问题</h2><h3 id="2-3-1、代码膨胀"><a href="#2-3-1、代码膨胀" class="headerlink" title="2.3.1、代码膨胀"></a>2.3.1、代码膨胀</h3><p>问题存在于1：1 每个方法配置一个服务降级方法，技术上可以，实际上代码冗余。1：N 除了个别重要核心业务有专属，其它普通的可以通过@DefaultProperties(defaultFallback = “”)  统一跳转到统一处理结果页面。<br><strong>解决问题</strong><br>只需要在类名上写一个默认的降级方法，之后并在类中写一个全局的服务降级方法，再在需要服务降级方法上标注@HystrixCommand无需其它参数即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@DefaultProperties(defaultFallback = <span class="string">&quot;payment_Global_FallbackMethod&quot;</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixController</span> </span>&#123;</span><br><span class="line">@HystrixCommand <span class="comment">//加了@DefaultProperties属性注解，并且没有写具体方法名字，就用统一全局的</span></span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_TimeOut</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">String</span> result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//全局fallbackMethod</span></span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">payment_Global_FallbackMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2、逻辑混乱"><a href="#2-3-2、逻辑混乱" class="headerlink" title="2.3.2、逻辑混乱"></a>2.3.2、逻辑混乱</h3><p>每个Controller都要写一个服务降级方法，这样与业务逻辑是否混乱，所以与OpenFeign接口处做文章。<br><strong>实现客户端Service接口层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="title">implements</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_OK</span>(<span class="params">Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-------------paymentInfo_OK fall back,┭┮﹏┭┮&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_TimeOut</span>(<span class="params">Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-------------paymentInfo_TimeOut fall back,┭┮﹏┭┮&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改造Service接口，添加fallback服务降级方法指向所实现的接口</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@FeignClient(value = <span class="string">&quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;</span>, fallback = PaymentFallbackService.class)</span><br><span class="line">public interface PaymentHystrixService &#123;</span><br><span class="line">    @GetMapping(<span class="string">&quot;/payment/hystrix/ok/&#123;id&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">String</span> paymentInfo_OK(@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id);</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">String</span> paymentInfo_TimeOut(@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong><br>这样接口的所有方法都会有服务降级的效果，实现代码冗余的难题。</p><h2 id="2-2、服务熔断"><a href="#2-2、服务熔断" class="headerlink" title="2.2、服务熔断"></a>2.2、服务熔断</h2><p>大神论文：<a href="https://martinfowler.com/bliki/CircuitBreaker.html">https://martinfowler.com/bliki/CircuitBreaker.html</a><br><strong>修改服务端Service层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod = <span class="string">&quot;paymentCircuitBreaker_fallback&quot;</span>, commandProperties = &#123;</span><br><span class="line">            @HystrixProperty(name = <span class="string">&quot;circuitBreaker.enabled&quot;</span>, value = <span class="string">&quot;true&quot;</span>),<span class="comment">//是否开启断路熔断器</span></span><br><span class="line">            @HystrixProperty(name = <span class="string">&quot;circuitBreaker.requestVolumeThreshold&quot;</span>, value = <span class="string">&quot;10&quot;</span>),<span class="comment">//请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。</span></span><br><span class="line">            @HystrixProperty(name = <span class="string">&quot;circuitBreaker.sleepWindowInMilliseconds&quot;</span>, value = <span class="string">&quot;10000&quot;</span>),<span class="comment">//快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</span></span><br><span class="line">            @HystrixProperty(name = <span class="string">&quot;circuitBreaker.errorThresholdPercentage&quot;</span>, value = <span class="string">&quot;60&quot;</span>),<span class="comment">//错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</span></span><br><span class="line">    &#125;)</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">paymentCircuitBreaker</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;******id 不能负数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">String</span> serialNumber = IdUtil.simpleUUID();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;调用成功，流水号: &quot;</span> + serialNumber;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>修改服务端Controller层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/payment/circuit/&#123;id&#125;&quot;</span>)</span><br><span class="line">public <span class="built_in">String</span> paymentCircuitBreaker(@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">String</span> result = paymentService.paymentCircuitBreaker(id);</span><br><span class="line">    log.info(<span class="string">&quot;****result: &quot;</span>+result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到断路器的三个重要参数：快照时间窗、请求总数阀值、错误百分比阀值。<br>1：快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</p><p>2：请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。</p><p>3：错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</p><p><strong>熔断器打开之后</strong><br>1：再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。</p><p>2：原来的主逻辑要如何恢复呢？<br>对于这一问题，hystrix也为我们实现了自动恢复功能。<br>当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，<br>当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，<br>主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。</p><h2 id="2-3、服务监控hystrixDashboard"><a href="#2-3、服务监控hystrixDashboard" class="headerlink" title="2.3、服务监控hystrixDashboard"></a>2.3、服务监控hystrixDashboard</h2><h3 id="2-3-1、概述"><a href="#2-3-1、概述" class="headerlink" title="2.3.1、概述"></a>2.3.1、概述</h3><p>除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控（Hystrix Dashboard），Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。</p><h3 id="2-3-2、搭建过程"><a href="#2-3-2、搭建过程" class="headerlink" title="2.3.2、搭建过程"></a>2.3.2、搭建过程</h3><p><strong>pom依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>主类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableHystrixDashboard</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardMain9001</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(MainApp9001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所监控的类都需要添加此依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- actuator监控信息完善 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>还需要在被监控的主类中加入此组件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑</span></span><br><span class="line"><span class="comment"> *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，</span></span><br><span class="line"><span class="comment"> *只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Bean</span><br><span class="line">public ServletRegistrationBean <span class="function"><span class="title">getServlet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">    ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">    registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">    registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="http://localhost:9001/hystrix">http://localhost:9001/hystrix</a></strong><br>输入<a href="http://localhost:8001/hystrix.stream%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%AF%B9%E5%BA%94%E7%9B%91%E6%8E%A7%E3%80%82">http://localhost:8001/hystrix.stream就可以进行对应监控。</a></p><h1 id="3、学习地址"><a href="#3、学习地址" class="headerlink" title="3、学习地址"></a>3、学习地址</h1><p>来源：尚硅谷哔哩哔哩学习地址：<a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Junit5笔记</title>
      <link href="2021/04/30/Junit5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/04/30/Junit5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Junit5常用测试注解"><a href="#一、Junit5常用测试注解" class="headerlink" title="一、Junit5常用测试注解"></a>一、Junit5常用测试注解</h1><h4 id="①-DisplayName：为测试类或者测试方法设置展示名称。"><a href="#①-DisplayName：为测试类或者测试方法设置展示名称。" class="headerlink" title="①.@DisplayName：为测试类或者测试方法设置展示名称。"></a>①.@DisplayName：为测试类或者测试方法设置展示名称。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;测试DisplayName注解&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testDisplayName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试DisplayName注解&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="②-BeforeEach-表示在每个单元测试之前执行"><a href="#②-BeforeEach-表示在每个单元测试之前执行" class="headerlink" title="②.@BeforeEach :表示在每个单元测试之前执行"></a>②.@BeforeEach :表示在每个单元测试之前执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testBeforeEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试就要开始啦……&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="③-AfterEach-表示在每个单元测试之后执行"><a href="#③-AfterEach-表示在每个单元测试之后执行" class="headerlink" title="③.@AfterEach :表示在每个单元测试之后执行"></a>③.@AfterEach :表示在每个单元测试之后执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAfterEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试就要结束啦……&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="④-BeforeAll-表示在所有单元测试之前执行"><a href="#④-BeforeAll-表示在所有单元测试之前执行" class="headerlink" title="④.@BeforeAll :表示在所有单元测试之前执行"></a>④.@BeforeAll :表示在所有单元测试之前执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBeforeAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有测试就要开始啦……&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑤-AfterAll-表示在所有单元测试之后执行"><a href="#⑤-AfterAll-表示在所有单元测试之后执行" class="headerlink" title="⑤.@AfterAll :表示在所有单元测试之后执行"></a>⑤.@AfterAll :表示在所有单元测试之后执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAfterAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有测试就要结束啦……&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑥-Disabled-表示测试类或测试方法不执行，类似于JUnit4中的-Ignore。"><a href="#⑥-Disabled-表示测试类或测试方法不执行，类似于JUnit4中的-Ignore。" class="headerlink" title="⑥.@Disabled :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore。"></a>⑥.@Disabled :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;测试方法二&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"><span class="comment">//    禁用注解</span></span><br><span class="line">    <span class="meta">@Disabled</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试方法二&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑦-Timeout-表示测试方法运行如果超过了指定时间将会返回错误"><a href="#⑦-Timeout-表示测试方法运行如果超过了指定时间将会返回错误" class="headerlink" title="⑦.@Timeout :表示测试方法运行如果超过了指定时间将会返回错误"></a>⑦.@Timeout :表示测试方法运行如果超过了指定时间将会返回错误</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Timeout(value = 1000,unit = TimeUnit.MILLISECONDS)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testTimeout</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1001</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑧-ExtendWith-为测试类或测试方法提供扩展类引用。类似于Junit4的-RunWith。"><a href="#⑧-ExtendWith-为测试类或测试方法提供扩展类引用。类似于Junit4的-RunWith。" class="headerlink" title="⑧.@ExtendWith :为测试类或测试方法提供扩展类引用。类似于Junit4的@RunWith。"></a>⑧.@ExtendWith :为测试类或测试方法提供扩展类引用。类似于Junit4的@RunWith。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BootstrapWith(SpringBootTestContextBootstrapper.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(&#123;SpringExtension.class&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="⑨-RepeatedTest-表示方法可重复执行，里面参数为重复多少次、"><a href="#⑨-RepeatedTest-表示方法可重复执行，里面参数为重复多少次、" class="headerlink" title="⑨.@RepeatedTest :表示方法可重复执行，里面参数为重复多少次、"></a>⑨.@RepeatedTest :表示方法可重复执行，里面参数为重复多少次、</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RepeatedTest(5)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试重复测试&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="二、断言机制"><a href="#二、断言机制" class="headerlink" title="二、断言机制"></a>二、断言机制</h1><p>断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。<strong>这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。</strong>JUnit 5 内置的断言可以分成如下几个类别：<br><strong>检查业务逻辑返回的数据是否合理。</strong><br>所有的测试运行结束以后，会有一个详细的测试报告；</p><h4 id="①-简单断言测试"><a href="#①-简单断言测试" class="headerlink" title="①.简单断言测试"></a>①.简单断言测试</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>assertEquals</td><td>判断两个对象或两个原始类型是否相等</td></tr><tr><td>assertNotEquals</td><td>判断两个对象或两个原始类型是否不相等</td></tr><tr><td>assertSame</td><td>判断两个对象引用是否指向同一个对象</td></tr><tr><td>assertNotSame</td><td>判断两个对象引用是否指向不同的对象</td></tr><tr><td>assertTrue</td><td>判断给定的布尔值是否为 true</td></tr><tr><td>assertFalse</td><td>判断给定的布尔值是否为 false</td></tr><tr><td>assertNull</td><td>判断给定的对象引用是否为 null</td></tr><tr><td>assertNotNull</td><td>判断给定的对象引用是否不为 null</td></tr><tr><td>断言如果前面方法失败了，后面就不会运行</td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;简单断言测试&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSimpleAssertions</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cal = cal(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">//        org.opentest4j.AssertionFailedError:</span></span><br><span class="line"><span class="comment">//        Expected :111</span></span><br><span class="line"><span class="comment">//        Actual   :11</span></span><br><span class="line">        assertEquals(<span class="number">11</span>,cal,<span class="string">&quot;业务逻辑计算失败&quot;</span>);</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">        assertNotSame(o1,o2);</span><br></pre></td></tr></table></figure><h4 id="②-数组断言"><a href="#②-数组断言" class="headerlink" title="②.数组断言"></a>②.数组断言</h4><p>通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;数组断言&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertArrayEquals(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="③-组合断言"><a href="#③-组合断言" class="headerlink" title="③.组合断言"></a>③.组合断言</h4><p>assertAll 方法接受多个org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;组合断言&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 断言需要全部成功才能够继续</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assertAll(<span class="string">&quot;Math&quot;</span>,</span><br><span class="line">                () -&gt; assertEquals(<span class="number">2</span>, <span class="number">1</span> + <span class="number">1</span>,<span class="string">&quot;结果不相等&quot;</span>),</span><br><span class="line">                () -&gt; assertTrue(<span class="number">1</span> &gt; <span class="number">0</span>,<span class="string">&quot;结果为假&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="④-异常断言"><a href="#④-异常断言" class="headerlink" title="④.异常断言"></a>④.异常断言</h4><p>在JUnit4时期，想要测试方法的异常情况时，需要用@Rule注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式Assertions.assertThrows() ,配合函数式编程就可以进行使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;异常测试&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertThrows(</span><br><span class="line">                <span class="comment">//扔出断言异常</span></span><br><span class="line">                ArithmeticException.class, () -&gt; System.out.println(<span class="number">1</span> % <span class="number">0</span>),</span><br><span class="line">                <span class="string">&quot;业务逻辑竟然正常运行&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑤-超时断言"><a href="#⑤-超时断言" class="headerlink" title="⑤.超时断言"></a>⑤.超时断言</h4><p>Junit5还提供了Assertions.assertTimeout() 为测试方法设置了超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;超时测试&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果测试方法时间超过1s将会异常</span></span><br><span class="line">        Assertions.assertTimeout(Duration.ofMillis(<span class="number">1000</span>), () -&gt; Thread.sleep(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑥-快速失败"><a href="#⑥-快速失败" class="headerlink" title="⑥.快速失败"></a>⑥.快速失败</h4><p>通过 fail 方法直接使得测试失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;快速失败&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fail(<span class="string">&quot;这应该失败&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="三、前置条件"><a href="#三、前置条件" class="headerlink" title="三、前置条件"></a>三、前置条件</h1><p>JUnit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于不满足的断言会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试前置条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;测试前置条件&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAssumptions</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Assumptions.assumeTrue(<span class="keyword">true</span>,<span class="string">&quot;结果不是True&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;数字&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。</p><h1 id="四、嵌套测试"><a href="#四、嵌套测试" class="headerlink" title="四、嵌套测试"></a>四、嵌套测试</h1><p>JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Kevin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021-03-23 20:38:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;嵌套测试&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestingAStackDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;is instantiated with new Stack()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isInstantiatedWithNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//嵌套测试情况下，外层的Test不能驱动内层的@Before(After)Each/All之类方法提前/之类运行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;when new&quot;)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WhenNew</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">createNewStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;新生成了一个Stack栈&quot;</span>);</span><br><span class="line">            stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;is empty&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when popped&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">throwsExceptionWhenPopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            assertThrows(EmptyStackException.class,stack::pop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when peeked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">throwsExceptionWhenPeeked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::peek);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nested</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;after pushing an element&quot;)</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AfterPushing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            String anElement = <span class="string">&quot;an element&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@BeforeEach</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">pushAnElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(stack.toString()+<span class="string">&quot;栈中防止一个元素：&quot;</span>+anElement.toString());</span><br><span class="line">                stack.push(anElement);</span><br><span class="line">                System.out.println(stack);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 内层的Test可以驱动外层的Before(After)Each/All的方法提前/之后运行</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;it is no longer empty&quot;)</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">isNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when popped and is empty&quot;)</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">returnElementWhenPopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                assertEquals(anElement, stack.pop());</span><br><span class="line">                assertTrue(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when peeked but remains not empty&quot;)</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">returnElementWhenPeeked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                assertEquals(anElement, stack.peek());</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="五、参数化测试"><a href="#五、参数化测试" class="headerlink" title="五、参数化测试"></a>五、参数化测试</h1><p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。<br>利用@ValueSource等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。<br>@ValueSource: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型<br>@NullSource: 表示为参数化测试提供一个null的入参<br>@EnumSource: 表示为参数化测试提供一个枚举入参<br>@CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参<br>@MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)<br>当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现ArgumentsProvider接口，任何外部文件都可以作为它的入参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line">    <span class="meta">@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;参数化测试1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterizedTest1</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">        Assertions.assertTrue(StringUtils.isNotBlank(string));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ParameterizedTest</span></span><br><span class="line">    <span class="meta">@MethodSource(&quot;method&quot;)</span>    <span class="comment">//指定方法名（方法必须是静态的而且需要返回一个Stream类型）</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;方法来源参数&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWithExplicitLocalMethodSource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        Assertions.assertNotNull(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>来源（尚硅谷SpringBoot教程）：<a href="https://www.yuque.com/atguigu/springboot">https://www.yuque.com/atguigu/springboot</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Alibaba Nacos</title>
      <link href="2021/04/30/SpringCloud%20Alibaba%20Nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
      <url>2021/04/30/SpringCloud%20Alibaba%20Nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Nacos概述"><a href="#1、Nacos概述" class="headerlink" title="1、Nacos概述"></a>1、Nacos概述</h1><h2 id="1-1、基本介绍"><a href="#1-1、基本介绍" class="headerlink" title="1.1、基本介绍"></a>1.1、基本介绍</h2><p>Nacos：Naming+Configuration的前两个字母，S代表Service。一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。<br>Nacos就是<strong>注册中心 + 配置中心</strong>的<strong>组合</strong>：Nacos = Eureka+Config +Bus<br>GitHub地址：<a href="https://github.com/alibaba/Nacos">https://github.com/alibaba/Nacos</a><br>中文文档：<a href="https://nacos.io/zh-cn/index.html">https://nacos.io/zh-cn/index.html</a></p><h2 id="1-2、与其它服务中心对比"><a href="#1-2、与其它服务中心对比" class="headerlink" title="1.2、与其它服务中心对比"></a>1.2、与其它服务中心对比</h2><p>Nacos支持<strong>AP与CP</strong>之间的<strong>切换</strong><br><img src="https://img-blog.csdnimg.cn/20210415163502543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="与其它服务中心对比"><br>C是所有节点在<strong>同一时间看到的数据是一致的</strong>；而A的定义是<strong>所有的请求都会收到响应</strong>。<br>何时选择使用何种模式？<br>一般来说，如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如 Spring cloud 和 Dubbo 服务，都适用于AP模式，AP模式为了服务的可能性而减弱了一致性，因此AP模式下只支持注册临时实例。</p><p>如果需要在服务级别编辑或者存储配置信息，那么 CP 是必须，K8S服务和DNS服务则适用于CP模式。<br>CP模式下则支持注册持久化实例，此时则是以 Raft 协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。</p><p>curl -X PUT ‘$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP’</p><h2 id="1-3、安装并运行Nacos"><a href="#1-3、安装并运行Nacos" class="headerlink" title="1.3、安装并运行Nacos"></a>1.3、安装并运行Nacos</h2><p><strong>Windows版本</strong><br>1、下载Nacos地址：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a><br>2、解压到指定文件夹，进入bin目录下直接点击startup.cmd运行。<br>3、访问：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a><br>4、账号和密码都是nacos登录页面即可登录成功</p><h1 id="2、Nacos服务注册中心"><a href="#2、Nacos服务注册中心" class="headerlink" title="2、Nacos服务注册中心"></a>2、Nacos服务注册中心</h1><h2 id="2-1、基于Nacos的服务提供者"><a href="#2-1、基于Nacos的服务提供者" class="headerlink" title="2.1、基于Nacos的服务提供者"></a>2.1、基于Nacos的服务提供者</h2><p>1、微服务父Pom添加依赖spring-cloud-alibaba-dependencies，子Pom添加spring-cloud-starter-alibaba-nacos-discovery依赖。（后面不做介绍）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、Yaml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-payment-provider</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 #配置Nacos地址</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;*&#39; #暴露所有web监控端点</span><br></pre></td></tr></table></figure><p>3、主启动类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain9001</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">            SpringApplication.run(PaymentMain9001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、业务类（返回该微服务的端口号）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    @Value(<span class="string">&quot;$&#123;server.port&#125;&quot;</span>)</span><br><span class="line">    private <span class="built_in">String</span> serverPort;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/payment/nacos/&#123;id&#125;&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">getPayment</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Nacos 注册中心,，端口号: &quot;</span> + serverPort + <span class="string">&quot;\t id=&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、测试<br>可以在Nacos-服务管理-服务列表控制台看到注册进来的微服务名称<br>再浏览器中输入<a href="http://localhost:9001/payment/nacos/123">http://localhost:9001/payment/nacos/123</a>可以访问到端口号加上id。<br>6、负载均衡前期准备<br>再依照9001端口创建9002微服务，加依赖，改Yaml，写主类/业务类。<br>如果想省事可以直接拷贝虚拟端口映射：①.再已运行的9001右击-Copy Configuration。②.更改配置名，并添加VM options：-Dserver port-9011。可以开启以9011端口的微服务。</p><h2 id="2-2、基于Nacos的服务消费者"><a href="#2-2、基于Nacos的服务消费者" class="headerlink" title="2.2、基于Nacos的服务消费者"></a>2.2、基于Nacos的服务消费者</h2><p>为什么Nacos自动支持负载均衡<br>因为Nacos在引入已经自动集成了Ribbon，所以自带负载均衡功能。<br>1、添加依赖spring-cloud-starter-alibaba-nacos-discovery。<br>2、修改Yaml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 83</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-order-consumer</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848</span><br><span class="line"></span><br><span class="line">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span><br><span class="line">service-url:</span><br><span class="line">  nacos-user-service: http:&#x2F;&#x2F;nacos-payment-provider </span><br></pre></td></tr></table></figure><p>3、主启动类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosMain83</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(OrderNacosMain83.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>4、注册RestTemplate用于调用服务类（配置类）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextBean</span> </span>&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    public RestTemplate <span class="function"><span class="title">restTemplate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、业务类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">&quot;$&#123;service-url.nacos-user-service&#125;&quot;</span>)</span><br><span class="line">    private <span class="built_in">String</span> serverURL;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/consumer/payment/nacos/&#123;id&#125;&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(serverURL + <span class="string">&quot;/payment/nacos/&quot;</span> + id, <span class="built_in">String</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、测试<br>可以在Nacos控制台看到已经注册的两个微服务提供者与一个微服务消费者<br>通过访问：<a href="http://localhost:83/consumer/payment/nacos/123">http://localhost:83/consumer/payment/nacos/123</a><br>可以发现获得的端口号是9001和9002交替出现，所以证明Nacos自动实现轮询负载均衡功能，既可以自动更改Ribbon的负载均衡的算法。</p><h1 id="3、Nacos作为配置中心（基础配置）"><a href="#3、Nacos作为配置中心（基础配置）" class="headerlink" title="3、Nacos作为配置中心（基础配置）"></a>3、Nacos作为配置中心（基础配置）</h1><h2 id="3-1、Nacos中的匹配规则"><a href="#3-1、Nacos中的匹配规则" class="headerlink" title="3.1、Nacos中的匹配规则"></a>3.1、Nacos中的匹配规则</h2><p>配置规则官网：<a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#公式：</span><br><span class="line">$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br></pre></td></tr></table></figure><p>简单来说：<br>①、prefix 默认为 spring.application.name （应用名）的值<br>②、spring.profile.active 即为当前环境对应的 profile，可以通过配置项 spring.profile.active 来配置。<br>③、file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置<br><img src="https://img-blog.csdnimg.cn/20210415165339856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="公式"></p><h2 id="3-2、微服务拉取配置"><a href="#3-2、微服务拉取配置" class="headerlink" title="3.2、微服务拉取配置"></a>3.2、微服务拉取配置</h2><p>1、添加spring-cloud-starter-alibaba-nacos-config依赖<br><strong>为什么两个配置？</strong><br>Nacos同springcloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取，<br>拉取配置之后，才能保证项目的正常启动。<br>springboot中配置文件加载存在优先级顺序的，bootstrap优先级高于application</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、创建两个配置文件bootstrap与application<br><strong>bootstrap</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># nacos配置</span><br><span class="line">server:</span><br><span class="line">  port: 3377</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-config-client</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 #Nacos服务注册中心地址</span><br><span class="line">      config:</span><br><span class="line">        server-addr: localhost:8848 #Nacos作为配置中心地址</span><br><span class="line">        file-extension: yaml #指定yaml格式的配置</span><br></pre></td></tr></table></figure><p><strong>application</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev # 表示开发环境</span><br></pre></td></tr></table></figure><p>3、主启动类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NacosConfigClientMain3377</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">            SpringApplication.run(NacosConfigClientMain3377.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、业务类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RefreshScope <span class="comment">//在控制器类加入@RefreshScope注解使当前类下的配置支持Nacos的动态刷新功能。</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    @Value(<span class="string">&quot;$&#123;config.info&#125;&quot;</span>)</span><br><span class="line">    private <span class="built_in">String</span> configInfo;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/config/info&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">getConfigInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、测试<br>启动前需要在nacos客户端-配置管理-配置管理栏目下有对应的yaml配置文件，访问：<a href="http://localhost:3377/config/info">http://localhost:3377/config/info</a><br>6、自带动态刷新<br>修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新。</p><h2 id="3-3、Nacos作为配置中心（分类配置）"><a href="#3-3、Nacos作为配置中心（分类配置）" class="headerlink" title="3.3、Nacos作为配置中心（分类配置）"></a>3.3、Nacos作为配置中心（分类配置）</h2><p>1、DataID方案<br>通过修改application.yml配置文件中的profile环境实现yaml的切换<br>2、Group方案<br>通过修改bootstrap.yml配置文件中的spring.cloud.nacos.config.group=组名即可修改组<br>3、Namespace方案<br>通过修改bootstrap.yml配置文件中的spring.cloud.nacos.config.namespace=空间ID即可修命名空间</p><h1 id="4、Nacos集群和持久化配置"><a href="#4、Nacos集群和持久化配置" class="headerlink" title="4、Nacos集群和持久化配置"></a>4、Nacos集群和持久化配置</h1><h2 id="4-1、概述"><a href="#4-1、概述" class="headerlink" title="4.1、概述"></a>4.1、概述</h2><p>官方说明：<a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a><br>我们采用Nginx集群+Nacos集群+MySQL集群进行搭建高可用<br><img src="https://img-blog.csdnimg.cn/20210415171158422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="集群"></p><h2 id="4-2、Nacos持久化配置"><a href="#4-2、Nacos持久化配置" class="headerlink" title="4.2、Nacos持久化配置"></a>4.2、Nacos持久化配置</h2><p>Nacos默认使用自带的数据库derby进行持久化，可以在源代码看到引入了derby数据库的依赖。<br><strong>Windows版如何从derby切换到mysql</strong><br>1、nacos\conf目录下找到sql脚本：nacos-mysql.sql。在MySQL创建库nacos_config;<br>并执行nacos-mysql.sql中的脚本创建表。<br>2、nacos\conf目录下找到application.properties添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform&#x3D;mysql</span><br><span class="line"> </span><br><span class="line">db.num&#x3D;1</span><br><span class="line">db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;nacos_config?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true</span><br><span class="line">db.user&#x3D;数据库账号</span><br><span class="line">db.password&#x3D;数据库密码</span><br></pre></td></tr></table></figure><p>3、重新启动Nacos可以看到没有记录了，重新创建一个配置文件可以在数据库中看到里面有记录证明修改成功。</p><h2 id="4-3、Linux版Nginx-Nacos-MySQL配置高可用"><a href="#4-3、Linux版Nginx-Nacos-MySQL配置高可用" class="headerlink" title="4.3、Linux版Nginx+Nacos+MySQL配置高可用"></a>4.3、Linux版Nginx+Nacos+MySQL配置高可用</h2><p>1、下载Linux版本Nacos，并使用tar -zxvf进行解压到Linux服务器中<br>2、下载Linux版本MySQL版本&gt;5.6.5以上。并使用mysql -uroot -proot，-u后面是用户名，-p后面是密码。创建数据库nacos_config并执行nacos\conf目录下的sql脚本：nacos-mysql.sql。nacos\conf目录下找到application.properties添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform&#x3D;mysql</span><br><span class="line"> </span><br><span class="line">db.num&#x3D;1</span><br><span class="line">db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;nacos_config?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true</span><br><span class="line">db.user&#x3D;数据库账号</span><br><span class="line">db.password&#x3D;数据库密码</span><br></pre></td></tr></table></figure><p>3、Linux服务器上nacos的集群配置cluster.conf，nacos/conf/cluster.conf修改为ip:端口号。需要使用：hostname -i命令Linux识别的ip地址不能是127.0.0.1。<br>4、编辑Nacos的启动脚本startup.sh，使它能够接受不同的启动端口<br>/mynacos/nacos/bin 的startup.sh（<strong>新版本不用修改</strong>）<br><img src="https://img-blog.csdnimg.cn/20210415172539730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="修改Start.sh命令"><br>5、在bin目录下使用./startup.sh -p 三个端口号开启服务<br>6、Nginx的配置，由它作为负载均衡器<br>编辑/usr/local/nginx/conf下的nginx.conf文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream cluster&#123;</span><br><span class="line">        server 127.0.0.1:3333;</span><br><span class="line">        server 127.0.0.1:4444;</span><br><span class="line">        server 127.0.0.1:5555;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       1111;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            #root   html;</span><br><span class="line">            #index  index.html index.htm;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;cluster;</span><br><span class="line">        &#125;</span><br><span class="line">        后面省略</span><br></pre></td></tr></table></figure><p>7、测试通过nginx访问nacos：<a href="http://192.168.174.145:1111/nacos">http://192.168.174.145:1111/nacos</a>如果能够成功访问到并添加一个配置文件能够在mysql的表中发现增加记录证明集群搭建完毕。<br>8、通过服务端访问Nacos集群：修改yaml配置文件spring.cloud.nacos.discover.server-addr=192.168.174.145:1111，如果能够在Nacos看到服务注册进入那么集群搭建成功。</p><h1 id="5、学习地址"><a href="#5、学习地址" class="headerlink" title="5、学习地址"></a>5、学习地址</h1><p>来源：哔哩哔哩尚硅谷：<a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Stream消息驱动</title>
      <link href="2021/04/30/SpringCloud%20Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/04/30/SpringCloud%20Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="1-1、是什么"><a href="#1-1、是什么" class="headerlink" title="1.1、是什么"></a>1.1、是什么</h2><p>官方定义 Spring Cloud Stream 是一个构建消息驱动微服务的框架。<br>应用程序通过 inputs 或者 outputs 来与 Spring Cloud Stream中binder对象交互。<br>通过我们配置来binding(绑定) ，而 Spring Cloud Stream 的 binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与 Spring Cloud Stream 交互就可以方便使用消息驱动的方式。</p><p>通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。<br>Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。</p><p>目前仅支持RabbitMQ、Kafka。<br>Spring官网：<a href="https://spring.io/projects/spring-cloud-stream#overview">https://spring.io/projects/spring-cloud-stream#overview</a><br>Stream中文手册：<a href="https://m.wang1314.com/doc/webapp/topic/20971999.html">https://m.wang1314.com/doc/webapp/topic/20971999.html</a></p><h2 id="1-2、设计思想"><a href="#1-2、设计思想" class="headerlink" title="1.2、设计思想"></a>1.2、设计思想</h2><p>通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。<img src="https://img-blog.csdnimg.cn/20210412195127763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="处理架构"><br>Binder可以生成Binding，Binding用来绑定消息容器的生产者和消费者，它有两种类型，INPUT和OUTPUT，INPUT对应于消费者，OUTPUT对应于生产者。<br>Stream中的消息通信方式遵循了发布-订阅模式，Topic主题进行广播，在RabbitMQ就是Exchange，在Kakfa中就是Topic。</p><h2 id="1-3、标准流程套路"><a href="#1-3、标准流程套路" class="headerlink" title="1.3、标准流程套路"></a>1.3、标准流程套路</h2><p><strong>Binder</strong>：很方便的连接中间件，屏蔽差异。<br><strong>Channel</strong>：通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置。<br><strong>Source</strong>和<strong>Sink</strong>：简单的可理解为参照对象是Spring Cloud Stream自身，<br>从Stream发布消息就是输出，接受消息就是输入。<br><strong>常用API和注解</strong><img src="https://img-blog.csdnimg.cn/2021041219541621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="2、构建"><a href="#2、构建" class="headerlink" title="2、构建"></a>2、构建</h1><h2 id="2-1、消息驱动的生产者"><a href="#2-1、消息驱动的生产者" class="headerlink" title="2.1、消息驱动的生产者"></a>2.1、消息驱动的生产者</h2><p><strong>添加依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-stream-provider</span><br><span class="line">  cloud:</span><br><span class="line">      stream:</span><br><span class="line">        binders: # 在此处配置要绑定的rabbitmq的服务信息；</span><br><span class="line">          defaultRabbit: # 表示定义的名称，用于于binding整合</span><br><span class="line">            type: rabbit # 消息组件类型</span><br><span class="line">            environment: # 设置rabbitmq的相关的环境配置</span><br><span class="line">              spring:</span><br><span class="line">                rabbitmq:</span><br><span class="line">                  host: localhost</span><br><span class="line">                  port: 5672</span><br><span class="line">                  username: guest</span><br><span class="line">                  password: guest</span><br><span class="line">        bindings: # 服务的整合处理</span><br><span class="line">          output: # 这个名字是一个通道的名称</span><br><span class="line">            destination: studyExchange # 表示要使用的Exchange名称定义</span><br><span class="line">            content-type: application&#x2F;json # 设置消息类型，本次为json，文本则设置“text&#x2F;plain”</span><br><span class="line">            binder: defaultRabbit # 设置要绑定的消息服务的具体设置</span><br></pre></td></tr></table></figure><p><strong>主运行类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StreamMQMain8801</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(StreamMQMain8801.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>发送消息的接口</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IMessageProvider</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="built_in">String</span> send() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@EnableBinding(Source.class)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">IMessageProviderImpl</span> <span class="title">implements</span> <span class="title">IMessageProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private MessageChannel output;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">sendMessage</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">String</span> serial = UUID.randomUUID().toString();</span><br><span class="line">        boolean send = output.send(MessageBuilder.withPayload(serial).build());</span><br><span class="line">        System.out.println(<span class="string">&quot;******serial******: &quot;</span> + serial);</span><br><span class="line">        <span class="keyword">if</span> (send) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;发送成功：&quot;</span>+serial;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;发送失败：&quot;</span>+serial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Controller控制层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private IMessageProvider messageProvider;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = <span class="string">&quot;/sendMessage&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> sendMessage()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> messageProvider.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:8801/sendMessage%E5%8F%AF%E4%BB%A5%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%EF%BC%8C%E5%9C%A8RabbitMQ%E4%B8%8A%E9%9D%A2%E7%9C%8B%E8%A7%81%E6%98%8E%E6%98%BE%E7%9A%84%E6%B6%88%E6%81%AF%E6%B3%A2%E5%8A%A8%E5%B3%B0">http://localhost:8801/sendMessage可以发送消息，在RabbitMQ上面看见明显的消息波动峰</a></p><h2 id="2-2、消息驱动的消费者"><a href="#2-2、消息驱动的消费者" class="headerlink" title="2.2、消息驱动的消费者"></a>2.2、消息驱动的消费者</h2><p><strong>添加依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-stream-consumer</span><br><span class="line">  cloud:</span><br><span class="line">      stream:</span><br><span class="line">        binders: # 在此处配置要绑定的rabbitmq的服务信息；</span><br><span class="line">          defaultRabbit: # 表示定义的名称，用于于binding整合</span><br><span class="line">            type: rabbit # 消息组件类型</span><br><span class="line">            environment: # 设置rabbitmq的相关的环境配置</span><br><span class="line">              spring:</span><br><span class="line">                rabbitmq:</span><br><span class="line">                  host: localhost</span><br><span class="line">                  port: 5672</span><br><span class="line">                  username: guest</span><br><span class="line">                  password: guest</span><br><span class="line">        bindings: # 服务的整合处理</span><br><span class="line">          input: # 这个名字是一个通道的名称</span><br><span class="line">            destination: studyExchange # 表示要使用的Exchange名称定义</span><br><span class="line">            content-type: application&#x2F;json # 设置消息类型，本次为对象json，如果是文本则设置“text&#x2F;plain”</span><br><span class="line">            binder: defaultRabbit # 设置要绑定的消息服务的具体设置</span><br></pre></td></tr></table></figure><p><strong>主运行类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StreamMQMain8802</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(StreamMQMain8802.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Controller控制层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@EnableBinding(Sink.class)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ReceiveMessageListener</span> </span>&#123;</span><br><span class="line">    @Value(<span class="string">&quot;$&#123;server.port&#125;&quot;</span>)</span><br><span class="line">    private <span class="built_in">String</span> serverPort;</span><br><span class="line"></span><br><span class="line">    @StreamListener(Sink.INPUT)</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">input</span>(<span class="params">Message&lt;<span class="built_in">String</span>&gt; message</span>)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所接收到的消息为======&quot;</span> + message.getPayload() + <span class="string">&quot;\t    &quot;</span> + <span class="string">&quot;端口号&quot;</span> + serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：<a href="http://localhost:8801/sendMessage%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%9C%A88802%E7%AB%AF%E5%8F%A3%E5%8F%AF%E4%BB%A5%E6%8E%A5%E6%94%B6%E5%88%B0%E6%B6%88%E6%81%AF%EF%BC%8C%E9%81%BF%E5%85%8D%E4%BA%86%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%8C%E7%B1%BB%E4%BC%BC%E4%BA%8E%E4%B8%80%E4%B8%AATemplate%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%E3%80%82">http://localhost:8801/sendMessage发送信息，在8802端口可以接收到消息，避免了中间件的不同，类似于一个Template可以进行发送和接收消息。</a></p><h1 id="3、Stream的分组消费与持久化"><a href="#3、Stream的分组消费与持久化" class="headerlink" title="3、Stream的分组消费与持久化"></a>3、Stream的分组消费与持久化</h1><h2 id="3-1、分组消费"><a href="#3-1、分组消费" class="headerlink" title="3.1、分组消费"></a>3.1、分组消费</h2><p><strong>再次构建一个8803端口与8802类似，步骤省略</strong><br>可以发现，如果生产者发送一条消息，两个消费者会同时消费一条消息，因为他们会自动生成一个流水号将他们划分到不同组，所以这里我们需要使用配置方法将其配置到同一个组去避免重复消费。<br><strong>yml配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    stream:</span><br><span class="line">      bindings: </span><br><span class="line">        input: </span><br><span class="line">          group: 组名</span><br></pre></td></tr></table></figure><p>这样就将其创建到同一个组去，再次发送消息，一条消息只会被一个消费端消费，不会重复消费</p><h2 id="3-2、持久化"><a href="#3-2、持久化" class="headerlink" title="3.2、持久化"></a>3.2、持久化</h2><p>Stream默认开启持久化，即使消费端宕机了，之后生产者发送消息的时候服务端收不到，当消费端再次上线且组别没有发生变化的时候消费端还能消费到未消费的信息。这样自动实现了持久化。</p><h1 id="4、学习地址"><a href="#4、学习地址" class="headerlink" title="4、学习地址"></a>4、学习地址</h1><p>来源：哔哩哔哩尚硅谷：<a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Alibaba Sentinel</title>
      <link href="2021/04/30/SpringCloud%20Alibaba%20Sentinel%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%90%E6%B5%81/"/>
      <url>2021/04/30/SpringCloud%20Alibaba%20Sentinel%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Sentinel概述"><a href="#1、Sentinel概述" class="headerlink" title="1、Sentinel概述"></a>1、Sentinel概述</h1><h2 id="1-1、Sentinel是什么"><a href="#1-1、Sentinel是什么" class="headerlink" title="1.1、Sentinel是什么"></a>1.1、Sentinel是什么</h2><p>轻量级的流量控制、熔断降级Java库，就类似于Hystrix框架，是Alibaba的。<br>GitHub地址：<a href="https://github.com/alibaba/Sentinel">https://github.com/alibaba/Sentinel</a><br>下载地址：<a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a><br>中文文档地址：<a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">https://github.com/alibaba/Sentinel/wiki</a><br>英文文档地址：<a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel</a></p><h2 id="1-2、Sentinel能做什么"><a href="#1-2、Sentinel能做什么" class="headerlink" title="1.2、Sentinel能做什么"></a>1.2、Sentinel能做什么</h2><p><img src="https://img-blog.csdnimg.cn/20210420144157203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="特性"></p><h2 id="1-3、Sentinel安装过程"><a href="#1-3、Sentinel安装过程" class="headerlink" title="1.3、Sentinel安装过程"></a>1.3、Sentinel安装过程</h2><p><img src="https://img-blog.csdnimg.cn/20210420144310662.png" alt="安装部分"><br>下载Jar包到本地，前提保证有JDK1.8环境以及8080端口未被占用，运行java -jar sentinel-dashboard-(版本号).jar。之后访问：<a href="http://localhost:8080/">http://localhost:8080</a>即可访问到控制台。</p><h2 id="1-4、初始化演示工程"><a href="#1-4、初始化演示工程" class="headerlink" title="1.4、初始化演示工程"></a>1.4、初始化演示工程</h2><p>1.添加依赖（必须保证Nacos和Sentinel同时存在依赖环境）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">      &lt;!--SpringCloud ailibaba sentinel --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2.修改Yaml配置文件将服务注册进入Nacos并配置Sentinel控制台和暴露监控点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8401</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloudalibaba-sentinel-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        #Nacos服务注册中心地址</span><br><span class="line">        server-addr: localhost:8848</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        #配置Sentinel dashboard地址</span><br><span class="line">        dashboard: localhost:8080</span><br><span class="line">        #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span><br><span class="line">        port: 8719</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;*&#39;</span><br></pre></td></tr></table></figure><p>3.主启动类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainApp8401</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApp8401.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.业务类Controller</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    @GetMapping(<span class="string">&quot;/testA&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> testA()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;================测试A已经成功通过================&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/testB&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> testB()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;================测试B已经成功通过================&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.测试<br>先启动Nacos再启动Sentinel，登录Sentinel发现什么都没有，需要<strong>事先访问资源端点</strong>才能在控制台看到资源目录。所以得到结论：sentinel8080正在监控微服务8401</p><h1 id="2、Sentinel流控规则"><a href="#2、Sentinel流控规则" class="headerlink" title="2、Sentinel流控规则"></a>2、Sentinel流控规则</h1><h2 id="2-1、流控规则基本术语介绍"><a href="#2-1、流控规则基本术语介绍" class="headerlink" title="2.1、流控规则基本术语介绍"></a>2.1、流控规则基本术语介绍</h2><p><img src="https://img-blog.csdnimg.cn/20210420145248483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="介绍"></p><h2 id="2-2、流控模式"><a href="#2-2、流控模式" class="headerlink" title="2.2、流控模式"></a>2.2、流控模式</h2><h3 id="2-2-1、直接"><a href="#2-2-1、直接" class="headerlink" title="2.2.1、直接"></a>2.2.1、直接</h3><p><img src="https://img-blog.csdnimg.cn/20210420145538204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>默认的流控规则，配置一秒钟最大允许一次通过，表示1秒钟内查询1次就是OK，若超过次数1，就直接-快速失败，报默认错误。<br>快速点击访问<a href="http://localhost:8401/testA%EF%BC%8C**%E4%BC%9A%E6%8A%A5Blocked">http://localhost:8401/testA，**会报Blocked</a> by Sentinel (flow limiting)这个默认错误**。</p><h3 id="2-2-2、关联"><a href="#2-2-2、关联" class="headerlink" title="2.2.2、关联"></a>2.2.2、关联</h3><p><img src="https://img-blog.csdnimg.cn/20210420145654755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>当关联的资源达到阈值时，就限流自己，当关联资源/testB的qps阀值超过1时，就限流/testA的Rest访问地址，当关联资源到阈值后限制配置好的资源名。<br>使用PostMan进行线程组访问testB节点，再访问testA资源发现A资源已经被限制访问。</p><h3 id="2-2-3、链路"><a href="#2-2-3、链路" class="headerlink" title="2.2.3、链路"></a>2.2.3、链路</h3><p>使用多个请求去调用同一个微服务，所以会出现链路失败的情况。</p><h2 id="2-3、流控效果"><a href="#2-3、流控效果" class="headerlink" title="2.3、流控效果"></a>2.3、流控效果</h2><h3 id="2-3-1、直接-gt-快速失败"><a href="#2-3-1、直接-gt-快速失败" class="headerlink" title="2.3.1、直接-&gt;快速失败"></a>2.3.1、直接-&gt;快速失败</h3><p>默认的流控处理效果，出现<strong>Blocked by Sentinel (flow limiting)</strong> 异常，源码位于DefaultController这个控制层中可以发现里面有这条语句。</p><h3 id="2-3-2、预热"><a href="#2-3-2、预热" class="headerlink" title="2.3.2、预热"></a>2.3.2、预热</h3><p><img src="https://img-blog.csdnimg.cn/20210420150242835.png" alt="配置"></p><p>公式：阈值除以coldFactor(默认值为3),经过预热时长后才会达到阈值。默认coldFactor为3，即请求 QPS 从 threshold / 3 开始，经预热时长逐渐升至设定的 QPS 阈值。<br>源码：WarmUpController类中。<br>应用场景：秒杀系统在开启的瞬间，会有很多流量上来，预热方式就是为了保护系统，以慢慢增大吞吐量。</p><h3 id="2-3-3、排队等待"><a href="#2-3-3、排队等待" class="headerlink" title="2.3.3、排队等待"></a>2.3.3、排队等待</h3><p><img src="https://img-blog.csdnimg.cn/20210420150421797.png" alt="在这里插入图片描述"></p><p>匀速排队，阈值必须设置为QPS。<br><img src="https://img-blog.csdnimg.cn/20210420150353239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>源码在：com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController</p><h1 id="3、Sentinel降级规则"><a href="#3、Sentinel降级规则" class="headerlink" title="3、Sentinel降级规则"></a>3、Sentinel降级规则</h1><h2 id="3-1、基本介绍"><a href="#3-1、基本介绍" class="headerlink" title="3.1、基本介绍"></a>3.1、基本介绍</h2><p>Sentinel 熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，<br>让请求快速失败，避免影响到其它的资源而导致级联错误。</p><p>当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。<br>Sentinel的断路器是<strong>没有半开状态</strong>的，不像Hystrix是有半开状态。<br><img src="https://img-blog.csdnimg.cn/20210420150744245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-2、降级策略-RT"><a href="#3-2、降级策略-RT" class="headerlink" title="3.2、降级策略-RT"></a>3.2、降级策略-RT</h2><p><img src="https://img-blog.csdnimg.cn/20210420150845450.png" alt="在这里插入图片描述"><br>Java代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/testD&quot;</span>)</span><br><span class="line">public <span class="built_in">String</span> testD()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    log.info(<span class="string">&quot;testD 测试RT&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testD&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置<br><img src="https://img-blog.csdnimg.cn/20210420150937180.png" alt="在这里插入图片描述"><br>永远一秒钟打进来10个线程（大于5个了）调用testD，我们希望200毫秒处理完本次任务，<br>如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开(保险丝跳闸)微服务不可用，保险丝跳闸断电了。</p><h2 id="3-3、降级策略-异常比例"><a href="#3-3、降级策略-异常比例" class="headerlink" title="3.3、降级策略-异常比例"></a>3.3、降级策略-异常比例</h2><p><img src="https://img-blog.csdnimg.cn/20210420151057235.png" alt="在这里插入图片描述"><br>Java代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/testD&quot;</span>)</span><br><span class="line">public <span class="built_in">String</span> testD()</span><br><span class="line">&#123;</span><br><span class="line">    log.info(<span class="string">&quot;testD 测试RT&quot;</span>);</span><br><span class="line">    int age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testD&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置<br><img src="https://img-blog.csdnimg.cn/20210420151137928.png" alt="在这里插入图片描述"><br>如果异常超过百分之二十就断开断路器<br>单独访问一次，必然来一次报错一次(int age  = 10/0)，调一次错一次；开启jmeter后，直接高并发发送请求，多次调用达到我们的配置条件了。断路器开启(保险丝跳闸)，微服务不可用了，不再报错<strong>error（页面）</strong>而是服务降级了。</p><h2 id="3-4、降级策略-异常数"><a href="#3-4、降级策略-异常数" class="headerlink" title="3.4、降级策略-异常数"></a>3.4、降级策略-异常数</h2><p><img src="https://img-blog.csdnimg.cn/20210420151239463.png" alt="在这里插入图片描述"><br>Java代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/testE&quot;</span>)</span><br><span class="line">public <span class="built_in">String</span> testE()</span><br><span class="line">&#123;</span><br><span class="line">    log.info(<span class="string">&quot;testE 测试异常比例&quot;</span>);</span><br><span class="line">    int age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testE 测试异常比例&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置<br><img src="https://img-blog.csdnimg.cn/20210420151306642.png" alt="在这里插入图片描述"><br><a href="http://localhost:8401/testE%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE%E7%BB%9D%E5%AF%B9%E6%8A%A5%E9%94%99%EF%BC%8C%E5%9B%A0%E4%B8%BA%E9%99%A4%E6%95%B0%E4%B8%8D%E8%83%BD%E4%B8%BA%E9%9B%B6%EF%BC%8C">http://localhost:8401/testE，第一次访问绝对报错，因为除数不能为零，</a><br>我们看到error窗口，但是达到5次报错后，进入熔断后降级。就不会报错误页面而是报服务降级的页面。</p><h1 id="4、Sentinel热点key限流"><a href="#4、Sentinel热点key限流" class="headerlink" title="4、Sentinel热点key限流"></a>4、Sentinel热点key限流</h1><h2 id="4-1、热点key限流基本配置"><a href="#4-1、热点key限流基本配置" class="headerlink" title="4.1、热点key限流基本配置"></a>4.1、热点key限流基本配置</h2><p>何为热点<br>热点即经常访问的数据，很多时候我们希望统计或者限制某个热点数据中访问频次最高的TopN数据，并对其访问进行限流或者其它操作。</p><p>我们能不能自定?类似hystrix，某个方法出问题了，就找对应的兜底降级方法？<br>使用@SentinelResource可以实现，类似于Hystrix的自定义降级方法。</p><p><strong>Java代码配置自定义降级方法显示</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/testHotKey&quot;</span>)</span><br><span class="line">    @SentinelResource(value = <span class="string">&quot;testHotKey&quot;</span>, blockHandler = <span class="string">&quot;defaultHandler_testHotKey&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> testHotKey(@RequestParam(value = <span class="string">&quot;p1&quot;</span>, required = <span class="literal">false</span>) <span class="built_in">String</span> p1,</span><br><span class="line">                             @RequestParam(value = <span class="string">&quot;p2&quot;</span>, required = <span class="literal">false</span>) <span class="built_in">String</span> p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;==============testHotKey&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">defaultHandler_testHotKey</span>(<span class="params"><span class="built_in">String</span> p1, <span class="built_in">String</span> p2, BlockException ble</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;==============defaultHandler_testHotKey，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时我们对第一个参数也就是p1进行限流，如果有它参与的请求那么久限制他的访问<br><img src="https://img-blog.csdnimg.cn/20210420151942837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-2、热点key参数例外项配置"><a href="#4-2、热点key参数例外项配置" class="headerlink" title="4.2、热点key参数例外项配置"></a>4.2、热点key参数例外项配置</h2><p>我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样，加入我们想要p1=3的时候，让他能够有更多的阈值。<br>在高级选项中打开这个并设置参数类型String，设置参数值为3，限定阈值为500。<br>这样传过来的参数p1只要等于3的时候就拥有500的上限。</p><h1 id="5、-SentinelResource注解详解"><a href="#5、-SentinelResource注解详解" class="headerlink" title="5、@SentinelResource注解详解"></a>5、@SentinelResource注解详解</h1><h2 id="5-1、基本限流配置存在的问题"><a href="#5-1、基本限流配置存在的问题" class="headerlink" title="5.1、基本限流配置存在的问题"></a>5.1、基本限流配置存在的问题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/byResource&quot;</span>)</span><br><span class="line">    @SentinelResource(value = <span class="string">&quot;byResource&quot;</span>, blockHandler = <span class="string">&quot;handleException&quot;</span>)</span><br><span class="line">    public CommonResult <span class="function"><span class="title">byResource</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;按资源名称限流测试OK&quot;</span>, <span class="keyword">new</span> Payment(2020L, <span class="string">&quot;serial001&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CommonResult <span class="function"><span class="title">handleException</span>(<span class="params">BlockException exception</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>, exception.getClass().getCanonicalName() + <span class="string">&quot;\t 服务不可用&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样限流之后，如果出现状况不会出现默认的页面会出现handleException中的结果。<br><strong>以上代码出现的问题</strong><br>1、依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。<br>2、每个业务方法都添加一个兜底的，那代码膨胀加剧。<br>3、全局统一的处理方法没有体现。</p><h2 id="5-2、全局限流配置"><a href="#5-2、全局限流配置" class="headerlink" title="5.2、全局限流配置"></a>5.2、全局限流配置</h2><p>编写一个类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CustomerBlockHandler</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> CommonResult <span class="function"><span class="title">handleException01</span>(<span class="params">BlockException exception</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>, <span class="string">&quot;自定义的限流处理信息，handleException01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> CommonResult <span class="function"><span class="title">handleException02</span>(<span class="params">BlockException exception</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>, <span class="string">&quot;自定义的限流处理信息，handleException02&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要在@SentinelResource中添加参数blockHandlerClass即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/rateLimit/customerBlockHandler&quot;</span>)</span><br><span class="line">    @SentinelResource(value = <span class="string">&quot;customerBlockHandler&quot;</span>,</span><br><span class="line">            blockHandlerClass = CustomerBlockHandler.class, blockHandler = <span class="string">&quot;handleException02&quot;</span>)</span><br><span class="line">    public CommonResult <span class="function"><span class="title">customerBlockHandler</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;按客户自定义限流处理逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样就可以指定是CustomerBlockHandler中的handleException02方法来处理被限流之后所出现的页面，避免代码耦合，解决全局统一与自定义。</p><h1 id="6、Sentinel服务熔断功能"><a href="#6、Sentinel服务熔断功能" class="headerlink" title="6、Sentinel服务熔断功能"></a>6、Sentinel服务熔断功能</h1><h2 id="6-1、Ribbon系列"><a href="#6-1、Ribbon系列" class="headerlink" title="6.1、Ribbon系列"></a>6.1、Ribbon系列</h2><p>1、创建服务提供者9003/9004，过程省略。<br>2、创建服务消费者84<br>①、Pom依赖文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--SpringCloud ailibaba sentinel --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>②、Yaml配置文件与之前的差不多不赘述<br>主要注册进入Nacos以及Sentinel中。<br>③、配置Ribbon的RestTemplate类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    public RestTemplate getRestTemplate()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④、Controller控制层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CircleBreakerController</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> final <span class="built_in">String</span> SERVICE_URL = <span class="string">&quot;http://nacos-payment-provider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line">    @RequestMapping(<span class="string">&quot;/consumer/fallback/&#123;id&#125;&quot;</span>)</span><br><span class="line">    @SentinelResource(value = <span class="string">&quot;fallback&quot;</span>, fallback = <span class="string">&quot;handlerFallback&quot;</span>, blockHandler = <span class="string">&quot;blockHandler&quot;</span>)</span><br><span class="line">    public CommonResult&lt;Payment&gt; <span class="function"><span class="title">fallback</span>(<span class="params">@PathVariable Long id</span>)</span> &#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span> + id, CommonResult.class, id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public CommonResult <span class="function"><span class="title">handlerFallback</span>(<span class="params">@PathVariable Long id, Throwable e</span>)</span> &#123;</span><br><span class="line">        Payment payment = <span class="keyword">new</span> Payment(id, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>, <span class="string">&quot;兜底异常handlerFallback,exception内容  &quot;</span> + e.getMessage(), payment);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public CommonResult <span class="function"><span class="title">blockHandler</span>(<span class="params">@PathVariable Long id, BlockException blockException</span>)</span> &#123;</span><br><span class="line">        Payment payment = <span class="keyword">new</span> Payment(id, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">445</span>, <span class="string">&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;</span> + blockException.getMessage(), payment);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>⑤、结论<br><strong>blockHandler</strong> 主要是管限流配置的，只配置了他，代码出现问题他管不着会返回错误页面，但是触发到限流条件了的话他会进行接管。<br><strong>fallback</strong> 主要管代码出现异常，代码500出现错误了之后直接返回fallback的友好页面。<br>若 <strong>blockHandler 和 fallback 都进行了配置</strong>，则被限流降级而抛出 BlockException 时只会进入 blockHandler 处理逻辑。</p><h2 id="6-2、Feign系列"><a href="#6-2、Feign系列" class="headerlink" title="6.2、Feign系列"></a>6.2、Feign系列</h2><p>1、添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud openfeign --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、修改上一个微服务的Yaml配置文件开启Sentinel对Feign的支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 激活Sentinel对Feign的支持</span><br><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: true </span><br></pre></td></tr></table></figure><p>3、带@FeignClient注解的业务接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value = <span class="string">&quot;nacos-payment-provider&quot;</span>, fallback = PaymentServiceImpl.class)</span><br><span class="line">public interface PaymentService &#123;</span><br><span class="line">    @GetMapping(value = <span class="string">&quot;/paymentSQL/&#123;id&#125;&quot;</span>)</span><br><span class="line">    public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(<span class="string">&quot;id&quot;</span>) Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、全局业务降级接口实现类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PaymentServiceImpl</span> <span class="title">implements</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult&lt;Payment&gt; <span class="function"><span class="title">paymentSQL</span>(<span class="params">Long id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>, <span class="string">&quot;服务降级返回，没有该流水信息&quot;</span>, <span class="keyword">new</span> Payment(id, <span class="string">&quot;errorSerial......&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、Controller控制层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">    private PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = <span class="string">&quot;/consumer/openfeign/&#123;id&#125;&quot;</span>)</span><br><span class="line">    public CommonResult&lt;Payment&gt; <span class="function"><span class="title">paymentSQL</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Long id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没有该id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paymentService.paymentSQL(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>6、主启动类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosMain84</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">            SpringApplication.run(OrderNacosMain84.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、测试：测试84调用9003，此时故意关闭9003微服务提供者，看84消费侧自动降级，不会被耗死。<br>结论：发现自动跳转到实现@FeignClient注解的业务接口的实现类上去了，不会被耗死，所以也有全局保护的功能。</p><h2 id="6-3、熔断框架比较"><a href="#6-3、熔断框架比较" class="headerlink" title="6.3、熔断框架比较"></a>6.3、熔断框架比较</h2><p><img src="https://img-blog.csdnimg.cn/20210420155045333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="7、Sentinel规则持久化"><a href="#7、Sentinel规则持久化" class="headerlink" title="7、Sentinel规则持久化"></a>7、Sentinel规则持久化</h1><p><strong>发现一个问题</strong>：一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化。所以我们需将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效。<br>1、修改8401的Pom文件（添加Sentinel整合Nacos的依赖）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-datasource-nacos&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、修改8401的Yaml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: localhost:8080 #配置Sentinel dashboard地址</span><br><span class="line">        port: 8719</span><br><span class="line">      datasource:</span><br><span class="line">        datasource1:</span><br><span class="line">          nacos:</span><br><span class="line">            server-addr: localhost:8848</span><br><span class="line">            dataId: cloudalibaba-sentinel-service</span><br><span class="line">            groupId: DEFAULT_GROUP</span><br><span class="line">            data-type: json</span><br><span class="line">            rule-type: flow</span><br></pre></td></tr></table></figure><p>3、在Nacos中添加Sentinel的配置规则<br><img src="https://img-blog.csdnimg.cn/20210420155539696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210420155528360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4、在Nacos中添加Sentinel的配置规则<br>启动8401端口之后，只要刷新一下Sentinel就可以看到规则已经出现在列表中了，快速访问<a href="http://localhost:8401/rateLimit/byUrl%E5%8F%91%E7%8E%B0%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99%E5%B7%B2%E7%BB%8F%E5%90%AF%E5%8A%A8%E4%BA%86%EF%BC%8C%E8%B6%85%E8%BF%87%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99%E5%B0%B1%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%BB%98%E8%AE%A4%E7%9A%84%E9%94%99%E8%AF%AF%E6%8F%90%E9%86%92%E3%80%82">http://localhost:8401/rateLimit/byUrl发现限流规则已经启动了，超过限流规则就会出现默认的错误提醒。</a><br>5、关闭8401服务之后规则消失，再次启动访问资源又回重新出现，达到持久化的目的。</p><h1 id="8、学习地址"><a href="#8、学习地址" class="headerlink" title="8、学习地址"></a>8、学习地址</h1><p>来源：哔哩哔哩尚硅谷：<a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Eureka与OpenFeign</title>
      <link href="2021/04/30/Eureka%E4%B8%8EOpenFeign/"/>
      <url>2021/04/30/Eureka%E4%B8%8EOpenFeign/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Eureka基础知识"><a href="#1、Eureka基础知识" class="headerlink" title="1、Eureka基础知识"></a>1、Eureka基础知识</h1><h2 id="1-1、什么是服务治理？"><a href="#1-1、什么是服务治理？" class="headerlink" title="1.1、什么是服务治理？"></a>1.1、什么是服务治理？</h2><p>Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理。在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。</p><h2 id="1-2、什么是服务注册？"><a href="#1-2、什么是服务注册？" class="headerlink" title="1.2、什么是服务注册？"></a>1.2、什么是服务注册？</h2><p>Eureka采用了CS的设计架构，Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。<br>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))<br><img src="https://img-blog.csdnimg.cn/2021041015073216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-3、Eureka两大组件"><a href="#1-3、Eureka两大组件" class="headerlink" title="1.3、Eureka两大组件"></a>1.3、Eureka两大组件</h2><p>Eureka包含两个组件：Eureka Server和Eureka Client<br>Eureka Server提供服务注册服务<br>各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p><p>EurekaClient通过注册中心进行访问<br>是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）</p><h1 id="2、单机Eureka构建步骤"><a href="#2、单机Eureka构建步骤" class="headerlink" title="2、单机Eureka构建步骤"></a>2、单机Eureka构建步骤</h1><h2 id="2-1、添加Eureka依赖"><a href="#2-1、添加Eureka依赖" class="headerlink" title="2.1、添加Eureka依赖"></a>2.1、添加Eureka依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--eureka-server--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-2、yaml配置文件"><a href="#2-2、yaml配置文件" class="headerlink" title="2.2、yaml配置文件"></a>2.2、yaml配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7001.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    #false表示不向注册中心注册自己。</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    service-url:</span><br><span class="line">      #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><h2 id="2-3、主启动类"><a href="#2-3、主启动类" class="headerlink" title="2.3、主启动类"></a>2.3、主启动类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaServer<span class="comment">//一定要添加上这个注解</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">EurekaMain7001</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4、访问"><a href="#2-4、访问" class="headerlink" title="2.4、访问"></a>2.4、访问</h2><p><a href="http://localhost:7001/">http://localhost:7001/</a><br>因为没有服务类加入进来所以列表是空的，接下来介绍如何将服务类加入进来。</p><h1 id="3、服务添加进Eureka步骤"><a href="#3、服务添加进Eureka步骤" class="headerlink" title="3、服务添加进Eureka步骤"></a>3、服务添加进Eureka步骤</h1><h2 id="3-1、引入依赖"><a href="#3-1、引入依赖" class="headerlink" title="3.1、引入依赖"></a>3.1、引入依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--eureka client--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="3-2、配置yaml文件"><a href="#3-2、配置yaml文件" class="headerlink" title="3.2、配置yaml文件"></a>3.2、配置yaml文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-provider-payment#服务名称</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: true#表示是否将自己注册进EurekaServer默认为true。</span><br><span class="line">    fetch-registry: true#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka#所加入的服务发现IP地址</span><br></pre></td></tr></table></figure><h2 id="3-3、主启动类"><a href="#3-3、主启动类" class="headerlink" title="3.3、主启动类"></a>3.3、主启动类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient<span class="comment">//应用Eureka客户端</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4、Eureka查看该服务"><a href="#3-4、Eureka查看该服务" class="headerlink" title="3.4、Eureka查看该服务"></a>3.4、Eureka查看该服务</h2><p><a href="http://localhost:7001/">http://localhost:7001/</a><br>可以在Instances currently registered with Eureka看到该服务已经注册进入。</p><h1 id="4、Eureka集群搭建"><a href="#4、Eureka集群搭建" class="headerlink" title="4、Eureka集群搭建"></a>4、Eureka集群搭建</h1><h2 id="4-1、复制Eureka的单机模块"><a href="#4-1、复制Eureka的单机模块" class="headerlink" title="4.1、复制Eureka的单机模块"></a>4.1、复制Eureka的单机模块</h2><p>修改yml中的端口号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7002</span><br></pre></td></tr></table></figure><h2 id="4-2、主类与单机一致，只需要将配置改为相互守望即可。"><a href="#4-2、主类与单机一致，只需要将配置改为相互守望即可。" class="headerlink" title="4.2、主类与单机一致，只需要将配置改为相互守望即可。"></a>4.2、主类与单机一致，只需要将配置改为相互守望即可。</h2><p><strong>7002端口的Eureka配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7002.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    #false表示不向注册中心注册自己。</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p><strong>7001端口的Eureka配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7001.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    #false表示不向注册中心注册自己。</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7002.com:2001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><h2 id="4-3、将客户端同时注册进入Eureka集群"><a href="#4-3、将客户端同时注册进入Eureka集群" class="headerlink" title="4.3、将客户端同时注册进入Eureka集群"></a>4.3、将客户端同时注册进入Eureka集群</h2><p>yml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka</span><br></pre></td></tr></table></figure><p>Eureka集群可以实现高可用。</p><h1 id="1、OpenFeign概述"><a href="#1、OpenFeign概述" class="headerlink" title="1、OpenFeign概述"></a>1、OpenFeign概述</h1><h2 id="1-1、OpenFeign是什么？"><a href="#1-1、OpenFeign是什么？" class="headerlink" title="1.1、OpenFeign是什么？"></a>1.1、OpenFeign是什么？</h2><p>Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。<br>它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡<br>GitHub地址：<a href="https://github.com/spring-cloud/spring-cloud-openfeign">https://github.com/spring-cloud/spring-cloud-openfeign</a></p><h2 id="1-2、Feign能干吗？"><a href="#1-2、Feign能干吗？" class="headerlink" title="1.2、Feign能干吗？"></a>1.2、Feign能干吗？</h2><p>Feign旨在使编写Java Http客户端变得更容易。<br>前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。</p><p>Feign集成了Ribbon<br>利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用</p><h1 id="2、OpenFeign使用"><a href="#2、OpenFeign使用" class="headerlink" title="2、OpenFeign使用"></a>2、OpenFeign使用</h1><h2 id="2-1、Pom文件，前提是Eureka已搭建成功"><a href="#2-1、Pom文件，前提是Eureka已搭建成功" class="headerlink" title="2.1、Pom文件，前提是Eureka已搭建成功"></a>2.1、Pom文件，前提是Eureka已搭建成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--openfeign--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>yml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><h2 id="2-2、主启动类"><a href="#2-2、主启动类" class="headerlink" title="2.2、主启动类"></a>2.2、主启动类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignMain80</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderFeignMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3、客户端的Service层接口"><a href="#2-3、客户端的Service层接口" class="headerlink" title="2.3、客户端的Service层接口"></a>2.3、客户端的Service层接口</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@FeignClient(value = <span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>)<span class="comment">//服务名称</span></span><br><span class="line">public interface PaymentFeignService &#123;</span><br><span class="line">    @GetMapping(<span class="string">&quot;/payment/get/&#123;id&#125;&quot;</span>)</span><br><span class="line">    public CommonResult getPaymentById(@PathVariable(<span class="string">&quot;id&quot;</span>) Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要与<strong>服务端</strong>的Controller进行对应</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/payment/get/&#123;id&#125;&quot;</span>)</span><br><span class="line">    public CommonResult <span class="function"><span class="title">getPaymentById</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Long id</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//业务逻辑省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="学习地址"><a href="#学习地址" class="headerlink" title="学习地址"></a>学习地址</h1><p>来源：<a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gateway网关学习笔记</title>
      <link href="2021/04/30/Gateway%E7%BD%91%E5%85%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/04/30/Gateway%E7%BD%91%E5%85%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="1-1、是什么"><a href="#1-1、是什么" class="headerlink" title="1.1、是什么"></a>1.1、是什么</h2><p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和 Project Reactor等技术。<br>Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能， 例如：熔断、限流、重试等。<br>SpringCloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架。<br>官网：<a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a></p><h2 id="1-2、做什么"><a href="#1-2、做什么" class="headerlink" title="1.2、做什么"></a>1.2、做什么</h2><p>反向代理、鉴权、流量控制、熔断、日志监控等等，相当于Servlet的过滤器。以下是<strong>架构图</strong>：<br><img src="https://img-blog.csdnimg.cn/20210412134605948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="架构图"></p><h2 id="1-3、三大核心概念"><a href="#1-3、三大核心概念" class="headerlink" title="1.3、三大核心概念"></a>1.3、三大核心概念</h2><h3 id="1-3-1、Route-路由"><a href="#1-3-1、Route-路由" class="headerlink" title="1.3.1、Route(路由)"></a>1.3.1、Route(路由)</h3><p>路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由</p><h3 id="1-3-2、Predicate-断言"><a href="#1-3-2、Predicate-断言" class="headerlink" title="1.3.2、Predicate(断言)"></a>1.3.2、Predicate(断言)</h3><p>参考的是Java8的java.util.function.Predicate<br>开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由。</p><h3 id="1-3-3、Filter-过滤"><a href="#1-3-3、Filter-过滤" class="headerlink" title="1.3.3、Filter(过滤)"></a>1.3.3、Filter(过滤)</h3><p>指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。</p><h1 id="2、Gateway配置过程"><a href="#2、Gateway配置过程" class="headerlink" title="2、Gateway配置过程"></a>2、Gateway配置过程</h1><h2 id="2-1、入门配置"><a href="#2-1、入门配置" class="headerlink" title="2.1、入门配置"></a>2.1、入门配置</h2><h3 id="2-1-1、通过配置文件进行配置"><a href="#2-1-1、通过配置文件进行配置" class="headerlink" title="2.1.1、通过配置文件进行配置"></a>2.1.1、通过配置文件进行配置</h3><p><strong>pom依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--gateway--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>主启动类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">GateWayMain9527</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(GateWayMain9527.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>yml配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9527</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          uri: http:&#x2F;&#x2F;localhost:8001          #匹配后提供服务的路由地址</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;payment&#x2F;get&#x2F;**         # 断言，路径相匹配的进行路由</span><br><span class="line"></span><br><span class="line">        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          uri: http:&#x2F;&#x2F;localhost:8001          #匹配后提供服务的路由地址</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;payment&#x2F;lb&#x2F;**         # 断言，路径相匹配的进行路由</span><br></pre></td></tr></table></figure><p><strong>主要注意三点，一个是配置的url地址，另一个是断言匹配路径，还有就是注册进入服务发现Eureka中心。先启动8001端口，再启动9527端口变可以通过9527端口的/payment/get/id访问到8001端口，从而实现路由的功能。</strong></p><h3 id="2-1-1、通过注入RouteLocator的Bean配置"><a href="#2-1-1、通过注入RouteLocator的Bean配置" class="headerlink" title="2.1.1、通过注入RouteLocator的Bean配置"></a>2.1.1、通过注入RouteLocator的Bean配置</h3><p>加入依赖与主启动类与上面相同，不同的是添加一个Config配置类进入容器.<br>需求分析，通过9527端口的/guonei访问到百度新闻的国内新闻：<a href="http://news.baidu.com/guonei%E3%80%82">http://news.baidu.com/guonei。</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">GateWayConfig</span> </span>&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RouteLocator <span class="function"><span class="title">customRouteLocator</span>(<span class="params">RouteLocatorBuilder routeLocatorBuilder</span>)</span> &#123;</span><br><span class="line">        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();</span><br><span class="line">        routes.route(<span class="string">&quot;path_route_kevin&quot;</span>,</span><br><span class="line">                r -&gt; r.path(<span class="string">&quot;/guonei&quot;</span>)</span><br><span class="line">                        .uri(<span class="string">&quot;http://news.baidu.com/guonei&quot;</span>)).build();</span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器中放入一个RouteLocator类，生成一个路由，建立一个路径为/guonei的映射到uri为<a href="http://news.baidu.com/guonei%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%AE%BF%E9%97%AE%E7%99%BE%E5%BA%A6%E5%9B%BD%E5%86%85%E6%96%B0%E9%97%BB%E7%9A%84%E7%9B%AE%E7%9A%84%E3%80%82">http://news.baidu.com/guonei，实现访问百度国内新闻的目的。</a></p><h2 id="2-2、通过微服务名称实现动态路由"><a href="#2-2、通过微服务名称实现动态路由" class="headerlink" title="2.2、通过微服务名称实现动态路由"></a>2.2、通过微服务名称实现动态路由</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9527</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由</span><br><span class="line">      routes:</span><br><span class="line">        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          # uri: http:&#x2F;&#x2F;localhost:8001          #匹配后提供服务的路由地址</span><br><span class="line">          uri: lb:&#x2F;&#x2F;cloud-payment-service #匹配后提供服务的路由地址</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;payment&#x2F;get&#x2F;**         # 断言，路径相匹配的进行路由</span><br><span class="line"></span><br><span class="line">        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          # uri: http:&#x2F;&#x2F;localhost:8001          #匹配后提供服务的路由地址</span><br><span class="line">          uri: lb:&#x2F;&#x2F;cloud-payment-service #匹配后提供服务的路由地址</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;payment&#x2F;lb&#x2F;**         # 断言，路径相匹配的进行路由</span><br></pre></td></tr></table></figure><p>l<strong>b://serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri</strong></p><h2 id="2-3、Predicate断言的使用"><a href="#2-3、Predicate断言的使用" class="headerlink" title="2.3、Predicate断言的使用"></a>2.3、Predicate断言的使用</h2><h3 id="2-3-1、是什么？"><a href="#2-3-1、是什么？" class="headerlink" title="2.3.1、是什么？"></a>2.3.1、是什么？</h3><p>Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping基础架构的一部分。<br>Spring Cloud Gateway包括许多内置的Route Predicate工厂。所有这些Predicate都与HTTP请求的不同属性匹配。多个Route Predicate工厂可以进行组合。</p><p>Spring Cloud Gateway 创建 Route 对象时， 使用 RoutePredicateFactory 创建 Predicate 对象，Predicate 对象可以赋值给 Route。 Spring Cloud Gateway 包含许多内置的Route Predicate Factories。</p><p>所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通过逻辑and。<br>官网链接：<a href="https://docs.spring.io/spring-cloud-gateway/docs/3.0.3-SNAPSHOT/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/3.0.3-SNAPSHOT/reference/html/#gateway-request-predicates-factories</a></p><h2 id="2-4、Filter过滤器的使用"><a href="#2-4、Filter过滤器的使用" class="headerlink" title="2.4、Filter过滤器的使用"></a>2.4、Filter过滤器的使用</h2><h3 id="2-4-1、常用的GatewayFilter"><a href="#2-4-1、常用的GatewayFilter" class="headerlink" title="2.4.1、常用的GatewayFilter"></a>2.4.1、常用的GatewayFilter</h3><p>yml配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">     filters:</span><br><span class="line">            - AddRequestParameter&#x3D;X-Request-Id,1024 #过滤器工厂会在匹配的请求头加上一对请求头，名称为X-Request-Id值为1024</span><br></pre></td></tr></table></figure><h3 id="2-4-2、自定义过滤器"><a href="#2-4-2、自定义过滤器" class="headerlink" title="2.4.2、自定义过滤器"></a>2.4.2、自定义过滤器</h3><p>自定义全局GlobalFilter，只需要继承两个接口即可：GlobalFilter, Ordered。并加入到容器中去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">    public <span class="class"><span class="keyword">class</span> <span class="title">MyLogGateWayFilter</span> <span class="title">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; <span class="function"><span class="title">filter</span>(<span class="params">ServerWebExchange exchange, GatewayFilterChain chain</span>)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;***************   come in MyLogGateWayFilter：&quot;</span>+<span class="keyword">new</span> <span class="built_in">Date</span>()+<span class="string">&quot;***************&quot;</span>);</span><br><span class="line">        <span class="built_in">String</span> uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (uname == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户名为非法用户┭┮﹏┭┮&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int <span class="function"><span class="title">getOrder</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须带有参数才能够访问：<a href="http://localhost:9527/payment/lb?uname=z3%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%B8%A6%E5%B0%B1%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E3%80%82">http://localhost:9527/payment/lb?uname=z3，如果不带就访问不了。</a></p><h1 id="3、学习地址"><a href="#3、学习地址" class="headerlink" title="3、学习地址"></a>3、学习地址</h1><p>哔哩哔哩尚硅谷来源：<a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC学习笔记</title>
      <link href="2021/04/30/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/04/30/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>第一章SpringMVC概述<br>springvc:是基于spring的一个框架，实际上就是spring的一个模块，专门是做web开发的。理解是servlet的一个升级</p><p>web开发底层是servlet ,框架是在servlet基础上面加入一些功能，让你做web开发方便。</p><p>SpringMVC就是一个Spring。Spring是容器，ioc能够管理对象，使用<bean>，@Component，@Repository，@Service，@Controller，SpringMVC能够创建对象，放入到容器中（SpringMVC容器），SpringMVC容器中放的是控制器对象。</p><p>       我们要做的是使用@Controller创建控制器对象，把对象放入到SpringMVC容器中，把创建的对象作为控制器使用，这个容器对象能接受用户的请求，显示处理结果，就当做是一个servlet使用（类似但并不是）。</p><p>       使用@Controller注解创建的是一个普通类的对象，不是Servlet。SpringMVC赋予了控制器对象一些额外的功能。</p><p>Web开发底层是servlet，SpringMVC中有个对象是Servlet：DispatherServlet（中央调度器）</p><p>DispatherServlet：负责接收用户所有的请求，用户把请求给了DispatherServlet，之后DispathServlet把请求转发给我们的Controller对象，最后是Controller对象处理请求。</p><p>Index.jsp—DispatherServlet(Servlet)—转发，分配给—Controller对象(@Controller注解创建的对象)</p><p>第二章Springmvc请求的处理流程<br>1).发起请求some.do—</p><p>2).tomcat(web.xml—url-pattern知道 *.do的请求是给中央调度DispatcherServlet)—</p><p>3)DispatcherServlet(根据springmvc.xml配置知道some.do—dosome())——-4)DispatcherServlet把some.do转发给MyController.doSome()方法</p><p>5)框架执行dosome()把得到ModelAndView进行处理，转发到show.jsp</p><p>上面的过程简化的方式</p><p>       Some.do—DispatcherServlet—MyController</p><p>Springmvc执行过程源代码分析</p><p>tomcat启动，创建容器的过程<br>通过load-on-start标签指定的1，创建DispatcherServlet对象，DispatcherServlet它的父类是集成HttpServlet的，它是一个serlvet，在被创建时，会执行init()方法。在init方法中<br>//创建容器，读取配置文件<br>webApplicationContext ctx=new ClassPathXmlApplicationContext(“springmvc.xml”)；<br>//把容器对象放入到ServletContext中<br>getServletContext().setAttribute(key,ctx);</p><p>上面创建容器作用：创建@Controller注解所在的类的对象。创建MyController对象中，这个对象放入到springmvc的容器中，容器是map，类似map.put(“myController”, MyController对象)</p><p>请求的处理过程<br>1）执行serv的service()</p><p>Protected void service(HttpServletRequest request,HttpServletResponse response)</p><p>Protected void doService(HttpServletRequest request,HttpServletResponse response)</p><p>DispatcherServlet.doDispatch(request,response){</p><p>调用MyController的dosom()方法;</p><p>}</p><p>       复习springmvc框架以及如何接收用户的参数</p><p>没有加入Java到JSON转换的时候其中内存中的对象</p><p>text/plain;charset=ISO-8859-1</p><p>发起的请求是由哪些服务器程序处理的。</p><p>Tomcat本身能处理静态资源的访问，像html，图片，js文件都是静态资源。</p><p> 表示静态资源和未映射的请求都给default处理</p><p>Default这个servlet作用：</p><p>处理静态资源<br>处理未映射到其他servlet的请求</p><p>复习前两天的内容：</p><p>解决请求中post方式有中文乱码，使用过滤器解决问题。CharacterEncodingFilter</p><p>逐个接收中，请求中参数名和形参名不一样，使用注解@RequestParam解决问题</p><p>使用Java对象接收请求参数时，要求请求中参数名和属性名一样。</p><p>Springmvc处理器方法的形参还可以用Map、List等集合类型，数组都可以。</p><p>处理器方法的返回值：</p><p>       表示请求的处理结果</p><p>ModelAndView，表示数据和视图，对视图执行forward<br>String：表示视图的，可以逻辑名称，完整视图路径，对视图执行forward<br>Void：返回值本身不能表示数据和视图，可以相应ajax请求<br>对象Object：表示数据的，可以响应ajax请求。<br>Springmvc处理器返回对象，转为json响应ajax步骤：①加入处理java转为json转换的工具库：使用jackson。②在springmvc配置文件加入注解驱动&lt;mvc：annotation-dirver&gt;。③在处理器方法上面加入@Requestbody。</p><p>url-pattren设置中央调度器的url-pattern是“/”：表示静态资源访问失败都是404，动态资源可以正常访问（例如网页的请求）。</p><p>              第一种解决静态资源访问的方案：在spring的配置文件中1）<a href="mvc:default-servelt-handler">mvc:default-servelt-handler</a> 2）<a href="mvc:annotation-driven">mvc:annotation-driven</a>。（原理：给程序内存中增加一个处理器对象，DefaultHttpRequestHandler，让这个对象来处理静态资源的访问）</p><p>             </p><p>在jsp，html中使用的地址，都是在前端页面中的地址，都是相对地址</p><p>地址分类：</p><p>绝对地址，带有协议名称的是绝对地址，<a href="http://www.baidu.com,ftp//202.122.23.1">http://www.baidu.com，ftp://202.122.23.1</a><br>相对地址，没有协议开头的，例如：user/some.do，/user/some.do。相对地址不能独立的使用，必须有一个参考地址，通过参考地址+相对地址本身才能够指定资源。<br>参考地址<br>在你的页面中的，访问地址不加“/”</p><p>访问的是：<a href="http://localhost:8080/ch06_path/index.jsp">http://localhost:8080/ch06_path/index.jsp</a></p><p>路径：<a href="http://localhost:8080/ch06_path/">http://localhost:8080/ch06_path/</a></p><p>资源：index.jsp</p><p>在index.jsp发起user/some.do请求，访问地址变为：<a href="http://localhost:8080/ch06_path/user/some.do">http://localhost:8080/ch06_path/user/some.do</a></p><p>当你的地址    没有斜杠开头，例如 user/some.do，当你点击链接时，访问地址是当前页面的地址再加上你链接的地址。</p><p><a href="http://localhost:8080/ch06_path/">http://localhost:8080/ch06_path/</a> + user/some.do</p><p>index.jsp 访问user/some.do，返回后现在的地址：<a href="http://localhost:8080/ch06_path/user/some.do">http://localhost:8080/ch06_path/user/some.do</a></p><p>路径<a href="http://localhost:8080/ch06_path/user/">http://localhost:8080/ch06_path/user/</a></p><p>资源：some.do</p><p>在index.jsp在user/some.do，就变为<a href="http://localhost:8080/ch06_path/user/user/some.do">http://localhost:8080/ch06_path/user/user/some.do</a></p><p>       解决方案：</p><p>加入EL表达式也就是下面介绍的那个。<br>加入一个base标签，是html语言中的标签。表示当前页面中访问地址的基地址。表示你的页面中所有没有“/”开头的地址，都是以base标签中的地址作为参考地址，使用base中的地址+user/some.do组成访问地址</p><p>2）在你的页面加上斜杠“/”</p><p>       访问的是：<a href="http://localhost:8080/ch06_path/index.jsp">http://localhost:8080/ch06_path/index.jsp</a></p><p>       路径：<a href="http://localhost:8080/ch06_path/">http://localhost:8080/ch06_path/</a></p><p>点击       /user/some.do 访问地址变为<a href="http://localhost:8080/user/some.do">http://localhost:8080/user/some.do</a>   参考地址是       你的服务器地址，也就是<a href="http://localhost:8080/">http://localhost:8080</a></p><p>如果你的资源不能加入${pageContext.request.contextPath}（这个叫做EL表达式）</p><p><a href="/ch06_path/user/some.do">发起user/first.do的get请求</a></p><p>如果你的资源不能访问，有一个/是绝对的所以我们需要加入${pageContext.request.contextPath}这个EL表达式.</p><p>Index,jsp—addStudent.jsp—student/addStudent.do(Service的方法dao的方法)—result.jsp</p><p>第四章 SpringMVC核心技术<br>SpringMVC框架采用的是统一，全局的异常处理。</p><p>把Controller中的所有异常处理都集中到一个地方。采用的是aop的思想。把业务逻辑和异常处理代码分开，解耦合。</p><p>使用两个注解</p><p>1.@ExceptionHandler</p><p>2.@ControllerAdvice</p><p>拦截器：</p><p>1）拦截器是SpringMVC中的一种，需要实现HandlerInterceptor接口</p><p>2）拦截器和过滤器类似，功能方向侧重点不同。过滤器是用来过滤器请求参数，设置编码字符集等工作。</p><p>3）拦截器是拦截用户请求，做请求做判断处理。</p><p>4）拦截器是全局的，可以对多个Controller做拦截。一个项目中可以有0个或多个拦截器，他们在一起拦截用户请求。拦截器常用在：用户登录处理，权限检查，记录日志。</p><p>拦截器的使用步骤：</p><p>定义类实现HandlerInterceptor接口<br>在SpringMVC配置文件中声明拦截器，让框架知道拦截器的存在。<br>拦截器的执行时间：</p><p>       1）在请求处理之前，也就是Controller类中的方法执行之前先被拦截。</p><p>       2）在控制器方法执行之后也会执行拦截器。</p><p>       3）在请求处理完成后也会执行拦截器。</p><p>拦截器原理图</p><p>拦截器：看做是多个Controller中公用的功能，集中到拦截器统一处理，使用的是AOP的思想。掌握第一个preHandle()方法</p><p>============================================================</p><p>多个拦截器：</p><p>第一个拦截器preHandle=true，第二个拦截器preHandle=true</p><p>11111111拦截器的MyInterceptor的preHandle()</p><p>22222222拦截器的MyInterceptor的preHandle()</p><p>===================执行MyController中的doSome方法==============</p><p>22222222拦截器的MyInterceptor的postHandle()</p><p>11111111拦截器的MyInterceptor的postHandle()</p><p>22222222拦截器的MyInterceptor的afterCompletion()</p><p>111111111111拦截器的MyInterceptor的afterCompletion()</p><p>第一个拦截器preHandle=true，第二个拦截器preHandle=false</p><p>11111111拦截器的MyInterceptor的preHandle()</p><p>22222222拦截器的MyInterceptor的preHandle()</p><p>111111111111拦截器的MyInterceptor的afterCompletion()</p><p>第一个拦截器preHandle= false，第二个拦截器preHandle=true</p><p>11111111拦截器的MyInterceptor的preHandle()</p><p>拦截器和过滤器的区别</p><p>过滤去是Servlet中的对象，拦截器是框架中的对象。<br>过滤器是实现Filter接口对象，拦截器是实现HandlerInterceptor<br>过滤器是用来设置request，Response的参数，属性的，侧重对数据过滤的。拦截器是用来验证请求的，能截断请求。<br>过滤器是在拦截器之前先执行的。<br>过滤器是Tomcat服务器创建的对象。拦截器是SPringMVC容器中创建的对象。<br>过滤器是一个执行时间点，而拦截器是有三个执行时间点。<br>过滤器可以处理jsp，js，html等等。拦截器是侧重拦截对Controller的对象，如果你的请求不能被中央调度器DispatcherServlet接收，这请求不会执行拦截器的内容。<br>过滤器拦截普通类方法执行，过滤器过滤Servlet请求响应。</p><p>用拦截器验证用户身份</p><p>Ch12</p><p>SpringMVC的执行流程（理解）<br>ApplicationContext ctx = new ClassPathXmlApplication ( “beans.xml”) ;studentservice service = (studentService) ctx.getBean ( “service”) ;</p><p>SpringMVC内部请求的处理流程：也就是SpringMVC接收请求，到处理完成的过程</p><p>用户发起请求some.do<br>DispatcherServlet接收请求some.do，把请求转交给处理器映射器。<br>处理器映射器：SpringMVC框架中的一种对象，框架把视线了HandlerMapping接口的类都叫做映射器（多个）。</p><p>处理器映射器作用：根据请求，从SpringMVC容器对象中获取处理器对象（MyController controller=ctx.getBean(“some.do”)）</p><p>                             框架把找到的处理器对象放到一个叫做处理器执行链(HandlerExecutionChain)的类保存</p><p>HandlerExecutionChain：类中保存着：1.处理器对象(MyController)；2.项目中的拦截器List<HandlerIntercept></p><ol start="3"><li>DispatcherServlet把2中的HandlerExecutionchain中的处理器对象交给了处理器适配器对象（多个)处理器适配器:springmvc框架中的对象，需要实现HandlerAdapter接口。I</li></ol><p>处理器适配器作用:执行处理器方法（调用MyController.doSome()得到返回值ModelAndView)</p><p>4．DispatcherServlet把3中获取的ModelAndView交给视图解析器对象。</p><p>视图解析器：SpringMVC的对象，需要实现ViewResoler接口（可以有多个）</p><p>视图解析器作用：组成视图完整路径，使用前缀，后缀。并创建View对象。</p><p>View是一个接口，表示视图，在框架中jsp，html不是string表示，而是使用View和他的实现类表示视图。</p><p>InternalResourceView:视图类，表示jsp文件，视图解析器会创建InternalResourceView类对象。这个对象的里面，有一个属性url=/WEB-INF/view/show.jsp</p><p>5．DispatcherServlet把4步骤中创建的view对象获取到，调用view类自己的方法，把Model数据放入到request作用域。执行对象视图的forward。请求结束。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架整合过程</title>
      <link href="2021/03/29/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%BF%87%E7%A8%8B/"/>
      <url>2021/03/29/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="创建Maven的Web项目"><a href="#创建Maven的Web项目" class="headerlink" title="创建Maven的Web项目"></a>创建Maven的Web项目</h1><p>创建Maven项目，点击Create from archetype，勾选org.apache.maven.archetypes:maven-archetype-webapp，写上项目名称以及Groupld，选择Maven库以及Maven Home，点击完成。<br>创建Java、Resource目录，项目结构如下：<br><img src="https://img-blog.csdnimg.cn/20210124221653919.png" alt="在这里插入图片描述"><br>创建bean实体包、Controller控制层包、dao持久化数据库操作包、Service服务包以及其目录下的ServiceImpl服务接口实现包。<img src="https://img-blog.csdnimg.cn/20210124221823903.png" alt="在这里插入图片描述"></p><h1 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h1><h6 id="创建jdbc-properties数据库连接文件"><a href="#创建jdbc-properties数据库连接文件" class="headerlink" title="创建jdbc.properties数据库连接文件"></a>创建jdbc.properties数据库连接文件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/数据库名称?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line">jdbc.username=用户名</span><br><span class="line">jdbc.passwd=密码</span><br></pre></td></tr></table></figure><h6 id="创建Mybatis-xml配置文件"><a href="#创建Mybatis-xml配置文件" class="headerlink" title="创建Mybatis.xml配置文件"></a>创建Mybatis.xml配置文件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--settings：控制mybatis全局行为--&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;!--设置mybatis输出日志--&gt;</span><br><span class="line">        &lt;setting name=<span class="string">&quot;logImpl&quot;</span> value=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">    &lt;!--设置别名--&gt;</span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;package name=<span class="string">&quot;实体类所在的包名&quot;</span>/&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line">    &lt;!-- sql mapper(sql映射文件)的位置--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;package name=<span class="string">&quot;mapper文件所在的包名在src/java/dao路径下&quot;</span>/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h6 id="创建Spring的ApplicationContext-xml配置文件"><a href="#创建Spring的ApplicationContext-xml配置文件" class="headerlink" title="创建Spring的ApplicationContext.xml配置文件"></a>创建Spring的ApplicationContext.xml配置文件</h6><p>其中需要声明数据源、声明SqlSessionFactory、扫描dao对象、服务层包的bean对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xmlns:mvc=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--spring配置文件：声明service，dao，工具类对象。--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--去声明数据源，连接数据库--&gt;</span><br><span class="line">    &lt;context:property-placeholder location=<span class="string">&quot;classpath:jdbc.&#x27;properties存放的位置&#x27;&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;dataSource&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span><br><span class="line">          init-method=<span class="string">&quot;init&quot;</span> destroy-method=<span class="string">&quot;close&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;jdbc.passwd&#125;&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--声明sqlSessionFactoryBean创建SqlSessionFactory--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;configLocation&quot;</span> value=<span class="string">&quot;classpath:&#x27;mybatis.xml存放的位置&#x27;&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--声明mybatis扫描器创建dao对象--&gt;</span><br><span class="line">    &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> value=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;basePackage&quot;</span> value=<span class="string">&quot;dao存放的引用路径&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--声明service的注解@Service所在的包名位置--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=<span class="string">&quot;service存放的引用路径&quot;</span>/&gt;</span><br><span class="line">    &lt;!--事务配置：注解的配置，aspectj的配置都在后面配置--&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h6 id="创建SpringMVC的DispatcherServlet-xml配置文件"><a href="#创建SpringMVC的DispatcherServlet-xml配置文件" class="headerlink" title="创建SpringMVC的DispatcherServlet.xml配置文件"></a>创建SpringMVC的DispatcherServlet.xml配置文件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xmlns:mvc=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;!--springmvc配置文件，声明Controller和其它web相关的对象--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--声明组件扫描器--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=<span class="string">&quot;controller所在的包名&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--声明springmvc框架中的视图解析器，帮助开发人员设置视图文件的路径--&gt;</span><br><span class="line">    &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br><span class="line">        &lt;!--前缀：视图文件的路径--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;prefix&quot;</span> value=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br><span class="line">        &lt;!--后缀：表示视图文件的扩展名，使用的<span class="built_in">Set</span>注入方式，赋值所以是用的value进行赋值--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;suffix&quot;</span> value=<span class="string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--声明注解驱动，做ajax和静态资源都需要用到注解驱动--&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h1 id="修改web-xml配置文件"><a href="#修改web-xml配置文件" class="headerlink" title="修改web.xml配置文件"></a>修改web.xml配置文件</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;4.0&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--中央调度器DispatcherServlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;web&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line">            &lt;param-value&gt;classpath:conf/DispatcherServlet.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;load-on-startup&gt;<span class="number">1</span>&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;web&lt;/servlet-name&gt;</span><br><span class="line">        &lt;!--将所有以.do结尾的处理都交给中央处理器解决--&gt;</span><br><span class="line">        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册spring的监听器--&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:conf/applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &lt;!--注册字符集过滤器，解决<span class="title">POST</span>乱码的问题--&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">characterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">filter</span>-<span class="title">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">CharacterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;!--设置项目中使用的字符编码--&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">utf</span>-8&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;!--强制请求对象（<span class="title">HTTPServletRequest</span>）使用<span class="title">enconding</span>编码的值--&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">forceRequestEncoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">true</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;!--强制应答对象（<span class="title">HTTPServletResponse</span>）使用<span class="title">enconding</span>编码的值--&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">forceResponseEncoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">true</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">characterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">web</span>-<span class="title">app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来就可以自己写业务逻辑代码了，或者使用EasyCode插件进行对应的逆向工程生成代码。这就是学习动力节点的B站相关视频总结出来的，感谢大家看到这儿，有问题欢迎指正，谢谢！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习笔记</title>
      <link href="2021/03/29/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/29/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章概述"><a href="#第一章概述" class="headerlink" title="第一章概述"></a>第一章概述</h1><p>框架怎么学：框架是一个软件，其他人写好的软件。<br>1）    知道框架能做什么，mybatis—访问数据库，对表中的数据执行增删改查<br>2）    框架的语法，框架要完成一个功能，需要一定的步骤支持的<br>3）    框架的内部实现，框架的内部怎么做。原理是什么？<br>4）    通过学习，可以实现一个框架。（写框架，实现框架）</p><h1 id="第二章控制反转IOC"><a href="#第二章控制反转IOC" class="headerlink" title="第二章控制反转IOC"></a>第二章控制反转IOC</h1><p>Spring的第一个核心思想。IOC（控制反转），是一个理论，概念，思想。描述：把对象的创建，赋值，管理工作都交给代码之外的容器实现。也就是对象的创建是有其它外部资源完成。<br>控制：创建对象，对象的属性赋值，对象之间的关系管理。<br>反转：把原来的开发人员管理，创建对象的权限转移给代码之外的容器实现。由容器代替工作人员管理对象，创建对象，给属性赋值<br>正转：由开发人员在代码中，使用new构造方法创建对象，开发人员主动管理对象。<br>为什么要使用ioc：目的就是减少对代码的改动，也能实现不同的功能。实现解耦合。<br>Java中创建对象有哪些方式：<br>1.构造方法，new Student（）<br>2.反射<br>3.序列化<br>4.克隆<br>5.Ioc：容器创建对象<br>6.动态代理</p><p>IOC的体现：<br>    Servlet 1：创建类继承HttpServelt<br>           2：在web.xml中注册servlet，使用<servlet-name>myservlet</servlet-name><br><servlet-class>com.bjpwernode.controller.MyServlet</servlet-class><br>           3：没有创建servlet对象，没有MyServlet myservlet=new MyServlet()<br>           4：Servlet是Tomcat服务器它不是你创建的。Tomcat也称为容器。<br>            Tomcat作为容器：里面存放servlet对象，Listener，Filter对象<br>IOC的技术实现，<br>    DI是ioc的技术实现，DI（Dependency Injection）是依赖注入，只需要在程序中提供要使用的对象名称就可以，至于对象如何在容器中创建，赋值，查找都由容器内部实现。<br>Spring是使用的di实现了ioc的功能，spring底层创建对象，使用的反射机制。<br>Spring是一个容器，管理对象，给属性赋值，底层是反射创建对象。</p><p>Junit：单元测试，一个工具类库，做测试方法使用的。<br>    单元：指定的是方法，一个类中有很多方法，一个方法称为一个单元。</p><ol><li>需要加入junit依赖。<dependency><!--      单元测试-->   <groupId>junit</groupId>   <artifactId>junit</artifactId>   <version>4.11</version>   <scope>test</scope></li><li>   创建测试作用的类：叫做测试类。<br>src/test/java目录中创建类</li><li>   创建测试方法<br>1）    public方法<br>2）    没有返回值void<br>3）    方法名称自定义，建议名称是test+你要测试的方法名称</li></ol><p> <br>4）    方法没有参数<br>5）    方法上面加入@Test，这样的方法是可以单独执行，不需要使用main方法。<br>什么样的对象放入容器中：dao类，service类，controller类，工具类<br>                        Spring中的对象默认都是单例，在容器中叫此名称对象仅一个</p><ol><li>   使用xml配置文件，使用bean标签</li><li>注解<br>不放到spring容器中的对象：实体类对象，实体类数据来自于数据库的。<pre><code>                     Servlet，listener，filter等。</code></pre>核心技术：IOC（控制反转）：1.理论，思想，概念：知道开发人员在容器中，代码之外管理对象，给属性赋值，管理依赖。<pre><code>                     2.IOC技术实现的DI（依赖注入）：开发人员在项目中只需要提供对象的名称，对象的创建查找赋值都由容器自己实现                     3.spring使用的DI的技术，底层使用的是反射机制                     4.DI给属性赋值：1set注入，2property方法赋值；引用类型注入属性名和ref的bean的id                                     2构造注入：constructor-arg的index和name进行对应构造方法的赋值</code></pre></li></ol><p>使用spring框架的步骤：加入依赖，创建类：接口、实现类、没有接口的类，创建spring的配置文件xml，使用<bean>声明对象，在使用容器中的对象，通过ApplicationContext接口和他的实现类ClassPathXmlApplcationContext的方法getBean（）就可以拿到容器。</p><p>1、    多个配置优势<br>a)    每个文件的大小比一个文件要小很多。效率高<br>b)    避免多人竞争带来的冲突<br>如果你的项目有多个模块（相关的功能在一起），一个模块一个配置文件。<br>    多文件的分配方式<br>a)    按功能模块，一个模块一个配置文件。<br>b)    按类的功能，数据库相关的配置一个文件配置文件，做事务的功能一个配置文件，做service功能的一个配置文件等</p><p>2、    基于注解的di：通过注解完成java对象创建，属性赋值。<br>使用注解的步骤：<br>    1、加入maven的依赖spring-context，在你加入spring-context的同时，<br>，间接加入spring-aop的依赖。使用注解必须使用aop的依赖。<br>    2、在类中加入spring 的注解（多个不同功能的注解）<br>    3、在spring的配置文件中，加入一个组件扫描器的标签，说明注解在你的项目中的位置<br>学习的注解：<br>    1、@Component，创建对象<br>    2、@Respotory，创建dao对象，用来访问数据库的。<br>    3、@Service，创建Service对象，处理业务逻辑的，可以有事务功能。<br>    4、@Controller，创建控制器对象，接受请求，显示处理结果。<br>    5、@Value，简单类型的属性赋值<br>    6、@Autowired，spring框架中引用类型的赋值注解，支持byName，byTyp默认是byType<br>    7、@Resource，jdk中的注解，使用自动注入给引用赋值，支持byName，byType，默认是byName<br>    8、注解的使用步骤：<br>        1、加入依赖：spring-context，简介加入spring-aop<br>        2、在类中加入注解<br>        3、在spring的配置文件中，加入组件扫描器的标签&lt;context:component-scan base-package=’包名’&gt;</p><p>Ioc能实现业务之间的解耦合，例如service和dao对象之间的解耦合。</p><h1 id="第三章AOP切面编程"><a href="#第三章AOP切面编程" class="headerlink" title="第三章AOP切面编程"></a>第三章AOP切面编程</h1><p>1．动态代理<br>    实现方式：JDK动态代理，使用JDK中的Proxy，Method，InvocationHanderl创建代理对象。JDK动态代理要求目标类必须实现接口<br>    Cglib动态代理：第三方的工具库，创建代理对象，原理是继承。通过继承目标类，创建子类，子类就是代理对象。要求目标类不能是final的，方法也不能是final<br>3.    动态代理的作用：<br>在目标类源代码不改变的情况下增加功能<br>减少代码的重复<br>专注业务逻辑代码<br>解耦合，让你的业务功能和日志，事务非业务功能分离<br>4.    AOP：面向切面编程，基于动态代理的，可以使用jdk，cglib两种代理方式。Aop就是动态代理的规范化，把动态代理的实现步骤，方式都定义好了，让开发人员用一种统一的方式，就用动态代理。<br>5.    AOP(Aspect Orient Programming)：面向切面编程<br>Aspect：切面，给你的目标类增加的功能，就是切面。上面的日志、事务<br>切面的特点：一般是非业务方法，独立使用<br>Orient：面向<br>Programming：编程<br>    怎么理解面向切面编程？<br>        1）需要在分析项目功能时，找出切面。<br>        2）合理的安排切面的执行时间（目标方法前，还是目标方法后）<br>        3）合理的安全切面执行位置，在哪个类具体增强什么功能。<br>    术语：<br>        1）Aspect：切面，表示增强的功能，代码，完成某个功能，非业务功能，常见的切面功能有日志，事务，统计信息，参数检查，权限验证。<br>        2）JoinPoint：连接点，连接业务和切面的位置。某类的业务方法<br>        3）Pointout：切入点，指多个连接点方法的集合。多个方法<br>        4）目标对象：给哪个类的方法增加功能，这个类就是目标对象<br>        5）Advice：通知，通知表示切面功能执行的时间。<br>说一个切面有三个关键的要素：<br>        1）切面的功能代码，切面干什么<br>        2）切面的执行位置，使用Pointcut表示切面执行的位置<br>        3）切面的执行时间，使用Advice表示时间，在目标方法之前还是目标方法之后<br>5、Aop的实现<br>    Aop是一个规范，是对动态代理的一个规范化，一个标准。<br>    Aop的技术实现框架：<br>        1、spring：spring内部实现了aop规范，能做aop的工作<br>                   Spring主要在事务处理使用aop<br>                   项目开发中很少使用spring 的aop实现，因为spring的aop比较笨重。<br>        2、aspectJ：一个开源的专门做aop的框架。Spring框架中集成了aspectJ框架，通过spring就能使用aspectJ的功能。<br>                    aspectJ框架实现aop的两种方式：</p><ol><li>   使用xml文件配置：配置全局事务</li><li>   使用注解，我们在项目中要做aop的功能，一般都用注解，aspectJ有5个注解。</li><li>学习aspectJ框架的使用<br>  1）切面的执行时间，这个执行时间在规范中他叫做Advice（通知，增强），在aspectJ框架中使用注解表示的。也可以使用xml配置文件中的标签<pre><code>  1）@Before  2）@AfterReturning  3）@Around  4）@AfterThrowing  5）@After</code></pre>  2）表示切面执行的位置，使用的是切入点表达式。</li></ol><h1 id="第四章Spring集成Mybatis"><a href="#第四章Spring集成Mybatis" class="headerlink" title="第四章Spring集成Mybatis"></a>第四章Spring集成Mybatis</h1><p>用的技术：ioc。<br>为什么ioc：能把Mybatis和spring集成到一起，像一个框架，是因为ioc能创建对象。<br>可以吧Mybatis框架中的对象交给spring统一创建，开发人员从spring中获取对象。<br>开发人员就不用同时面对两个或多个框架，就面对一个spring框架</p><p>Mybatis使用步骤：对象</p><ol><li>   定义dao接口，studentDao</li><li>   定义mapper文件 studentDao.xml</li><li>   定义mabatis的主配置文件 mybatis.xml文件</li><li>   创建dao 的代理对象，StudentDao dao=SqlSession.getMapper(StudentDao.class);<br>List<Student> students=dao.selectStudents();</li></ol><p>要使用dao对象，需要使用getMapper()方法，<br>怎么能使用getMapper()方法，需要哪些条件</p><ol><li>   获取SqlSession对象，需要使用SqlSessionFactory的openSession()方法。</li><li>   创建SqlSessionFactor对象。通过读取mybatis 的主配置文件，能创建SqlSessionFactory对象<br>需要SqlSessionFactory对象，使用Factory能获取SqlSession，有了SqlSession就能有dao，目的就是获取dao对象。Factory创建需要读取主配置文件。<br>主配置文件：</li><li>数据库信息</li><li>   Mapper文件的位置</li></ol><p>通过以上的说明，我们需要让spring创建以下对象<br>1.独立的连接池类的对象，使用阿里的druid连接池<br>2.SqlSessionFactory对象<br>3.创建出dao对象<br>需要学习就是上面三个对象的创建语法，使用xml的bean标签。</p><p>复习Aop：<br>    1.@Before：前置通知，在目标方法之前先执行切面的功能<br>    2.@AfterReturning后置通知，在目标方法之后执行的，能够获取到目标方法的返回值<br>    3.@Around环绕通知，在目标方法前和后都能增强功能，控制目标方法的访问，修改返回值<br>    4.@AterThrowing异常通知，在目标方法抛出异常后执行的通知<br>    5.@After最终通知，总是会被执行的代码<br>    6.@Pointcut定义和管理切入点的辅助注解<br>    7.代理的使用方法（1.如果目标有接口，框架使用jdk 的动态代理。如果目标类没有接口使用的是cglib动态代理。3.有接口也可以强制使用cglib动态代理。）</p><p>复习整合mybatis：<br>    使用spring的ioc核心技术，把mybatis框架中使用的对象交给spring统一创建和管理。（Spring是容器，存放项目中要使用的各种对象，例如Service对象，Dao对象，工具类对象等等。）<br>    1.交给spring的mybatis对象：1.数据源DataSource，使用阿里公司的Druid连接池<br>    2.SqlSessionFactory独享，使用的SqlSessionFactoryBean在内部创建的SqlSessionFactory<br>    3.Dao代理对象，使用的MapperScanConfigure，在这个类的内部，调用getMapper()，创建接口的Dao对象。</p><h1 id="第五章-Spring的事务处理"><a href="#第五章-Spring的事务处理" class="headerlink" title="第五章 Spring的事务处理"></a>第五章 Spring的事务处理</h1><ol><li>   什么是事务<br>讲mysql的时候，提出了事务，事务是指一组sql语句的集合，集合中有多条sql语句可能是insert，update，select，delete，我们希望这些多个sql语句都能成功，或者都失败，这些sql语句的执行是一直的，作为一个整体执行。</li><li>   在什么时候想到使用事务<br>当我的操作，涉及到多个表，或者是多个sql语句的insert，update，delete。需要保证这些语句都是成功才能完成我的功能，或者都失败，保证操作是符合要求的。<br>在java代码中写程序，控制事务，此时事务应该放在哪里呢？事务应该放在service类的业务方法上，因为业务方法会调用多个dao方法，执行多个sql语句</li><li>   通常使用JDBC访问数据库，还是mybatis访问数据库怎么处理事务<br>Jdbc访问数据库，处理事务 Connection conn；conn.commit()；conn.rollback();<br>Mybatis访问数据库，处理事务，SqlSession.commit()；SqlSession.rollback();<br>Hibernate访问数据库，处理事务，Session.commit()；Session.rollback()；</li><li>3问题中事务的处理方式，有什么不足<br>1）不同的数据库访问技术，处理事务的对象，方法不同，需要了解不同数据库访问技术使用事务的原理。<br>2）掌握多种数据库中事务的处理逻辑。什么时候提交事务，什么时候回滚事务。<br>3）处理事务的多种方法。<pre><code> 总结：就是多种数据库的访问技术，有不同的事务处理的机制，对象，方法</code></pre></li><li>   怎么解决不足<br>Spring提供一种处理事务的统一模型，能使用统一步骤，方式完成多种不同数据库访问技术的事务处理。<br>使用spring的事务处理机制，可以完成JDBC访问数据库的事务处理<br>使用spring的事务处理机制，可以完成mybatis访问数据的事务处理<br>使用spring的事务处理机制，可以完成hibernate访问数据库的事务处理</li><li>处理事务，需要怎么做，做什么<br>Spring处理事务的模型，使用的步骤都是固定的。把事务使用的信息提供给spring就可以了。<br>1）事务内部提交，回滚事务，使用的事务管理器对象，代替你完成commit，rollback。事务管理器是一个接口和他的众多实现类。<pre><code> 接口：PlatformTransactionManager，定义了事务重要方法commit，rollback 实现类：spring把每一种数据库访问技术对应的事务处理类都创建好了。 Mybatis访问数据库—spring创建好的DataSourceTransactionManager Hibernate访问数据库—spring创建DataSourceTransactionManager</code></pre>怎么使用：你需要告诉spring你用的哪种数据库访问技术，怎么告诉spring呢？声明数据库访问技术对于的事务管理器实现类，在spring的配置文件使用<bean>声明就可以了。例如：你要使用mybatis访问数据库，你应该在xml配置文件中<bean id=”XXX” class=”…DataSourceTransactionManager”>2）你的业务方法需要什么样的事务，说明需要事务的类型。 说明方法需要的事务： 2）事务的超时时间：表示一个方法最长的执行时间，如果方法执行时超过了，事务就会回滚。单位是秒，整数值，默认是-1。3）事务的传播行为：控制业务方法是不是有事务的，是什么样的事务的。7个传播行为，表示你的业务方法调用时，业务在方法之间是如果使用的。PROPAGATION_REQUIRED PROPAGATION_REQUIRES_NEW PROPAGATION_SUPPORTS 3）事务提交事务，回滚事务的时机 1）当你的业务方法，执行成功，没有异常抛出，当方法执行完毕，spring的方法执行后提交事务。事务管理器commit 2）当你的业务方法抛出运行异常，spring执行回滚，调用事务管理器的rollback运行时异常的定义：RuntimeException和他的子类都是运行时异常，例如NullPointException，NumberFormatException 3）当你的业务方法抛出非运行时异常，主要是受异常时，提交事务     受查异常：在你写代码中，必须处理的异常。例如IOExcetion，SQLException总结soring的事务</li><li>   管理事务的是事务管理和他的实现类</li><li>   Spring的事务是一个统一的模型<br>1）指定要使用的事务管理器实现类，使用<bean><br>2）指定哪些类，哪些方法需要加入事务的功能<br>3）指定方法需要的隔离级别，传播行为，超时时间<br>你需要告诉spring，你的项目类的信息，方法的名称，方法的事务传播行为。<br>Spring框架中提供的事务处理方案</li><li>适合中小项目使用的，注解方案。<br>spring框架自己用aop实现给业务方法增加事务的功能，使用@Transactional注解增加事务。Transactional注解是spring框架自己注解，放在public方法的上面，表示当前方法具有事务。可以给注解的属性赋值，表示具体的隔离级别，传播行为，异常信息等等。<br> 使用@Transactional的步骤</li><li>   需要声明事务管理器对象<bean id=”XX” class=”DataSourceTransactionMannager”></li><li>开启事务注解驱动，告诉spring框架，我要使用注解的方式管理事务。<br>Spring使用aop机制，创建@Transactional所在的类代理对象，给方法加入事务的功能。Spring给业务加入事务：<pre><code> 在你的业务执行之前，先开启事务，在业务方法之后提交或回滚事务，使用aop的环绕通知   3.在你的方法上面加入@Trancational注解</code></pre></li></ol><p>2.适合大型项目，有很多的类，方法，需要大量的配置事务，使用aspectj框架功能，在spring配置文件中声明类，方法需要的事务。这种方式业务方法和事务配置完全分离。<br>    实现步骤：都是在xml配置文件中实现。<br>        1）要使用的是aspectj框架，需要加依赖</p><pre><code>    2）声明事务管理器对象        &lt;bean id=”XXX” class=”DataSourceTransactionManager”&gt;    3）声明方法需要的事务类型（配置方法的事务属性【隔离级别，传播行为，超时】）    4）配置aop：指定哪些类要创建代理。</code></pre><h1 id="第六章Web项目使用ApplicationContext"><a href="#第六章Web项目使用ApplicationContext" class="headerlink" title="第六章Web项目使用ApplicationContext"></a>第六章Web项目使用ApplicationContext</h1><p>1.之前做的是javase项目有main方法的，执行代码是执行main方法，<br>    在main里面创建的容器对象<br>    ApplicationContext ctx=new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>2.web项目是在tomcat服务器上创建的，tomcat一启动，项目一直运行。</p><p>需求：<br>Web项目中容器对象只需要创建一次，把容器对象放到全局作用域ServletContext中。<br>怎么实现：<br>    使用监听器    当全局作用域对象被创建时    创建容器    存入ServletContext<br>    监听器的作用：<br>    1）创建容器对象，执行ApplicationContext ctx=new ClassPathApplicationContext(“applicationContext.xml”)<br>    2）把容器对象放入ServletContext，    ServletContext.setAttribute(key,ctx)<br>监听器可以自己创建，也可以使用框架中创建好的ContextLoaderListener（知道用法）</p><p>private wabApplicationcontext context;<br>public interface webApplicationcontext extends ApplicationContext<br>ApplicationContext：javase项目中使用的容器对象<br>webApplicationcontext：web项目中使用的容器对象<br>把创建的容器对象，放入到全局作用域</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记</title>
      <link href="2021/03/29/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/29/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>中文官网地址：<a href="http://www.redis.cn/">http://www.redis.cn</a><br>中文API文档地址：<a href="http://redisdoc.com/">http://redisdoc.com</a></p><h1 id="一、部署Redis"><a href="#一、部署Redis" class="headerlink" title="一、部署Redis"></a>一、部署Redis</h1><p>1.安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum -y install wget </span><br><span class="line">[root@localhost ~]# wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-6.0.6.tar.gz</span><br><span class="line">[root@localhost ~]# tar xzf redis-6.0.6.tar.gz</span><br><span class="line">[root@localhost ~]# cd redis-redis-6.0.6</span><br><span class="line">[root@localhost ~]# make   #提示报错选装GCC：yum install gcc-c++</span><br></pre></td></tr></table></figure><p>2.开启进程守护</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-6.0.6]# vi  redis.conf</span><br><span class="line"></span><br><span class="line"># Note that Redis will write a pid file in &#x2F;var&#x2F;run&#x2F;redis.pid when daemonized.</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><p>3.开启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">[root@localhost bin]# redis-server  &#x2F;redis-6.0.6&#x2F;redis.conf</span><br><span class="line">[root@localhost bin]# redis-cli  -p 6379</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p>4.关闭服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown</span><br><span class="line">not connected&gt; exit</span><br></pre></td></tr></table></figure><p>5.安装目录文件声明<br>redis-benchmark:性能测试工具，测试性能<br>redis-check-aof：修复有问题的AOF文件，<br>redis-check-dump：修复有问题的dump.rdb文件<br>redis-cli：客户端，操作入口<br>redis-sentinel：redis集群使用<br>redis-server：Redis服务器启动命令</p><p>参考于：<a href="https://blog.csdn.net/yangliuhbhd/article/details/81317689">https://blog.csdn.net/yangliuhbhd/article/details/81317689</a></p><h1 id="二、Redis常用命令"><a href="#二、Redis常用命令" class="headerlink" title="二、Redis常用命令"></a>二、Redis常用命令</h1><p><strong>Redis五大数据类型String（字符串）、Hash（哈希类似Java的Map）、List（列表）、Set（集合）、Zset（有序集合）</strong></p><p><strong>①String</strong><br>1.添加：set [key] [value]。带生命周期添加：setex [key] [秒数] [value]。带判断存在添加：setnx [key] [value]。<br>2.查询：keys [*]<br>3.删除：DEL [key]。使用FLUSHDB：清除当前数据库，FLUSHALL：清除所有数据库<br>4.移动：MOVE [key] [所移数据库名]<br>5.设置过期时间：EXPIRE [key名] [秒数]，查看过期时间ttl [key名]，如果为-1表示永不过期，-2表示已过期。其它时间为倒数秒数，已经过期的数据就被删除了，不会再keys *中查询到。<br>6.只增加数字不增字符串：INCR/DECR [key名]，增/减一。同理INCRBY/DECRBY [key名] [数字]。<br>7.定点查看字符串：GETRANGE [key名] [前下标] [后下标] ，截取下标添加字符串命令：SETRANGE [key名] [始标] [内容]。<br>8.追加：APPEND [key名] [追加数据]，查询长度：STRLEN [key名]<br>9.批量新增：mset [key] [value] [key] [value]……。批量获取：mget [key] [key] [key]。带判断的新增有序集合（如果数据库已存在都不会成功）：msetnx [key] [value] [key] [value]……。</p><p><strong>②List</strong><br>1.列表LIST相关添加：分为LPUSH和RPUSH，LPUSH [key] [v1] [v2] [v3]……，分为左右进入，如果你是使用左边进的话LPUSH就是逆着出LRANGE，如果你是RPUSH就是顺着出来LRANGE。可以这样理解，当使用LRANGE时是从左到右进行输出，使用LPUSH是从中间往左边插入，使用RPUSH是从中间往右边输入。只有RPUSH是怎么进怎么出。<br>2.创建LIST列表，命令：lpush [key名] [数组]，查看：LRANGE [LISTkey名] 0 -1，查看类型type [key名]。<br>3.列表出栈命令：lpop [key]和rpop [key]，一个是从左边出栈，一个是从右边出栈。<br>4.通过下标获取list中的值，LINDEX [list] [下标值]，是从左到右数的。下标从0开始。获取长度：LLEN [list]。<br>5.删除N个value：LREM [list] [所删除的个数] [所删除的数字]，如果删除的个数大于本身存在的个数，他就会把存在的全部删了，不会报错。<br>6.截取出其中一段赋值给本身：LTRIM [list] [始标] [末标]。<br>7.右出栈左进栈：RPOPLPUSH [list01] [list02] 。就是把后面的list01的右边最后一个添加到list02的左边第一个。<br>8.通过下标更改某一个值：lset [key] [index] [value]。在某个地方前/后插值：LINSERT [key] [before/after] [本身存在value1] [新值value2]。</p><p><strong>③Set</strong><br>1.添加：sadd [set名] [value] [value] ……。如果有重复的，集合默认把重复的忽略进行添加不重复的值。<br>2.查询：SMEMBERS [set名]。查看一个值是否在集合中：SMEMBERS [set名] [value]。查看元素个数SCARD [set名]。<br>3.删除集合中的值：SREM [set] [value]。<br>4.随机出值个数：SRANDMEMBER [set] [个数]。可用来抽奖。随机出栈：spop [set]。<br>5.移动一个值到另外的集合中：SMOVE [set源] [set目标] [所移动值]。<br>6.差集：SDIFF [set1集合] [set2集合] ……。所得出的数字是以set1集合为目标，不在后面任何一个集合中的数字出现。<br>7.交集：SINTER [set1集合] [set2集合] ……。所得出的数字是在这些集合中都有的数字。<br>8.并集：SUNION [set1集合] [set2集合] ……。所得出的数字是在这些全部数字但是不重复。</p><p><strong>④Hash（KV模式不变，但是V又是一个键值对）</strong><br>1.添加hash：hset [hash-key] [value-key] [value]。表示前面是添加符号，value-key表示的是value的key名字，最后面才是真正的value。<br>2.批量添加hash：hmset [hash-key] [value-key1][value1] [value-key2][value2] ……。所添加的就是一key为名的hash。批量获得hash：hmget [hash-key] [value-key1] [value-key2] 就可获得他们的value。第二种批量获得是：HGETALL [hash-key] 。会批量的得到前面是key后面的value的hash。<br>3.删除hash中某个value-key的value：hdel [hash-key] [value-key]。<br>4.获得hash的长度：hlen [hash-key]。<br>5.检测value-key是否存在hash中：HEXITS [hash-key] [value-key]。返回1为存在，返回0位不存在。<br>6.获取hash中每个keys的值：HKEYS [hash-key]。获取hash中每个value的值：HVALUES [hash-key]<br>7.使hash中数字key的value增减：HINCRBY [hash-key] [value-key] [所增长数字]。如果是浮点就是：HINCRBYFLOAT [hash-key] [value-key] [所增长数字]。<br>8.带判断存在的填充进入hash：HSETNX [hash-key] [value-key] [value]。</p><p><strong>⑤Zset有序集合（相当于在set集合基础之上加一个score值）</strong><br>1.添加有序集合：zadd [zset-key] [score1] [value1] [score2] [value2] ……。意思为后面的每个score和value是绑定到一起的是一个value。<br>2.序列输出：ZRANGE [zset-key] [0始标] [-1终标]。带有分数的序列输出：ZRANGE [zset-key] [始标] [终标] withscores。<br>3.输出范围的序列：ZRANGEBYSCORE [zset-key] [始分] [终分]。不包含命令：ZRANGEBYSCORE [zset-key] （[始分] （[终分]。在范围前加一个“（”表示不包含这个数。从范围序列中再进行筛选：ZRANGEBYSCORE [zset-key] [始分] [终分] limit [始标] [所取个数]。<br>4.删除某个值：ZREM [zset-key] [value]。把分数和value是一起删除的。<br>5.统计个数：ZCARD [zset-key]：分数和value是一体的，所以只有value的个数。<br>6.统计范围scores的个数：ZCOUNT [zset-key] [始分] [终分]。<br>7.顺序统计排名（以0开始）：ZRANK [zset-key] [value]。根据值输出对应分数：ZSCORE [zset-key] [value]。<br>8.逆序统计排名：ZREVRANK [zset-key] [value]。逆序获得名次。逆序统计名次输出：ZREVRANGE [zset-key] [0始标] [-1终标]。</p><h1 id="三、Redis如何持久化"><a href="#三、Redis如何持久化" class="headerlink" title="三、Redis如何持久化"></a>三、Redis如何持久化</h1><p>1.RDB、AOF。<br>2.RDB、AOF在指定的时间间隔内将内存中的数据集快照写入磁盘，<br>也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。Redis会单独创建（ fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。Fork的作用是赋值一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。<img src="https://img-blog.csdnimg.cn/20210129110414469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.在redis.conf配置文件中，系统会默默的给您生成三个策略，把dump.rdb保存到你的磁盘当中，这就是实现的持久化。<br>4.redis数据库中，运维会帮您把dump.rdb进行远程备份。当您使用FLUSHALL的时候清空了数据库在使用SHUTDOWN的时候他就将已经清空了的数据库保存下来了。所以这样下次就不能自动加载dump.rdb进行自动回复，需要下载dump.rdb进行恢复。简单来说：每次使用SHUTDOWN也会保存一次dump.rdb但是没有意义。如果有一个重要的数据需要保存，所以马上备份就是直接使用save命令，全部阻塞只管保存。bgsave是异步请求，一边保存一边接受新的增删。<br>5.RDB是非常紧凑文件，在保存文件父进程fork出子进程工作全由子进程做，所以RDB持久化方式可以最大化redis的性能。与AOF相比，恢复大的数据集时，RDB更快。缺点：丢失数据风险大，fork过程耗时间不能及时响应。<br>6.AOF：Append Only File：是在redis.conf配置文件append中默认关闭，我们将它开启之后它就会每次记录写入的操作。<br>7.AOF和RDB能够同时存在的，Redis启动时先读取AOF，如果AOF出现问题那么Redis启动被拒绝。如何解决？使用redis-check-aof自动帮你删除掉不符合它语法逻辑的，截断后面的。<br>8.重写原理，Redis会记录上次重写时的AOF大小，默认配置是当AOF大小是上次rewrite后大小的已被且文件大于64M时触发。但是现在至少的3GB起步了。<br>9.AOF文件是一个只进行追加的日志文件，Redis可以在AOF文件体积变得过大时，自动后台进行重写。AOF文件有序保存了对数据库写入操作，以Redis协议的格式保存，因此AOF文件的内容非常让人容易读懂。缺点：对于RDB来说AOF文件要大很多，根据fsync策略，AOF速度慢于RDB。<br>10.最终的性能建议：RDB作为后备策略，主要使用AOF来进行数据持久化。</p><h1 id="四、事务"><a href="#四、事务" class="headerlink" title="四、事务"></a>四、事务</h1><p>1.开启事务：MULTI。通常返回OK，之后进行的每个命令返回的都是QUEUED，最后使用EXEC就会返回一个队列为前面所执行的每一个结果输出。放弃事务不提交：DISCARD。<br>2.全体连坐：中间有一个出错了的话（注意是在加入队列的时候就报错(error)，相当于Java的编译时报错，这样的出错叫做全体连坐），事务提交不上去，所以就没有这一条事务，对应原子性。<br>3.冤头债主：中间有一个是出错了（但是他出错在加入队列的时候是能够加进去的，返回QUEUED而不是报错信息）这样最后提交事务EXEC那么错误的那条报错，其它的是能够提交上去的。<br>4.表锁：使用的时候整表锁住，一致性最高，并发性极差。行锁：加锁力度小一点，一致性一般，并发性较好。<br>5.悲观锁：相当于表锁，把整张表都锁住，每次使用都上锁，知道下一个拿到锁之后才能进行修改。乐观锁：相当于GitHub的Push推送，需要将最新版本号Pull下来之后在进行修改后在Push，这样在保证并发性的同时并保持一致性，策略：提交的版本必须大于记录当前版本才能执行更新。<br>6.Watch监控（类似于乐观锁）：假设一个信用卡时间，我这次使用了几块钱，下次就要换几块钱。使用balance和debt进行验证，初始为100和0。我们开始使用watch监控到balance之后，如果balance没有在其他线程进行修改那么它开启事务MULTI之后再进行decrby balance 20，incrby debt 20。最终提交exec那么它会出结果为80和20。  但是，如果在watch监控balance之后，另外一个线程去改变了balance的量之后，我们再进行之前的事务操作，事务就会失败。<br>7.UNwatch取消监控：第六条Watch监控失效之后，你所监控的key被修改了，那么需要使用UNwatch取消监控。之后在使用watch监控最新的版本，来进行开启事务MULTI，进行提交EXEC事务。这样就会成功。<br>8.一旦执行了EXEC或UNwatch之前被监控的所有key都被结算了。所以要重新监控。<br>9.了解redis有消息发布订阅。订阅：SUBSCRIBE [key1] [key2] [key3]……。另一个线程发布：PUBLISH [key名] [消息]。模糊订阅：PSUBSCRIBE [key]*，另一个线程发布：PUBLISH [key只要包含前一个key中的] [消息]。都会被接收到。</p><h1 id="五、主从复制"><a href="#五、主从复制" class="headerlink" title="五、主从复制"></a>五、主从复制</h1><p>1.Master用来写，Slave用来读。复制三个redis.conf，分别在redis后面加上端口号6379/80/81，之后进行配置他们的pidfile以及端口号和日志文件输出和dump+端口号。<br>2.分别使用三个配置文件开启端口号79 80 81的数据库，之后在使用info replication可以查看当前端口数据库是主还是从。之后从数据库使用SLAVEOF [ip地址] [端口号]来进行跟随主。并且在跟随主之前的数据都会被拷贝过来。<br>3.只有主机才能写，从机器只能读权限，所以他们写不了东西上去。<br>4.如果主机倒了，那么从机还是从机，不能变为主机，使用info replication还是从机。主机修复了之后从机依然跟随主机，不会发生任何改变，依然能够查询到主机添加的数据。<br>5.如果从机倒了，再进行端口打开连接，info replication那么他就从从机身份变成了主机身份，但是他是另外的一个主机身份，并不能查到之前主机数据库中的数据。除非写进了配置文件，不然都要重新连接主机。<br>6.一个主机可以有多个从机，但是一个从机只能有一个主机，从机可以跟随另外的一个从机，那么另外的中间从机它又是主机又是从机，但是它本身是不能写的所以这就形成了一个类似的链表结构。<br>7.中途变更转向：会清除之前的数据，重新读取新的主机的数据。<br>8.反客为主：SLAVEOF on noe。可以将主机已经下线的从机又变为新的主机。<br>9.哨兵模式：反客为主自动版。配置哨兵：sentinel monitor host6379 127.0.0.1 6379 1意思是代表监视6379的主机，如果SHUTDOWN了就后面跟随的从机器，谁的票数大于1就是谁是新主机。开启哨兵：redis-sentinel [sentinel.conf路径]。现在主机倒了，另外的从机会进行投票选出新的主机，而且不影响运行。但是如果倒掉的主机又重新连接上了，哨兵会将主机安排跟随新上位的从机。</p><h1 id="六、IDEA中如何使用Jedis"><a href="#六、IDEA中如何使用Jedis" class="headerlink" title="六、IDEA中如何使用Jedis"></a>六、IDEA中如何使用Jedis</h1><p>1.在IDEA中常用命令使用方法，先New一个Jedis(“ip地址”,”端口号”);之后方法基本上都是与命令行是差不多的。<br>2.IDEA中开启事务：jedis.multi();提交事务：jedis.exec();开始监控：jedis.watch(‘keys名’);<br>3.模拟网络阻塞时被监控目标被修改情况：在watch之后使用一个线程睡眠，与此同时在linux界面上去修改这个被监控的值，这样事务不会被提交。<br>4.测试主从复制，new Jedis两个不同的端口号。之后从机.slaveof(“IP地址”，端口号)，主机set值之后从机可以get到。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus</title>
      <link href="2021/03/29/MyBatisPlus/"/>
      <url>2021/03/29/MyBatisPlus/</url>
      
        <content type="html"><![CDATA[<p>@<a href="MybatisPlus%E7%AC%94%E8%AE%B0">TOC</a></p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-MyBatisPlus介绍"><a href="#1-MyBatisPlus介绍" class="headerlink" title="1.MyBatisPlus介绍"></a>1.MyBatisPlus介绍</h2><p>MyBatis-Plus( 简称 MP),是一个 MyBatis 的增强工具包，只做增强不做改变. 为简化开<br>发工作、提高生产率而生，我们的愿景是成为 Mybatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。</p><h2 id="2-代码及文档发布地址"><a href="#2-代码及文档发布地址" class="headerlink" title="2.代码及文档发布地址"></a>2.代码及文档发布地址</h2><p>官方地址:<br><a href="http://mp.baomidou.com/">http://mp.baomidou.com</a><br>代码发布地址:<br>Github: <a href="https://github.com/baomidou/mybatis-plus">https://github.com/baomidou/mybatis-plus</a><br>Gitee: <a href="https://gitee.com/baomidou/mybatis-plus">https://gitee.com/baomidou/mybatis-plus</a><br>文档发布地址:<br><a href="https://mp.baomidou.com/guide/">https://mp.baomidou.com/guide/</a><br>代码地址：<br><a href="https://github.com/ZKQevin/MybatisPlus">https://github.com/ZKQevin/MybatisPlus</a><br>学习地址：<br><a href="https://www.bilibili.com/video/BV1Ds411E76Y">https://www.bilibili.com/video/BV1Ds411E76Y</a></p><h1 id="二、集成MP"><a href="#二、集成MP" class="headerlink" title="二、集成MP"></a>二、集成MP</h1><h2 id="1-创建数据库表"><a href="#1-创建数据库表" class="headerlink" title="1.创建数据库表"></a>1.创建数据库表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 创建库 </span><br><span class="line">CREATE DATABASE mp; </span><br><span class="line">-- 使用库 </span><br><span class="line">USE mp; </span><br><span class="line">-- 创建表 </span><br><span class="line">CREATE TABLE tbl_employee( </span><br><span class="line">id INT(11) PRIMARY KEY AUTO_INCREMENT, </span><br><span class="line">last_name VARCHAR(50), </span><br><span class="line">email VARCHAR(50), </span><br><span class="line">gender CHAR(1),</span><br><span class="line"> age int </span><br><span class="line"> ); </span><br><span class="line">INSERT INTO tbl_employee(last_name,email,gender,age) VALUES(&#39;Tom&#39;,&#39;tom@qq.com&#39;,1,22); </span><br><span class="line">INSERT INTO tbl_employee(last_name,email,gender,age) VALUES(&#39;Jerry&#39;,&#39;jerry@qq.com&#39;,0,25); </span><br><span class="line">INSERT INTO tbl_employee(last_name,email,gender,age) VALUES(&#39;Black&#39;,&#39;black@qq.com&#39;,1,30); </span><br><span class="line">INSERT INTO tbl_employee(last_name,email,gender,age) VALUES(&#39;White&#39;,&#39;white@qq.com&#39;,0,35);</span><br></pre></td></tr></table></figure><h2 id="2-创建JavaBean实体类"><a href="#2-创建JavaBean实体类" class="headerlink" title="2.创建JavaBean实体类"></a>2.创建JavaBean实体类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private <span class="built_in">String</span> lastName;</span><br><span class="line">    private <span class="built_in">String</span> email;</span><br><span class="line">    private Integer gender;</span><br><span class="line">    private Integer age;</span><br><span class="line">    <span class="comment">//省略get和set以及ToString方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-添加依赖"><a href="#3-添加依赖" class="headerlink" title="3.添加依赖"></a>3.添加依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--单元测试依赖--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;4.11&lt;&#x2F;version&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--mp依赖</span><br><span class="line">           MybatisPlus 会自动维护Mybatis以及Mybatis-spring相关的依赖--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mybatis-plus&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;3.1.2&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--log4j--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.2.17&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--c3p0--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.mchange&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;0.9.5.2&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--mysql--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;5.1.38&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--spring--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;4.3.13.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-orm&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;4.3.24.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="4-引入数据源配置部分省略"><a href="#4-引入数据源配置部分省略" class="headerlink" title="4.引入数据源配置部分省略"></a>4.引入数据源配置部分省略</h2><h1 id="三、通用CRUD"><a href="#三、通用CRUD" class="headerlink" title="三、通用CRUD"></a>三、通用CRUD</h1><p>1)基于 Mybatis<br>需要编写 EmployeeMapper 接口，并手动编写 CRUD 方法<br>提供 EmployeeMapper.xml 映射文件，并手动编写每个方法对应的 SQL 语句.<br>2)基于 MybatisPlus<br>只需要创建 EmployeeMapper 接口, 并继承 BaseMapper 接口.这就是使用 M<br>(泛型指定的就是当前Mapper接口所操作的实体类)需要完成的所有操作，甚至不需要创建 SQL 映射文件。</p><h2 id="1-插入操作"><a href="#1-插入操作" class="headerlink" title="1.插入操作"></a>1.插入操作</h2><p> <strong>①.生成ID策略</strong><br><img src="https://img-blog.csdnimg.cn/20210204142803599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>②.开启驼峰命名转换以及对应数据库表</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@TableName(value = <span class="string">&quot;tbl_employee&quot;</span>)<span class="comment">//对应数据库名</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TableId:</span></span><br><span class="line"><span class="comment">     *  value：指定表中的主键列的列明，如果实体属性名与类名一直，可以省略不指定，</span></span><br><span class="line"><span class="comment">     *  type：指定主键策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @TableId(value = <span class="string">&quot;id&quot;</span>,type = IdType.AUTO)</span><br><span class="line">    private Integer id;</span><br><span class="line">    private <span class="built_in">String</span> lastName;</span><br><span class="line">    private <span class="built_in">String</span> email;</span><br><span class="line">    private Integer gender;</span><br><span class="line">    private Integer age;</span><br><span class="line">    @TableField(exist = <span class="literal">false</span>)<span class="comment">//忽略数据库没有的值salary</span></span><br><span class="line">    private Integer salary;</span><br><span class="line">    <span class="comment">//省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③.获取插入的ID值</strong><br>在<strong>mybatis</strong>的Mapper映射文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id&#x3D;&quot;insert&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt;&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure><p>在<strong>MybatisPlus</strong>中，直接在Java后台获取到不需要写Mapper</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer key=employee.getId();</span><br></pre></td></tr></table></figure><p><strong>④.插入对象出现空值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">testCommonInsert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化Employee对象</span></span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setLastName(<span class="string">&quot;MP&quot;</span>);</span><br><span class="line">        employee.setEmail(<span class="string">&quot;kevin@qq.com&quot;</span>);</span><br><span class="line">        Integer result = employeeMapper.insert(employee);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时插入结果为：MP,<a href="mailto:&#107;&#x65;&#x76;&#x69;&#110;&#x40;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;">&#107;&#x65;&#x76;&#x69;&#110;&#x40;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;</a>，null，null。<br><strong>结论</strong>：insert方法在插入时，会根据实体类的每个属性进行非空判断，只有非空的属性对应的字段才会出现到SQL语句中</p><h2 id="2-更新操作"><a href="#2-更新操作" class="headerlink" title="2.更新操作"></a>2.更新操作</h2><p>通过ID进行更新操作，传入一个对相同会进行自动判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testCommonUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setId(<span class="number">6</span>);</span><br><span class="line">        employee.setLastName(<span class="string">&quot;MybatisPlus&quot;</span>);</span><br><span class="line">        employee.setEmail(<span class="string">&quot;MybatisPlus@qq.com&quot;</span>);</span><br><span class="line">        employee.setGender(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//可以写一个构造方法，new Employee(6,&quot;Name&quot;,&quot;email&quot;,0,20)</span></span><br><span class="line">        <span class="comment">//如果出现非空会MybatisPlus会进行自动判断，不会出现在SQL语句中</span></span><br><span class="line">        employee.setAge(<span class="number">20</span>);</span><br><span class="line">        Integer result = employeeMapper.updateById(employee);</span><br><span class="line">        System.out.println(<span class="string">&quot;result：&quot;</span>+result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-查询操作"><a href="#3-查询操作" class="headerlink" title="3.查询操作"></a>3.查询操作</h2><p><strong>①.通过ID查询</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testCommonSelect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = employeeMapper.selectById(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Employee=&quot;</span>+employee);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>②.通过实体查询单条数据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.setId(<span class="number">4</span>);</span><br><span class="line">employee.setLastName(<span class="string">&quot;DSM&quot;</span>);</span><br><span class="line">Employee result = employeeMapper.selectOne(employee);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p><strong>③.传入多个ID查询多条记录</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; idList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">idList.add(<span class="number">4</span>);</span><br><span class="line">idList.add(<span class="number">5</span>);</span><br><span class="line">idList.add(<span class="number">6</span>);</span><br><span class="line">List&lt;Employee&gt; employees = employeeMapper.selectBatchIds(idList);</span><br><span class="line">System.out.println(employees);</span><br></pre></td></tr></table></figure><p><strong>④.使用HashMap封装对象查询</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; columnMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      columnMap.put(<span class="string">&quot;last_name&quot;</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">      columnMap.put(<span class="string">&quot;gender&quot;</span>,<span class="number">1</span>);</span><br><span class="line">      List&lt;Employee&gt; result = employeeMapper.selectByMap(columnMap);</span><br><span class="line">      System.out.println(result);</span><br></pre></td></tr></table></figure><p><strong>⑤.分页查询</strong><br>查询第三页，每一页显示两条数据，MybatisPlus会进行自动分页处理，底层使用的Mybatis的RowBounds方法进行处理，内存进行处理，所以SQL是看不到的。后续会使用MybatisPlus的插件进行物理分页</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IPage&lt;Employee&gt; result = employeeMapper.selectPage(<span class="keyword">new</span> Page&lt;&gt;(<span class="number">3</span>, <span class="number">2</span>), <span class="literal">null</span>);</span><br><span class="line">        System.out.println(result);</span><br></pre></td></tr></table></figure><h2 id="3-删除操作"><a href="#3-删除操作" class="headerlink" title="3.删除操作"></a>3.删除操作</h2><p><strong>①.通过id进行删除</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testCommonDelete</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Integer result = employeeMapper.deleteById(<span class="number">8</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result：&quot;</span>+result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>②.根据条件删除</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; columnMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      columnMap.put(<span class="string">&quot;last_name&quot;</span>,<span class="string">&quot;MP&quot;</span>);</span><br><span class="line">      columnMap.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;kevin@qq.com&quot;</span>);</span><br><span class="line">      Integer result = employeeMapper.deleteByMap(columnMap);</span><br><span class="line">      System.out.println(<span class="string">&quot;result&quot;</span>+result);</span><br></pre></td></tr></table></figure><p><strong>③.批量删除数据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; idList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      idList.add(<span class="number">12</span>);</span><br><span class="line">      idList.add(<span class="number">13</span>);</span><br><span class="line">      Integer result = employeeMapper.deleteBatchIds(idList);</span><br><span class="line">      System.out.println(<span class="string">&quot;result&quot;</span>+result);</span><br></pre></td></tr></table></figure><h2 id="4-MybatisPlus启动注入SQL原理分析"><a href="#4-MybatisPlus启动注入SQL原理分析" class="headerlink" title="4.MybatisPlus启动注入SQL原理分析"></a>4.MybatisPlus启动注入SQL原理分析</h2><p>问题: xxxMapper 继承了 BaseMapper, BaseMapper 中提供了通用的 CRUD 方法, 方法来源于 BaseMapper, 有方法就必须有 SQL, 因为 MyBatis 最终还是需要通过 SQL 语句操作数据。</p><h1 id="四、条件构造器"><a href="#四、条件构造器" class="headerlink" title="四、条件构造器"></a>四、条件构造器</h1><h2 id="1-QueryWrapper（条件查询构造器）"><a href="#1-QueryWrapper（条件查询构造器）" class="headerlink" title="1.QueryWrapper（条件查询构造器）"></a>1.QueryWrapper（条件查询构造器）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public Employee <span class="function"><span class="title">testQueryWrapperSelect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//1.我们需要分页查询tbl_employee表中，年龄在16-50之间性别为男性姓名为MP的所有用户</span></span><br><span class="line">        IPage&lt;Employee&gt; employeeIPage = employeeMapper.selectPage(<span class="keyword">new</span> Page&lt;Employee&gt;(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> QueryWrapper&lt;Employee&gt;()</span><br><span class="line">                        .between(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="number">50</span>)</span><br><span class="line">                        .eq(<span class="string">&quot;gender&quot;</span>, <span class="number">1</span>)</span><br><span class="line">                        .eq(<span class="string">&quot;last_name&quot;</span>, <span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        List&lt;Employee&gt; employees1=employeeIPage.getRecords();</span><br><span class="line">        employees1.forEach((value)-&gt; System.out.println(value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.查询tbl_employee表中，性别为女并且名字中带有“Tom”或者邮箱中带有“a“</span></span><br><span class="line">        List&lt;Employee&gt; employees2 = employeeMapper.selectList(<span class="keyword">new</span> QueryWrapper&lt;Employee&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;gender&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                .like(<span class="string">&quot;last_name&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">                .or()   <span class="comment">//SQL:(gender = ? AND last_name LIKE ? OR email LIKE ? )</span></span><br><span class="line">                <span class="comment">//.orNew()  //SQL:(gender = ? AND last_name LIKE ?) OR (email LIKE ? );貌似新版本已经取消orNew()了</span></span><br><span class="line">                .like(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        employees2.forEach(value -&gt; System.out.println(value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.使用last。查询为女的，根据age进行排序（asc/desc），进行分页</span></span><br><span class="line">        List&lt;Employee&gt; employees3 = employeeMapper.selectList(<span class="keyword">new</span> QueryWrapper&lt;Employee&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;gender&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                .orderByDesc(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">                .last(<span class="string">&quot;limit 1,3&quot;</span>));</span><br><span class="line">        employees3.forEach(value -&gt; System.out.println(value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.使用Condition分页查询tbl_employee表中，年龄在16-50之间性别为男性姓名为MP的所有用户（了解Condition即可）</span></span><br><span class="line">        <span class="comment">//employeeMapper.selectPage(new Page&lt;Employee&gt;(1,2),Connection.create().eq(&quot;gender&quot;,1));</span></span><br><span class="line">     <span class="comment">//5.另一种分页,获取每行存在list集合中，并且每行的字段都放在map集合中。key:value=columnName:value</span></span><br><span class="line">    Page&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt;&gt; page=employeeMapper.selectMapsPage(<span class="keyword">new</span> Page&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt;&gt;(<span class="number">1</span>,<span class="number">3</span>),</span><br><span class="line">                                                                <span class="keyword">new</span> QueryWrapper&lt;Employee&gt;().lambda()</span><br><span class="line">                                                                .between(Employee::getAge,<span class="number">15</span>,<span class="number">50</span>)</span><br><span class="line">                                                                .eq(Employee::getGender,<span class="number">1</span>)</span><br><span class="line">                                                                .eq(Employee::getLastName,<span class="string">&quot;MP&quot;</span>));</span><br><span class="line">    List&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt;&gt; emps=page.getRecords();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt; map:emps)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">String</span> key:map.keySet())&#123;</span><br><span class="line">            System.out.print(key+<span class="string">&quot;---&gt;&quot;</span>+map.get(key)+<span class="string">&quot;; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-UpdateWrapper（修改构造器）"><a href="#2-UpdateWrapper（修改构造器）" class="headerlink" title="2.UpdateWrapper（修改构造器）"></a>2.UpdateWrapper（修改构造器）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testUpdateWrapperSelect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setLastName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        employee.setEmail(<span class="string">&quot;Jack@sina.com&quot;</span>);</span><br><span class="line">        employee.setGender(<span class="number">0</span>);</span><br><span class="line">        Integer update = employeeMapper.update(employee, <span class="keyword">new</span> UpdateWrapper&lt;Employee&gt;()</span><br><span class="line">                        .eq(<span class="string">&quot;last_name&quot;</span>,<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">                        .eq(<span class="string">&quot;age&quot;</span>,<span class="number">44</span>));</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-UpdateWrapper（删除构造器）"><a href="#3-UpdateWrapper（删除构造器）" class="headerlink" title="3.UpdateWrapper（删除构造器）"></a>3.UpdateWrapper（删除构造器）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testDeleteWrapper</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Integer <span class="keyword">delete</span> = employeeMapper.delete(<span class="keyword">new</span> UpdateWrapper&lt;Employee&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;last_name&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        System.out.println(<span class="keyword">delete</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>本次教学只是常用的罗列出来，还有很多构造器方法在文档之中，需要自己学<br>MP：多个Wrapper    Condition 条件构造器<br>Mybatis MBG：xxxExample→Criteria：QBC(Query By Criteria) Hibernate、通用Mapper</p><h1 id="五、ActiveReccord（活动记录）"><a href="#五、ActiveReccord（活动记录）" class="headerlink" title="五、ActiveReccord（活动记录）"></a>五、ActiveReccord（活动记录）</h1><p><strong>1）概述</strong><br>Active Record(活动记录)，是一种领域模型模式，特点是一个模型类对应关系型数据库中的一个表，而模型类的一个实例对应表中的一行记录。<br>ActiveRecord 一直广受动态语言（ PHP 、 Ruby 等）的喜爱，而 Java 作为准静态语言，对于 ActiveRecord 往往只能感叹其优雅，所以 MP 也在 AR 道路上进行了一定的探索。</p><h2 id="1-使用AR：继承Model-lt-实体类-gt"><a href="#1-使用AR：继承Model-lt-实体类-gt" class="headerlink" title="1.使用AR：继承Model&lt;实体类&gt;"></a>1.使用AR：继承Model&lt;实体类&gt;</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Model</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//省略getset方法以及实体类属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-AR插入操作"><a href="#2-AR插入操作" class="headerlink" title="2.AR插入操作"></a>2.AR插入操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testARInsert</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setLastName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        employee.setEmail(<span class="string">&quot;Jack@qq.com&quot;</span>);</span><br><span class="line">        employee.setGender(<span class="number">1</span>);</span><br><span class="line">        employee.setAge(<span class="number">20</span>);</span><br><span class="line">        boolean insert = employee.insert();</span><br><span class="line">        System.out.println(<span class="string">&quot;Result=&quot;</span>+insert);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-AR修改操作"><a href="#3-AR修改操作" class="headerlink" title="3.AR修改操作"></a>3.AR修改操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testARUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="number">16</span>,<span class="string">&quot;JKL&quot;</span>,<span class="string">&quot;JKL@qq.com&quot;</span>,<span class="number">0</span>,<span class="number">15</span>);</span><br><span class="line">        System.out.println(employee.updateById());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-AR删除操作"><a href="#4-AR删除操作" class="headerlink" title="4.AR删除操作"></a>4.AR删除操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testARDelete</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        <span class="comment">//通过id删除数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过ID删除结果=&quot;</span>+employee.deleteById(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据条件删除数据(在逻辑上删除不存在的数据也是返回True)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过条件删除结果=&quot;</span>+employee.delete(<span class="keyword">new</span> QueryWrapper&lt;Employee&gt;().eq(<span class="string">&quot;last_name&quot;</span>,<span class="string">&quot;jack&quot;</span>)));</span><br></pre></td></tr></table></figure><h2 id="5-AR查询操作"><a href="#5-AR查询操作" class="headerlink" title="5.AR查询操作"></a>5.AR查询操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testARSelect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        <span class="comment">//通过id查询</span></span><br><span class="line">        System.out.println(employee.selectById(<span class="number">16</span>));</span><br><span class="line">        <span class="comment">//查询所有操作</span></span><br><span class="line">        System.out.println(employee.selectAll());</span><br><span class="line">        <span class="comment">//使用Wrapper以及AR进行模糊查询</span></span><br><span class="line">        employee.selectList(<span class="keyword">new</span> QueryWrapper&lt;Employee&gt;().like(<span class="string">&quot;last_name&quot;</span>,<span class="string">&quot;J&quot;</span>)).forEach(value -&gt; &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-AR分页复杂操作"><a href="#6-AR分页复杂操作" class="headerlink" title="6.AR分页复杂操作"></a>6.AR分页复杂操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testARPage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        <span class="comment">//selectpage方法将返回对象封装到一个Page对象中，如果要得到需要使用getRecord()方法。</span></span><br><span class="line">        IPage&lt;Employee&gt; employeeIPage = employee.selectPage(<span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>), <span class="keyword">new</span> QueryWrapper&lt;Employee&gt;().like(<span class="string">&quot;last_name&quot;</span>, <span class="string">&quot;T&quot;</span>));</span><br><span class="line">        employeeIPage.getRecords().forEach(value -&gt; &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h2><p>AR 模式提供了一种更加便捷的方式实现 CRUD 操作，其本质还是调用的 Mybatis 对应的方法，类似于<strong>语法糖</strong>。指计算机语言中添加的某种语法，这种语法对原本语言的功能并没有影响。可以更方便开发者使用，可以避免出错的机会，让程序可读性更好。</p><h1 id="六、代码生成器"><a href="#六、代码生成器" class="headerlink" title="六、代码生成器"></a>六、代码生成器</h1><p><strong>1）简介</strong><br>MP 提供了大量的自定义设置，生成的代码完全能够满足各类型的需求。AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。<br><strong>2）MP 的代码生成器 和 Mybatis MBG代码生成器的对比</strong><br>MP 的代码生成器都是基于 java 代码来生成。MBG 基于 xml 文件代码生成<br>MyBatis 的代码生成器可生成: 实体类、Mapper 接口、Mapper 映射文件</p><p>MP的代码生成器可生成: 实体类(可以选择是否支持 AR)、Mapper 接口、Mapper 映射文件、 Service 层、Controller层。IDEA的EasyCode也是可以进行生成。<br><strong>3）表及字段命名策略选择</strong><br>在MybatisPlus中，我们建议<strong>数据库表名</strong> 和 <strong>表字段名</strong>采用<strong>驼峰</strong>命名方式， 如果采用下划线命名方式，请开启全局下划线开关（版本2.3默认开启），如果表名字段名命名方式不一致请注解指定，我们建议最好保持一致（<strong>约定大于配置</strong>）</p><p>这么做的原因是为了避免在对应实体类时产生的性能损耗，这样字段不用做映射就能直接和实体类对应。当然如果项目里不用考虑这点性能损耗，那么你采用下滑线也是没问题的，只需要在生成代码时配置<strong>dbColumnUnderline</strong>(map-underscore-to-camel-case)属性就可以。</p><h2 id="1-使用添加依赖"><a href="#1-使用添加依赖" class="headerlink" title="1.使用添加依赖"></a>1.使用添加依赖</h2><p>添加 模板引擎 依赖和日志依赖，MyBatis-Plus 支持 <strong>Velocity</strong>（默认）、<strong>Freemarker</strong>、<strong>Beetl</strong>，用户可以选择自己熟悉的模板引擎，如果都不满足要求，可以采用自定义模板引擎。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Apach Velocity模版依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.velocity&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;velocity&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--sfl4j日志依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.7&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.7&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-生成器代码"><a href="#2-生成器代码" class="headerlink" title="2.生成器代码"></a>2.生成器代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testGenerator</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//1.全局策略配置</span></span><br><span class="line">        GlobalConfig config = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        config.setActiveRecord(<span class="literal">true</span>)<span class="comment">//是否支持AR模式</span></span><br><span class="line">                .setAuthor(<span class="string">&quot;kevin&quot;</span>)<span class="comment">//作者</span></span><br><span class="line">                .setOutputDir(<span class="string">&quot;D:\\Spring\\Spring-couse\\MyBatisPlus03\\src\\main\\java&quot;</span>)<span class="comment">//输出路径</span></span><br><span class="line">                .setFileOverride(<span class="literal">true</span>)<span class="comment">//文件覆盖</span></span><br><span class="line">                .setIdType(IdType.AUTO)<span class="comment">//主键策略</span></span><br><span class="line">                .setServiceName(<span class="string">&quot;%sService&quot;</span>)<span class="comment">//设置生成service接口名字的首字母是否为I（默认会生成I开头的IStudentService）</span></span><br><span class="line">                .setBaseResultMap(<span class="literal">true</span>)<span class="comment">//自动SQL映射文件，生成基本的ResultMap</span></span><br><span class="line">                .setBaseColumnList(<span class="literal">true</span>);<span class="comment">//生成基本的SQL片段</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.数据源配置</span></span><br><span class="line">        DataSourceConfig dataSourceConfig = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dataSourceConfig.setDbType(DbType.MYSQL)<span class="comment">//设置数据库类型</span></span><br><span class="line">                .setDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)<span class="comment">//数据库驱动名</span></span><br><span class="line">                .setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&quot;</span>)<span class="comment">//数据库地址</span></span><br><span class="line">                .setUsername(<span class="string">&quot;root&quot;</span>)<span class="comment">//数据库名字</span></span><br><span class="line">                .setPassword(<span class="string">&quot;123&quot;</span>);<span class="comment">//数据库密码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        strategy.setCapitalMode(<span class="literal">true</span>)<span class="comment">//全局大写命名</span></span><br><span class="line">                .setDbColumnUnderline(<span class="literal">true</span>)<span class="comment">//指定表明 字段名是否使用下划线</span></span><br><span class="line">                .setNaming(NamingStrategy.underline_to_camel)<span class="comment">//数据库表映射到实体的命名策略</span></span><br><span class="line">                .setTablePrefix(<span class="string">&quot;tbl_&quot;</span>)<span class="comment">//前置命名</span></span><br><span class="line">                .setInclude(<span class="string">&quot;tbl_employee&quot;</span>);<span class="comment">//生成的表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.包名策略</span></span><br><span class="line">        PackageConfig packageConfig = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        packageConfig.setParent(<span class="string">&quot;org.example&quot;</span>)<span class="comment">//所放置的包</span></span><br><span class="line">                .setMapper(<span class="string">&quot;mapper&quot;</span>)<span class="comment">//Mapper包</span></span><br><span class="line">                .setService(<span class="string">&quot;service&quot;</span>)<span class="comment">//服务层包</span></span><br><span class="line">                .setController(<span class="string">&quot;controller&quot;</span>)<span class="comment">//控制层</span></span><br><span class="line">                .setEntity(<span class="string">&quot;beans&quot;</span>)<span class="comment">//实体类</span></span><br><span class="line">                .setXml(<span class="string">&quot;mapper&quot;</span>);<span class="comment">//映射文件</span></span><br><span class="line">        <span class="comment">//5.整合配置</span></span><br><span class="line">        AutoGenerator autoGenerator = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line">        autoGenerator.setGlobalConfig(config)</span><br><span class="line">                .setDataSource(dataSourceConfig)</span><br><span class="line">                .setStrategy(strategy)</span><br><span class="line">                .setPackageInfo(packageConfig);</span><br><span class="line">        <span class="comment">//6.执行</span></span><br><span class="line">        autoGenerator.execute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-关于服务层自动注入"><a href="#3-关于服务层自动注入" class="headerlink" title="3.关于服务层自动注入"></a>3.关于服务层自动注入</h2><p>Service层的接口自动继承了了<strong>IService</strong>接口，里面有一些常用操作的接口<br>Service层的实现类不仅实现了Service层的接口，并且还继承了ServiceImpl类，该类也实现了IService接口。所以我们的serviceimpl不需要写一些简单具体操作的实现。并且也不需要自动注入mapper，在ServiceImpl中已经帮我们注入了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务层接口</span></span><br><span class="line">public interface EmployeeService <span class="keyword">extends</span> IService&lt;Employee&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务层实现类</span></span><br><span class="line">@Service</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">EmployeeMapper</span>, <span class="title">Employee</span>&gt; <span class="title">implements</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不用再进行Mapper的注入</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * EmployeeServiceImpl  集成了ServiceImpl</span></span><br><span class="line"><span class="comment">     * 1.在ServiceImpl中已经完成Mapper对象的注入，直接在EmployeeServiceImpl中进行使用</span></span><br><span class="line"><span class="comment">     * 2.在ServiceImpl中野帮我们提供了常用的CRUD方法，基本的一些CRUD方法在Service中不需要我们自己定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被继承的接口</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected M baseMapper;<span class="comment">//已自动注入Mapper</span></span><br><span class="line">    <span class="comment">//各种方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、插件拓展"><a href="#七、插件拓展" class="headerlink" title="七、插件拓展"></a>七、插件拓展</h1><h2 id="1-Mybatis插件机制简介"><a href="#1-Mybatis插件机制简介" class="headerlink" title="1.Mybatis插件机制简介"></a>1.Mybatis插件机制简介</h2><p><strong>1）插件机制</strong><br>Mybatis通过插件(Interkeptor)可以做到拦截四太对象相关方法的执行,根据需求，完成相关数据的动态改变。<br>Executor<br>StatementHandler<br>ParameterHandler<br>ResultSetHandler<br><strong>2）插件原理</strong><br>四太对象的每个对象在创建时，都会执行interceptorChain.pluginAll()，会经过每个插件对象的plugin()方法，目的是为当前的四太对象创建代理。代理对象就可以拦截到四太对象相关方法的执行，因为要执行四太对象的方法需要经过代理。<br><strong>3）注册插件</strong>：在Spring配置文件下sqlSessionFactory的bean标签下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注册插件--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;plugins&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">            &lt;!--注册分页插件--&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;com.baomidou.mybatisplus.plugins.PaginationInterceptor&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">                &lt;!--注册执行分析插件--&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;com.baomidou.mybatisplus.plugins.SqlExplainInterceptor&quot;&gt;</span><br><span class="line">                    &lt;!--停止全表操作--&gt;</span><br><span class="line">                    &lt;property name&#x3D;&quot;stopProceed&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;bean&gt;</span><br><span class="line">                &lt;!--注册性能分析插件--&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;com.baomidou.mybatisplus.plugins.PerformanceInterceptor&quot;&gt;</span><br><span class="line">                    &lt;property name&#x3D;&quot;format&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;!--是否进行格式化--&gt;</span><br><span class="line">                    &lt;property name&#x3D;&quot;maxTime&quot; value&#x3D;&quot;5&quot;&#x2F;&gt; &lt;!--最长执行时间，毫秒级--&gt;</span><br><span class="line">                &lt;&#x2F;bean&gt;</span><br><span class="line">                &lt;!--注册乐观锁插件--&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;com.baomidou.mybatisplus.plugins.OptimisticLockerInterceptor&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><p>还可以在Mybatis配置文件下configuration标签下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">        &lt;plugin interceptor&#x3D;&quot;com.baomidou.mybatisplus.plugins.PaginationInterceptor&quot; &#x2F;&gt;</span><br><span class="line">        …………</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br></pre></td></tr></table></figure><h2 id="2-分页插件"><a href="#2-分页插件" class="headerlink" title="2.分页插件"></a>2.分页插件</h2><p> 测试分页插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testPage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Page&lt;Employee&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    List&lt;Employee&gt; employees = employeeMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    employees.forEach(value -&gt; System.out.println(value));</span><br><span class="line">    System.out.println(<span class="string">&quot;总条数：&quot;</span>+page.getTotal());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前页码：&quot;</span>+page.getCurrent());</span><br><span class="line">    <span class="comment">//将查询的结果封装page对象中</span></span><br><span class="line">        page.setRecords(employees);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样就会看到在SQL中出现Limit限制语句是真正的进行了分页操作。我们还可以对查询到的数据进行封装为一个Page对象</p><h2 id="3-执行分析插件"><a href="#3-执行分析插件" class="headerlink" title="3.执行分析插件"></a>3.执行分析插件</h2><p>注册插件之后如果使用的对全表的操作，程序会自动摧毁此次请求。在测试阶段使用，不建议在生产阶段使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testSQLExplain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        employeeMapper.delete(<span class="literal">null</span>);<span class="comment">//全表删除操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-性能分析插件"><a href="#4-性能分析插件" class="headerlink" title="4.性能分析插件"></a>4.性能分析插件</h2><p>注册插件之后如果所执行的SQL超过执行时间之后那么此条SQL抛出异常。在测试阶段使用，不建议在生产阶段使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testPerformance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="string">&quot;marry&quot;</span>,<span class="string">&quot;marry@qq.com&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        employeeMapper.insert(employee);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-乐观锁插件"><a href="#5-乐观锁插件" class="headerlink" title="5.乐观锁插件"></a>5.乐观锁插件</h2><p><strong>1）实现原理</strong>：取出记录的时候获取当前Version版本号更新的时候带上Version，执行更新时，set version=youVersion+1 where versior=yourVersion。如果Version不对，就更新失败。必须使用@Version注解<br><strong>2）使用方法</strong>：在Spring配置文件ApplicationContext.xml配置文件中注册插件。在实体类和数据库添加字段Version。<br>在实体类上添加@Version注解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Version</span><br><span class="line">private Integer version;</span><br><span class="line"><span class="comment">//省略Get和Set方法</span></span><br></pre></td></tr></table></figure><p>测试方法，如果此时Version不与数据库中一致并不会报错只是不会更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testOptimisticLocker</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();<span class="comment">//更新操作</span></span><br><span class="line">        employee.setId(<span class="number">21</span>);</span><br><span class="line">        employee.setLastName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        employee.setVersion(<span class="number">2</span>);</span><br><span class="line">        employeeMapper.updateById(employee);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="八、自定义全局操作"><a href="#八、自定义全局操作" class="headerlink" title="八、自定义全局操作"></a>八、自定义全局操作</h1><p><strong>简介</strong><br>根据 MybatisPlus的 AutoSgllniector,可以自定义各种你想要的sal ,注入到全局中，相当于自定义Mxbatisplus自动注入的方法。</p><p>之前需要在xml中进行配置的SQL语句,现在通过扩展AutoSallnjector在加载mybatis,环境时就注入。</p><h2 id="1-AutoSqlInjector注入自定义SQL"><a href="#1-AutoSqlInjector注入自定义SQL" class="headerlink" title="1.AutoSqlInjector注入自定义SQL"></a>1.AutoSqlInjector注入自定义SQL</h2><p>1).Mapper中定义业务方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface EmployeeMapper <span class="keyword">extends</span> BaseMapper&lt;Employee&gt;&#123;</span><br><span class="line">    Integer deleteByName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2).定义MySqlInjector（新建一个injector包，MySqlInjector类）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MySqlInjector</span> <span class="keyword">extends</span> <span class="title">AutoSqlInjector</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展Inject方法，完成自定义全局操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">inject</span>(<span class="params">Configuration configuration, MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo table</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//将EmployeeMapper中定义的方法，处理成对应的MappedStatement对象，加入到configuration对象中。</span></span><br><span class="line">        <span class="comment">//注入的SQL语句</span></span><br><span class="line">        <span class="built_in">String</span> sql = <span class="string">&quot;delete from &quot;</span> + table.getTableName() + <span class="string">&quot; where name=JKL&quot;</span>;</span><br><span class="line">        <span class="comment">//注入的方法名    一定要与EmployeeMapper接口中的方法名一致</span></span><br><span class="line">        <span class="built_in">String</span> method = <span class="string">&quot;deleteByName&quot;</span>;</span><br><span class="line">        <span class="comment">//构造SqlSource对象</span></span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="comment">//构造一个删除的MappedStatement</span></span><br><span class="line">        <span class="built_in">this</span>.addDeleteMappedStatement(mapperClass, method, sqlSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3).自定义的MySqlInjector配置到ApplicationContext.xml全局策略中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义MybatisPlus的全局策略配置，在版本2.3以后就不用管了默认把数据库下划线变成驼峰就可以插入和主键策略问题--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;globalConfiguration&quot; class&#x3D;&quot;com.baomidou.mybatisplus.entity.GlobalConfiguration&quot;&gt;</span><br><span class="line">        &lt;!-- 在2.3版本以后，dbColumnUnderline 默认值就是true --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dbColumnUnderline&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!--注入自定义全局操作--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;sqlInjector&quot; ref&#x3D;&quot;mySqlInjector&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!--定义自定义注入器--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;mySqlInjector&quot; class&#x3D;&quot;org.example.injector.MySqlInjector&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>4).定义测试类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testMySqlInjector</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Integer i = employeeMapper.deleteByName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Result=&quot;</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-自定义注入器引用之逻辑删除"><a href="#2-自定义注入器引用之逻辑删除" class="headerlink" title="2.自定义注入器引用之逻辑删除"></a>2.自定义注入器引用之逻辑删除</h2><p><strong>假删除、逻辑删除</strong>：并不会真正的从数据库中讲数据删除掉，而是将当前被删除的这条数据中的一个逻辑删除字段置为删除操作。<strong>举例</strong>：tbl_user  logic_flag=1（可用），logic_flag=-1（不可用）。<br>1)新增数据表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tbl_user( </span><br><span class="line">id INT(11) PRIMARY KEY AUTO_INCREMENT, </span><br><span class="line">NAME VARCHAR(50),</span><br><span class="line">logic_flag INT(11)</span><br><span class="line"> ); </span><br></pre></td></tr></table></figure><p>实体类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private <span class="built_in">String</span> name;</span><br><span class="line">    @TableLogic(<span class="comment">/*value = &quot;1&quot;,delval = &quot;-1&quot;*/</span>) <span class="comment">//逻辑删除字段属性，可以使用注解属性</span></span><br><span class="line">    private Integer logicFlag;</span><br><span class="line">    <span class="comment">//省略get和set方法</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>2)在Spring配置文件ApplicationContext.xml进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义MybatisPlus的全局策略配置，在版本2.3以后就不用管了默认把数据库下划线变成驼峰就可以插入和主键策略问题--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;globalConfiguration&quot; class&#x3D;&quot;com.baomidou.mybatisplus.entity.GlobalConfiguration&quot;&gt;</span><br><span class="line">        &lt;!--注入逻辑删除--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;sqlInjector&quot; ref&#x3D;&quot;logicSqlInjector&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!--注入逻辑删除全局value配置，也可以在实体类上面进行配置--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;logicDeleteValue&quot; value&#x3D;&quot;-1&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;logicNotDeleteValue&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!--逻辑删除--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;logicSqlInjector&quot; class&#x3D;&quot;com.baomidou.mybatisplus.mapper.LogicSqlInjector&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>3)测试类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testLogicDelete</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.out.println(userMapper.deleteById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(userMapper.selectById(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所执行的SQL：UPDATE tbl_user SET logic_flag=-1 WHERE id=? </p><h1 id="九、公共字段自动填充"><a href="#九、公共字段自动填充" class="headerlink" title="九、公共字段自动填充"></a>九、公共字段自动填充</h1><h2 id="1-元数据处理器接口"><a href="#1-元数据处理器接口" class="headerlink" title="1.元数据处理器接口"></a>1.元数据处理器接口</h2><p>com.baomidou.mybatisplus.mapper.MetaObjectHandler<br>inserFill(MetaObject metaObject)<br>updateFill(MetaObject metaObject)<br><strong>metaobject:元对象</strong>，是Mybatis.提供的一个用于更加方便，更加优雅的访问对象的属性,给对象的属性设置值的一个对象.还会用于包装对象．支持对object 、Map、Collection等对象进行包装。本质上metaObjet获取对象的属性值或者是给对象的属性设置值，最终是要通过<strong>Reflector</strong>获取到属性的对应方法的<strong>Invoker</strong>，最终invoke。</p><h2 id="2-开发步骤"><a href="#2-开发步骤" class="headerlink" title="2.开发步骤"></a>2.开发步骤</h2><p>1)创建包MyMetaObjectHandler并创建类MyMetaObjectHandler继承MetaObjectHandler。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">extends</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">insertFill</span>(<span class="params">MetaObject metaObject</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//获取到需要被填充的字段的值</span></span><br><span class="line">        <span class="built_in">Object</span> fieldValue = getFieldValByName(<span class="string">&quot;name&quot;</span>, metaObject);</span><br><span class="line">        <span class="keyword">if</span> (fieldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;******************满足填充条件******************&quot;</span>);</span><br><span class="line">            setFieldValByName(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Kevin&quot;</span>, metaObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">updateFill</span>(<span class="params">MetaObject metaObject</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//获取到需要被填充的字段的值</span></span><br><span class="line">        <span class="built_in">Object</span> fieldValue = getFieldValByName(<span class="string">&quot;name&quot;</span>, metaObject);</span><br><span class="line">        <span class="keyword">if</span> (fieldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;******************满足填充条件******************&quot;</span>);</span><br><span class="line">            setFieldValByName(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>, metaObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)在Spring配置文件ApplicationContext.xml中进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;globalConfiguration&quot; class&#x3D;&quot;com.baomidou.mybatisplus.entity.GlobalConfiguration&quot;&gt;</span><br><span class="line">        &lt;!--注入公共字段填充处理器--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;metaObjectHandler&quot; ref&#x3D;&quot;myMetaObjectHandler&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!--公共字段填充处理器--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;myMetaObjectHandler&quot; class&#x3D;&quot;org.example.MyMetaObjectHandler.MyMetaObjectHandler&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>3)编写测试类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testMetaObjectHandler</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">//user.setName(&quot;lucy&quot;);//不定义名字，自动进行填充</span></span><br><span class="line">        user.setLogicFlag(<span class="number">1</span>);</span><br><span class="line">        user.setId(<span class="number">5</span>);</span><br><span class="line">        userMapper.updateById(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意一个问题</strong>：如果更新操作您本不想更新那个字段这儿也会给您默认进行填充，所以使用的时候需要进行注意这个问题。</p><h1 id="十、Oracle主键Sequence"><a href="#十、Oracle主键Sequence" class="headerlink" title="十、Oracle主键Sequence"></a>十、Oracle主键Sequence</h1><p>MySQL：支持主键自增。IdType.Auto<br>Oracle：序列（Sequence）<br>1)实体类配置主键Sequence    @KeySequence(value=”序列名”,class=xxx.class逐渐属性类型)<br>2)全局MP主键生成策略为idType.INPUT<br>3)全局mp中配置Oracle主键Sequence<br>com.baomidou.mybatisplus.incrementer.OracleKeyGenerator<br>4)可以将@keySequence定义在父类中,可实现多个子类对应的多个表公用一个Sequence</p><h1 id="十一、IDEA插件EasyCode使用"><a href="#十一、IDEA插件EasyCode使用" class="headerlink" title="十一、IDEA插件EasyCode使用"></a>十一、IDEA插件EasyCode使用</h1><p>1.安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击File&gt;Settinds&gt;Plugins然后在Plugins里搜索easycode点击Install安装插件</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210205213156343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2.搭建一个Maven的Web项目。生成之后需要手动创建在main下创Java目录并且创建包。这里创建包com.kevin（后面使用到）<br><img src="https://img-blog.csdnimg.cn/20210205213332141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.导入数据库<br><img src="https://img-blog.csdnimg.cn/20210205213632705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.配置数据库连接以及设置时区。<br><img src="https://img-blog.csdnimg.cn/20210205213735826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击Set time zone之后跳转到Advanced之后再点击回General<br><img src="https://img-blog.csdnimg.cn/20210205213852371.png" alt="在这里插入图片描述"><br>5.右键点击需要生成的数据库表<br><img src="https://img-blog.csdnimg.cn/20210205214050159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>6.选择所放置的包（com.java），确定路径正确之后一路点击yes就可以了<br><img src="https://img-blog.csdnimg.cn/20210205220542602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>7.完成之后结构图<br><img src="https://img-blog.csdnimg.cn/20210205220613453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
