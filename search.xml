<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Junit5笔记</title>
      <link href="2021/04/30/Junit5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/04/30/Junit5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Junit5常用测试注解"><a href="#一、Junit5常用测试注解" class="headerlink" title="一、Junit5常用测试注解"></a>一、Junit5常用测试注解</h1><h4 id="①-DisplayName：为测试类或者测试方法设置展示名称。"><a href="#①-DisplayName：为测试类或者测试方法设置展示名称。" class="headerlink" title="①.@DisplayName：为测试类或者测试方法设置展示名称。"></a>①.@DisplayName：为测试类或者测试方法设置展示名称。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;测试DisplayName注解&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testDisplayName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试DisplayName注解&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="②-BeforeEach-表示在每个单元测试之前执行"><a href="#②-BeforeEach-表示在每个单元测试之前执行" class="headerlink" title="②.@BeforeEach :表示在每个单元测试之前执行"></a>②.@BeforeEach :表示在每个单元测试之前执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testBeforeEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试就要开始啦……&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="③-AfterEach-表示在每个单元测试之后执行"><a href="#③-AfterEach-表示在每个单元测试之后执行" class="headerlink" title="③.@AfterEach :表示在每个单元测试之后执行"></a>③.@AfterEach :表示在每个单元测试之后执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAfterEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试就要结束啦……&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="④-BeforeAll-表示在所有单元测试之前执行"><a href="#④-BeforeAll-表示在所有单元测试之前执行" class="headerlink" title="④.@BeforeAll :表示在所有单元测试之前执行"></a>④.@BeforeAll :表示在所有单元测试之前执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBeforeAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有测试就要开始啦……&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑤-AfterAll-表示在所有单元测试之后执行"><a href="#⑤-AfterAll-表示在所有单元测试之后执行" class="headerlink" title="⑤.@AfterAll :表示在所有单元测试之后执行"></a>⑤.@AfterAll :表示在所有单元测试之后执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAfterAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有测试就要结束啦……&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑥-Disabled-表示测试类或测试方法不执行，类似于JUnit4中的-Ignore。"><a href="#⑥-Disabled-表示测试类或测试方法不执行，类似于JUnit4中的-Ignore。" class="headerlink" title="⑥.@Disabled :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore。"></a>⑥.@Disabled :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;测试方法二&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"><span class="comment">//    禁用注解</span></span><br><span class="line">    <span class="meta">@Disabled</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试方法二&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑦-Timeout-表示测试方法运行如果超过了指定时间将会返回错误"><a href="#⑦-Timeout-表示测试方法运行如果超过了指定时间将会返回错误" class="headerlink" title="⑦.@Timeout :表示测试方法运行如果超过了指定时间将会返回错误"></a>⑦.@Timeout :表示测试方法运行如果超过了指定时间将会返回错误</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Timeout(value = 1000,unit = TimeUnit.MILLISECONDS)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testTimeout</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1001</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑧-ExtendWith-为测试类或测试方法提供扩展类引用。类似于Junit4的-RunWith。"><a href="#⑧-ExtendWith-为测试类或测试方法提供扩展类引用。类似于Junit4的-RunWith。" class="headerlink" title="⑧.@ExtendWith :为测试类或测试方法提供扩展类引用。类似于Junit4的@RunWith。"></a>⑧.@ExtendWith :为测试类或测试方法提供扩展类引用。类似于Junit4的@RunWith。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BootstrapWith(SpringBootTestContextBootstrapper.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(&#123;SpringExtension.class&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="⑨-RepeatedTest-表示方法可重复执行，里面参数为重复多少次、"><a href="#⑨-RepeatedTest-表示方法可重复执行，里面参数为重复多少次、" class="headerlink" title="⑨.@RepeatedTest :表示方法可重复执行，里面参数为重复多少次、"></a>⑨.@RepeatedTest :表示方法可重复执行，里面参数为重复多少次、</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RepeatedTest(5)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试重复测试&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="二、断言机制"><a href="#二、断言机制" class="headerlink" title="二、断言机制"></a>二、断言机制</h1><p>断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。<strong>这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。</strong>JUnit 5 内置的断言可以分成如下几个类别：<br><strong>检查业务逻辑返回的数据是否合理。</strong><br>所有的测试运行结束以后，会有一个详细的测试报告；</p><h4 id="①-简单断言测试"><a href="#①-简单断言测试" class="headerlink" title="①.简单断言测试"></a>①.简单断言测试</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>assertEquals</td><td>判断两个对象或两个原始类型是否相等</td></tr><tr><td>assertNotEquals</td><td>判断两个对象或两个原始类型是否不相等</td></tr><tr><td>assertSame</td><td>判断两个对象引用是否指向同一个对象</td></tr><tr><td>assertNotSame</td><td>判断两个对象引用是否指向不同的对象</td></tr><tr><td>assertTrue</td><td>判断给定的布尔值是否为 true</td></tr><tr><td>assertFalse</td><td>判断给定的布尔值是否为 false</td></tr><tr><td>assertNull</td><td>判断给定的对象引用是否为 null</td></tr><tr><td>assertNotNull</td><td>判断给定的对象引用是否不为 null</td></tr><tr><td>断言如果前面方法失败了，后面就不会运行</td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;简单断言测试&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSimpleAssertions</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cal = cal(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">//        org.opentest4j.AssertionFailedError:</span></span><br><span class="line"><span class="comment">//        Expected :111</span></span><br><span class="line"><span class="comment">//        Actual   :11</span></span><br><span class="line">        assertEquals(<span class="number">11</span>,cal,<span class="string">&quot;业务逻辑计算失败&quot;</span>);</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">        assertNotSame(o1,o2);</span><br></pre></td></tr></table></figure><h4 id="②-数组断言"><a href="#②-数组断言" class="headerlink" title="②.数组断言"></a>②.数组断言</h4><p>通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;数组断言&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertArrayEquals(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="③-组合断言"><a href="#③-组合断言" class="headerlink" title="③.组合断言"></a>③.组合断言</h4><p>assertAll 方法接受多个org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;组合断言&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 断言需要全部成功才能够继续</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assertAll(<span class="string">&quot;Math&quot;</span>,</span><br><span class="line">                () -&gt; assertEquals(<span class="number">2</span>, <span class="number">1</span> + <span class="number">1</span>,<span class="string">&quot;结果不相等&quot;</span>),</span><br><span class="line">                () -&gt; assertTrue(<span class="number">1</span> &gt; <span class="number">0</span>,<span class="string">&quot;结果为假&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="④-异常断言"><a href="#④-异常断言" class="headerlink" title="④.异常断言"></a>④.异常断言</h4><p>在JUnit4时期，想要测试方法的异常情况时，需要用@Rule注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式Assertions.assertThrows() ,配合函数式编程就可以进行使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;异常测试&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertThrows(</span><br><span class="line">                <span class="comment">//扔出断言异常</span></span><br><span class="line">                ArithmeticException.class, () -&gt; System.out.println(<span class="number">1</span> % <span class="number">0</span>),</span><br><span class="line">                <span class="string">&quot;业务逻辑竟然正常运行&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑤-超时断言"><a href="#⑤-超时断言" class="headerlink" title="⑤.超时断言"></a>⑤.超时断言</h4><p>Junit5还提供了Assertions.assertTimeout() 为测试方法设置了超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;超时测试&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果测试方法时间超过1s将会异常</span></span><br><span class="line">        Assertions.assertTimeout(Duration.ofMillis(<span class="number">1000</span>), () -&gt; Thread.sleep(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑥-快速失败"><a href="#⑥-快速失败" class="headerlink" title="⑥.快速失败"></a>⑥.快速失败</h4><p>通过 fail 方法直接使得测试失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;快速失败&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fail(<span class="string">&quot;这应该失败&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="三、前置条件"><a href="#三、前置条件" class="headerlink" title="三、前置条件"></a>三、前置条件</h1><p>JUnit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于不满足的断言会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试前置条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;测试前置条件&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAssumptions</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Assumptions.assumeTrue(<span class="keyword">true</span>,<span class="string">&quot;结果不是True&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;数字&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。</p><h1 id="四、嵌套测试"><a href="#四、嵌套测试" class="headerlink" title="四、嵌套测试"></a>四、嵌套测试</h1><p>JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Kevin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021-03-23 20:38:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;嵌套测试&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestingAStackDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;is instantiated with new Stack()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isInstantiatedWithNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//嵌套测试情况下，外层的Test不能驱动内层的@Before(After)Each/All之类方法提前/之类运行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;when new&quot;)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WhenNew</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">createNewStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;新生成了一个Stack栈&quot;</span>);</span><br><span class="line">            stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;is empty&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when popped&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">throwsExceptionWhenPopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            assertThrows(EmptyStackException.class,stack::pop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when peeked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">throwsExceptionWhenPeeked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::peek);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nested</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;after pushing an element&quot;)</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AfterPushing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            String anElement = <span class="string">&quot;an element&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@BeforeEach</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">pushAnElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(stack.toString()+<span class="string">&quot;栈中防止一个元素：&quot;</span>+anElement.toString());</span><br><span class="line">                stack.push(anElement);</span><br><span class="line">                System.out.println(stack);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 内层的Test可以驱动外层的Before(After)Each/All的方法提前/之后运行</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;it is no longer empty&quot;)</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">isNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when popped and is empty&quot;)</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">returnElementWhenPopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                assertEquals(anElement, stack.pop());</span><br><span class="line">                assertTrue(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when peeked but remains not empty&quot;)</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">returnElementWhenPeeked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                assertEquals(anElement, stack.peek());</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="五、参数化测试"><a href="#五、参数化测试" class="headerlink" title="五、参数化测试"></a>五、参数化测试</h1><p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。<br>利用@ValueSource等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。<br>@ValueSource: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型<br>@NullSource: 表示为参数化测试提供一个null的入参<br>@EnumSource: 表示为参数化测试提供一个枚举入参<br>@CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参<br>@MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)<br>当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现ArgumentsProvider接口，任何外部文件都可以作为它的入参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line">    <span class="meta">@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;参数化测试1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterizedTest1</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">        Assertions.assertTrue(StringUtils.isNotBlank(string));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ParameterizedTest</span></span><br><span class="line">    <span class="meta">@MethodSource(&quot;method&quot;)</span>    <span class="comment">//指定方法名（方法必须是静态的而且需要返回一个Stream类型）</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;方法来源参数&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWithExplicitLocalMethodSource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        Assertions.assertNotNull(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>来源（尚硅谷SpringBoot教程）：<a href="https://www.yuque.com/atguigu/springboot">https://www.yuque.com/atguigu/springboot</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hystrix断路器</title>
      <link href="2021/04/30/Hystrix%E6%96%AD%E8%B7%AF%E5%99%A8/"/>
      <url>2021/04/30/Hystrix%E6%96%AD%E8%B7%AF%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="1-1、Hystrix是什么？"><a href="#1-1、Hystrix是什么？" class="headerlink" title="1.1、Hystrix是什么？"></a>1.1、Hystrix是什么？</h2><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</p><p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。<br><strong>Hystrix官网</strong>地址：<a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">https://github.com/Netflix/Hystrix/wiki/How-To-Use</a></p><h2 id="1-2、Hystrix重要概念"><a href="#1-2、Hystrix重要概念" class="headerlink" title="1.2、Hystrix重要概念"></a>1.2、Hystrix重要概念</h2><h3 id="1-2-1、服务降级"><a href="#1-2-1、服务降级" class="headerlink" title="1.2.1、服务降级"></a>1.2.1、服务降级</h3><p>服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback<br><strong>哪些情况会出现限流</strong>？<br>程序运行异常、超时、服务熔断触发服务降级、线程池/信号量打满也会导致服务降级</p><h3 id="1-2-1、服务熔断"><a href="#1-2-1、服务熔断" class="headerlink" title="1.2.1、服务熔断"></a>1.2.1、服务熔断</h3><p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。<br>通俗的说就是保险丝====服务的降级-&gt;进而熔断-&gt;恢复调用链路</p><h3 id="1-2-1、服务限流"><a href="#1-2-1、服务限流" class="headerlink" title="1.2.1、服务限流"></a>1.2.1、服务限流</h3><p><strong>秒杀高并发</strong>等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p><h1 id="2、Hystrix使用"><a href="#2、Hystrix使用" class="headerlink" title="2、Hystrix使用"></a>2、Hystrix使用</h1><h2 id="2-1、服务降级"><a href="#2-1、服务降级" class="headerlink" title="2.1、服务降级"></a>2.1、服务降级</h2><h3 id="2-1-1、构建服务端"><a href="#2-1-1、构建服务端" class="headerlink" title="2.1.1、构建服务端"></a>2.1.1、构建服务端</h3><p><strong>引入依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--hystrix--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>yml配置文件注册进Eureka服务发现中心</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    fetch-registry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka</span><br></pre></td></tr></table></figure><p><strong>业务方法service层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_OK</span>(<span class="params">Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程是：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;    paymentInfo_OK   &quot;</span> + id + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;嘻嘻&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">@HystrixCommand(fallbackMethod = <span class="string">&quot;paymentInfo_TimeOutHandler&quot;</span>, commandProperties = &#123;</span><br><span class="line">            @HystrixProperty(name = <span class="string">&quot;execution.isolation.thread.timeoutInMilliseconds&quot;</span>, value = <span class="string">&quot;3000&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_TimeOut</span>(<span class="params">Integer id</span>)</span> &#123;</span><br><span class="line">        int timeNum = <span class="number">4000</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(timeNum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程是：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;    paymentInfo_TimeOut   &quot;</span> + id + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 嘻嘻&quot;</span> + <span class="string">&quot;    耗时&quot;</span> + timeNum / <span class="number">1000</span> + <span class="string">&quot;秒钟&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_TimeOutHandler</span>(<span class="params">Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程是：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;    paymentInfo_TimeOutHandler   &quot;</span> + id + <span class="string">&quot;\t，8001运行报错或超时请稍后再试&quot;</span> + <span class="string">&quot; ┭┮﹏┭┮&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>业务方法Controller层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">  private PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">  @Value(<span class="string">&quot;$&#123;server.port&#125;&quot;</span>)</span><br><span class="line">  private <span class="built_in">String</span> serverPort;</span><br><span class="line"></span><br><span class="line">  @GetMapping(<span class="string">&quot;/payment/hystrix/ok/&#123;id&#125;&quot;</span>)</span><br><span class="line">  public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_OK</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">String</span> s = paymentService.paymentInfo_OK(id);</span><br><span class="line">      log.info(<span class="string">&quot;========结果：&quot;</span> + s);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @GetMapping(<span class="string">&quot;/payment/hystrix/timeOut/&#123;id&#125;&quot;</span>)</span><br><span class="line">  public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_TimeOut</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">String</span> s = paymentService.paymentInfo_TimeOut(id);</span><br><span class="line">      log.info(<span class="string">&quot;========结果：&quot;</span> + s);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>启动主类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-2、构建客户端"><a href="#2-2-2、构建客户端" class="headerlink" title="2.2.2、构建客户端"></a>2.2.2、构建客户端</h2><p><strong>引入依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--hystrix--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>yml配置文件注册进Eureka服务发现中心</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;</span><br><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure><p><strong>业务方法service层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@FeignClient(value = <span class="string">&quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;</span>)</span><br><span class="line">public interface PaymentHystrixService &#123;</span><br><span class="line">    @GetMapping(<span class="string">&quot;/payment/hystrix/ok/&#123;id&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">String</span> paymentInfo_OK(@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id);</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">String</span> paymentInfo_TimeOut(@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>业务方法Controller层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">  private PaymentHystrixService paymentHystrixService;</span><br><span class="line"></span><br><span class="line">  @GetMapping(<span class="string">&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;</span>)</span><br><span class="line">  public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_OK</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">String</span> result = paymentHystrixService.paymentInfo_OK(id);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  @GetMapping(<span class="string">&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;</span>)</span><br><span class="line">  @HystrixCommand(fallbackMethod = <span class="string">&quot;paymentInfo_TimeOutHandler&quot;</span>, commandProperties = &#123;</span><br><span class="line">          @HystrixProperty(name = <span class="string">&quot;execution.isolation.thread.timeoutInMilliseconds&quot;</span>, value = <span class="string">&quot;4000&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//@HystrixCommand //加了@DefaultProperties属性注解，并且没有写具体方法名字，就用统一全局的</span></span><br><span class="line">  public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_TimeOut</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">String</span> result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>启动主类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixMain80</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderHystrixMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-3、测试"><a href="#2-2-3、测试" class="headerlink" title="2.2.3、测试"></a>2.2.3、测试</h2><p>微服务启动注册进入Eureka中，只要超过@HystrixCommand-&gt;@HystrixProperty注解中参数的3秒钟就会自动跳转到服务降级方法paymentInfo_TimeOutHandler中去。</p><h2 id="2-3、以上服务降级所存在的问题"><a href="#2-3、以上服务降级所存在的问题" class="headerlink" title="2.3、以上服务降级所存在的问题"></a>2.3、以上服务降级所存在的问题</h2><h3 id="2-3-1、代码膨胀"><a href="#2-3-1、代码膨胀" class="headerlink" title="2.3.1、代码膨胀"></a>2.3.1、代码膨胀</h3><p>问题存在于1：1 每个方法配置一个服务降级方法，技术上可以，实际上代码冗余。1：N 除了个别重要核心业务有专属，其它普通的可以通过@DefaultProperties(defaultFallback = “”)  统一跳转到统一处理结果页面。<br><strong>解决问题</strong><br>只需要在类名上写一个默认的降级方法，之后并在类中写一个全局的服务降级方法，再在需要服务降级方法上标注@HystrixCommand无需其它参数即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@DefaultProperties(defaultFallback = <span class="string">&quot;payment_Global_FallbackMethod&quot;</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixController</span> </span>&#123;</span><br><span class="line">@HystrixCommand <span class="comment">//加了@DefaultProperties属性注解，并且没有写具体方法名字，就用统一全局的</span></span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_TimeOut</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">String</span> result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//全局fallbackMethod</span></span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">payment_Global_FallbackMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2、逻辑混乱"><a href="#2-3-2、逻辑混乱" class="headerlink" title="2.3.2、逻辑混乱"></a>2.3.2、逻辑混乱</h3><p>每个Controller都要写一个服务降级方法，这样与业务逻辑是否混乱，所以与OpenFeign接口处做文章。<br><strong>实现客户端Service接口层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="title">implements</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_OK</span>(<span class="params">Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-------------paymentInfo_OK fall back,┭┮﹏┭┮&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo_TimeOut</span>(<span class="params">Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-------------paymentInfo_TimeOut fall back,┭┮﹏┭┮&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改造Service接口，添加fallback服务降级方法指向所实现的接口</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@FeignClient(value = <span class="string">&quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;</span>, fallback = PaymentFallbackService.class)</span><br><span class="line">public interface PaymentHystrixService &#123;</span><br><span class="line">    @GetMapping(<span class="string">&quot;/payment/hystrix/ok/&#123;id&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">String</span> paymentInfo_OK(@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id);</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">String</span> paymentInfo_TimeOut(@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong><br>这样接口的所有方法都会有服务降级的效果，实现代码冗余的难题。</p><h2 id="2-2、服务熔断"><a href="#2-2、服务熔断" class="headerlink" title="2.2、服务熔断"></a>2.2、服务熔断</h2><p>大神论文：<a href="https://martinfowler.com/bliki/CircuitBreaker.html">https://martinfowler.com/bliki/CircuitBreaker.html</a><br><strong>修改服务端Service层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod = <span class="string">&quot;paymentCircuitBreaker_fallback&quot;</span>, commandProperties = &#123;</span><br><span class="line">            @HystrixProperty(name = <span class="string">&quot;circuitBreaker.enabled&quot;</span>, value = <span class="string">&quot;true&quot;</span>),<span class="comment">//是否开启断路熔断器</span></span><br><span class="line">            @HystrixProperty(name = <span class="string">&quot;circuitBreaker.requestVolumeThreshold&quot;</span>, value = <span class="string">&quot;10&quot;</span>),<span class="comment">//请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。</span></span><br><span class="line">            @HystrixProperty(name = <span class="string">&quot;circuitBreaker.sleepWindowInMilliseconds&quot;</span>, value = <span class="string">&quot;10000&quot;</span>),<span class="comment">//快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</span></span><br><span class="line">            @HystrixProperty(name = <span class="string">&quot;circuitBreaker.errorThresholdPercentage&quot;</span>, value = <span class="string">&quot;60&quot;</span>),<span class="comment">//错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</span></span><br><span class="line">    &#125;)</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">paymentCircuitBreaker</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;******id 不能负数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">String</span> serialNumber = IdUtil.simpleUUID();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;调用成功，流水号: &quot;</span> + serialNumber;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>修改服务端Controller层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/payment/circuit/&#123;id&#125;&quot;</span>)</span><br><span class="line">public <span class="built_in">String</span> paymentCircuitBreaker(@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">String</span> result = paymentService.paymentCircuitBreaker(id);</span><br><span class="line">    log.info(<span class="string">&quot;****result: &quot;</span>+result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到断路器的三个重要参数：快照时间窗、请求总数阀值、错误百分比阀值。<br>1：快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</p><p>2：请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。</p><p>3：错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</p><p><strong>熔断器打开之后</strong><br>1：再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。</p><p>2：原来的主逻辑要如何恢复呢？<br>对于这一问题，hystrix也为我们实现了自动恢复功能。<br>当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，<br>当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，<br>主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。</p><h2 id="2-3、服务监控hystrixDashboard"><a href="#2-3、服务监控hystrixDashboard" class="headerlink" title="2.3、服务监控hystrixDashboard"></a>2.3、服务监控hystrixDashboard</h2><h3 id="2-3-1、概述"><a href="#2-3-1、概述" class="headerlink" title="2.3.1、概述"></a>2.3.1、概述</h3><p>除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控（Hystrix Dashboard），Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。</p><h3 id="2-3-2、搭建过程"><a href="#2-3-2、搭建过程" class="headerlink" title="2.3.2、搭建过程"></a>2.3.2、搭建过程</h3><p><strong>pom依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>主类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableHystrixDashboard</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardMain9001</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(MainApp9001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所监控的类都需要添加此依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- actuator监控信息完善 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>还需要在被监控的主类中加入此组件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑</span></span><br><span class="line"><span class="comment"> *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，</span></span><br><span class="line"><span class="comment"> *只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Bean</span><br><span class="line">public ServletRegistrationBean <span class="function"><span class="title">getServlet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">    ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">    registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">    registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="http://localhost:9001/hystrix">http://localhost:9001/hystrix</a></strong><br>输入<a href="http://localhost:8001/hystrix.stream%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%AF%B9%E5%BA%94%E7%9B%91%E6%8E%A7%E3%80%82">http://localhost:8001/hystrix.stream就可以进行对应监控。</a></p><h1 id="3、学习地址"><a href="#3、学习地址" class="headerlink" title="3、学习地址"></a>3、学习地址</h1><p>来源：尚硅谷哔哩哔哩学习地址：<a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Alibaba Nacos</title>
      <link href="2021/04/30/SpringCloud%20Alibaba%20Nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
      <url>2021/04/30/SpringCloud%20Alibaba%20Nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Nacos概述"><a href="#1、Nacos概述" class="headerlink" title="1、Nacos概述"></a>1、Nacos概述</h1><h2 id="1-1、基本介绍"><a href="#1-1、基本介绍" class="headerlink" title="1.1、基本介绍"></a>1.1、基本介绍</h2><p>Nacos：Naming+Configuration的前两个字母，S代表Service。一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。<br>Nacos就是<strong>注册中心 + 配置中心</strong>的<strong>组合</strong>：Nacos = Eureka+Config +Bus<br>GitHub地址：<a href="https://github.com/alibaba/Nacos">https://github.com/alibaba/Nacos</a><br>中文文档：<a href="https://nacos.io/zh-cn/index.html">https://nacos.io/zh-cn/index.html</a></p><h2 id="1-2、与其它服务中心对比"><a href="#1-2、与其它服务中心对比" class="headerlink" title="1.2、与其它服务中心对比"></a>1.2、与其它服务中心对比</h2><p>Nacos支持<strong>AP与CP</strong>之间的<strong>切换</strong><br><img src="https://img-blog.csdnimg.cn/20210415163502543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="与其它服务中心对比"><br>C是所有节点在<strong>同一时间看到的数据是一致的</strong>；而A的定义是<strong>所有的请求都会收到响应</strong>。<br>何时选择使用何种模式？<br>一般来说，如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如 Spring cloud 和 Dubbo 服务，都适用于AP模式，AP模式为了服务的可能性而减弱了一致性，因此AP模式下只支持注册临时实例。</p><p>如果需要在服务级别编辑或者存储配置信息，那么 CP 是必须，K8S服务和DNS服务则适用于CP模式。<br>CP模式下则支持注册持久化实例，此时则是以 Raft 协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。</p><p>curl -X PUT ‘$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP’</p><h2 id="1-3、安装并运行Nacos"><a href="#1-3、安装并运行Nacos" class="headerlink" title="1.3、安装并运行Nacos"></a>1.3、安装并运行Nacos</h2><p><strong>Windows版本</strong><br>1、下载Nacos地址：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a><br>2、解压到指定文件夹，进入bin目录下直接点击startup.cmd运行。<br>3、访问：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a><br>4、账号和密码都是nacos登录页面即可登录成功</p><h1 id="2、Nacos服务注册中心"><a href="#2、Nacos服务注册中心" class="headerlink" title="2、Nacos服务注册中心"></a>2、Nacos服务注册中心</h1><h2 id="2-1、基于Nacos的服务提供者"><a href="#2-1、基于Nacos的服务提供者" class="headerlink" title="2.1、基于Nacos的服务提供者"></a>2.1、基于Nacos的服务提供者</h2><p>1、微服务父Pom添加依赖spring-cloud-alibaba-dependencies，子Pom添加spring-cloud-starter-alibaba-nacos-discovery依赖。（后面不做介绍）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、Yaml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-payment-provider</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 #配置Nacos地址</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;*&#39; #暴露所有web监控端点</span><br></pre></td></tr></table></figure><p>3、主启动类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain9001</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">            SpringApplication.run(PaymentMain9001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、业务类（返回该微服务的端口号）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    @Value(<span class="string">&quot;$&#123;server.port&#125;&quot;</span>)</span><br><span class="line">    private <span class="built_in">String</span> serverPort;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/payment/nacos/&#123;id&#125;&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">getPayment</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Nacos 注册中心,，端口号: &quot;</span> + serverPort + <span class="string">&quot;\t id=&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、测试<br>可以在Nacos-服务管理-服务列表控制台看到注册进来的微服务名称<br>再浏览器中输入<a href="http://localhost:9001/payment/nacos/123">http://localhost:9001/payment/nacos/123</a>可以访问到端口号加上id。<br>6、负载均衡前期准备<br>再依照9001端口创建9002微服务，加依赖，改Yaml，写主类/业务类。<br>如果想省事可以直接拷贝虚拟端口映射：①.再已运行的9001右击-Copy Configuration。②.更改配置名，并添加VM options：-Dserver port-9011。可以开启以9011端口的微服务。</p><h2 id="2-2、基于Nacos的服务消费者"><a href="#2-2、基于Nacos的服务消费者" class="headerlink" title="2.2、基于Nacos的服务消费者"></a>2.2、基于Nacos的服务消费者</h2><p>为什么Nacos自动支持负载均衡<br>因为Nacos在引入已经自动集成了Ribbon，所以自带负载均衡功能。<br>1、添加依赖spring-cloud-starter-alibaba-nacos-discovery。<br>2、修改Yaml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 83</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-order-consumer</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848</span><br><span class="line"></span><br><span class="line">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span><br><span class="line">service-url:</span><br><span class="line">  nacos-user-service: http:&#x2F;&#x2F;nacos-payment-provider </span><br></pre></td></tr></table></figure><p>3、主启动类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosMain83</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(OrderNacosMain83.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>4、注册RestTemplate用于调用服务类（配置类）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextBean</span> </span>&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    public RestTemplate <span class="function"><span class="title">restTemplate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、业务类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">&quot;$&#123;service-url.nacos-user-service&#125;&quot;</span>)</span><br><span class="line">    private <span class="built_in">String</span> serverURL;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/consumer/payment/nacos/&#123;id&#125;&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">paymentInfo</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Integer id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(serverURL + <span class="string">&quot;/payment/nacos/&quot;</span> + id, <span class="built_in">String</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、测试<br>可以在Nacos控制台看到已经注册的两个微服务提供者与一个微服务消费者<br>通过访问：<a href="http://localhost:83/consumer/payment/nacos/123">http://localhost:83/consumer/payment/nacos/123</a><br>可以发现获得的端口号是9001和9002交替出现，所以证明Nacos自动实现轮询负载均衡功能，既可以自动更改Ribbon的负载均衡的算法。</p><h1 id="3、Nacos作为配置中心（基础配置）"><a href="#3、Nacos作为配置中心（基础配置）" class="headerlink" title="3、Nacos作为配置中心（基础配置）"></a>3、Nacos作为配置中心（基础配置）</h1><h2 id="3-1、Nacos中的匹配规则"><a href="#3-1、Nacos中的匹配规则" class="headerlink" title="3.1、Nacos中的匹配规则"></a>3.1、Nacos中的匹配规则</h2><p>配置规则官网：<a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#公式：</span><br><span class="line">$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br></pre></td></tr></table></figure><p>简单来说：<br>①、prefix 默认为 spring.application.name （应用名）的值<br>②、spring.profile.active 即为当前环境对应的 profile，可以通过配置项 spring.profile.active 来配置。<br>③、file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置<br><img src="https://img-blog.csdnimg.cn/20210415165339856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="公式"></p><h2 id="3-2、微服务拉取配置"><a href="#3-2、微服务拉取配置" class="headerlink" title="3.2、微服务拉取配置"></a>3.2、微服务拉取配置</h2><p>1、添加spring-cloud-starter-alibaba-nacos-config依赖<br><strong>为什么两个配置？</strong><br>Nacos同springcloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取，<br>拉取配置之后，才能保证项目的正常启动。<br>springboot中配置文件加载存在优先级顺序的，bootstrap优先级高于application</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、创建两个配置文件bootstrap与application<br><strong>bootstrap</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># nacos配置</span><br><span class="line">server:</span><br><span class="line">  port: 3377</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-config-client</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 #Nacos服务注册中心地址</span><br><span class="line">      config:</span><br><span class="line">        server-addr: localhost:8848 #Nacos作为配置中心地址</span><br><span class="line">        file-extension: yaml #指定yaml格式的配置</span><br></pre></td></tr></table></figure><p><strong>application</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev # 表示开发环境</span><br></pre></td></tr></table></figure><p>3、主启动类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NacosConfigClientMain3377</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">            SpringApplication.run(NacosConfigClientMain3377.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、业务类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RefreshScope <span class="comment">//在控制器类加入@RefreshScope注解使当前类下的配置支持Nacos的动态刷新功能。</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    @Value(<span class="string">&quot;$&#123;config.info&#125;&quot;</span>)</span><br><span class="line">    private <span class="built_in">String</span> configInfo;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/config/info&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">getConfigInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、测试<br>启动前需要在nacos客户端-配置管理-配置管理栏目下有对应的yaml配置文件，访问：<a href="http://localhost:3377/config/info">http://localhost:3377/config/info</a><br>6、自带动态刷新<br>修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新。</p><h2 id="3-3、Nacos作为配置中心（分类配置）"><a href="#3-3、Nacos作为配置中心（分类配置）" class="headerlink" title="3.3、Nacos作为配置中心（分类配置）"></a>3.3、Nacos作为配置中心（分类配置）</h2><p>1、DataID方案<br>通过修改application.yml配置文件中的profile环境实现yaml的切换<br>2、Group方案<br>通过修改bootstrap.yml配置文件中的spring.cloud.nacos.config.group=组名即可修改组<br>3、Namespace方案<br>通过修改bootstrap.yml配置文件中的spring.cloud.nacos.config.namespace=空间ID即可修命名空间</p><h1 id="4、Nacos集群和持久化配置"><a href="#4、Nacos集群和持久化配置" class="headerlink" title="4、Nacos集群和持久化配置"></a>4、Nacos集群和持久化配置</h1><h2 id="4-1、概述"><a href="#4-1、概述" class="headerlink" title="4.1、概述"></a>4.1、概述</h2><p>官方说明：<a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a><br>我们采用Nginx集群+Nacos集群+MySQL集群进行搭建高可用<br><img src="https://img-blog.csdnimg.cn/20210415171158422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="集群"></p><h2 id="4-2、Nacos持久化配置"><a href="#4-2、Nacos持久化配置" class="headerlink" title="4.2、Nacos持久化配置"></a>4.2、Nacos持久化配置</h2><p>Nacos默认使用自带的数据库derby进行持久化，可以在源代码看到引入了derby数据库的依赖。<br><strong>Windows版如何从derby切换到mysql</strong><br>1、nacos\conf目录下找到sql脚本：nacos-mysql.sql。在MySQL创建库nacos_config;<br>并执行nacos-mysql.sql中的脚本创建表。<br>2、nacos\conf目录下找到application.properties添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform&#x3D;mysql</span><br><span class="line"> </span><br><span class="line">db.num&#x3D;1</span><br><span class="line">db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;nacos_config?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true</span><br><span class="line">db.user&#x3D;数据库账号</span><br><span class="line">db.password&#x3D;数据库密码</span><br></pre></td></tr></table></figure><p>3、重新启动Nacos可以看到没有记录了，重新创建一个配置文件可以在数据库中看到里面有记录证明修改成功。</p><h2 id="4-3、Linux版Nginx-Nacos-MySQL配置高可用"><a href="#4-3、Linux版Nginx-Nacos-MySQL配置高可用" class="headerlink" title="4.3、Linux版Nginx+Nacos+MySQL配置高可用"></a>4.3、Linux版Nginx+Nacos+MySQL配置高可用</h2><p>1、下载Linux版本Nacos，并使用tar -zxvf进行解压到Linux服务器中<br>2、下载Linux版本MySQL版本&gt;5.6.5以上。并使用mysql -uroot -proot，-u后面是用户名，-p后面是密码。创建数据库nacos_config并执行nacos\conf目录下的sql脚本：nacos-mysql.sql。nacos\conf目录下找到application.properties添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform&#x3D;mysql</span><br><span class="line"> </span><br><span class="line">db.num&#x3D;1</span><br><span class="line">db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;nacos_config?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true</span><br><span class="line">db.user&#x3D;数据库账号</span><br><span class="line">db.password&#x3D;数据库密码</span><br></pre></td></tr></table></figure><p>3、Linux服务器上nacos的集群配置cluster.conf，nacos/conf/cluster.conf修改为ip:端口号。需要使用：hostname -i命令Linux识别的ip地址不能是127.0.0.1。<br>4、编辑Nacos的启动脚本startup.sh，使它能够接受不同的启动端口<br>/mynacos/nacos/bin 的startup.sh（<strong>新版本不用修改</strong>）<br><img src="https://img-blog.csdnimg.cn/20210415172539730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="修改Start.sh命令"><br>5、在bin目录下使用./startup.sh -p 三个端口号开启服务<br>6、Nginx的配置，由它作为负载均衡器<br>编辑/usr/local/nginx/conf下的nginx.conf文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream cluster&#123;</span><br><span class="line">        server 127.0.0.1:3333;</span><br><span class="line">        server 127.0.0.1:4444;</span><br><span class="line">        server 127.0.0.1:5555;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       1111;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            #root   html;</span><br><span class="line">            #index  index.html index.htm;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;cluster;</span><br><span class="line">        &#125;</span><br><span class="line">        后面省略</span><br></pre></td></tr></table></figure><p>7、测试通过nginx访问nacos：<a href="http://192.168.174.145:1111/nacos">http://192.168.174.145:1111/nacos</a>如果能够成功访问到并添加一个配置文件能够在mysql的表中发现增加记录证明集群搭建完毕。<br>8、通过服务端访问Nacos集群：修改yaml配置文件spring.cloud.nacos.discover.server-addr=192.168.174.145:1111，如果能够在Nacos看到服务注册进入那么集群搭建成功。</p><h1 id="5、学习地址"><a href="#5、学习地址" class="headerlink" title="5、学习地址"></a>5、学习地址</h1><p>来源：哔哩哔哩尚硅谷：<a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Stream消息驱动</title>
      <link href="2021/04/30/SpringCloud%20Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/04/30/SpringCloud%20Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="1-1、是什么"><a href="#1-1、是什么" class="headerlink" title="1.1、是什么"></a>1.1、是什么</h2><p>官方定义 Spring Cloud Stream 是一个构建消息驱动微服务的框架。<br>应用程序通过 inputs 或者 outputs 来与 Spring Cloud Stream中binder对象交互。<br>通过我们配置来binding(绑定) ，而 Spring Cloud Stream 的 binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与 Spring Cloud Stream 交互就可以方便使用消息驱动的方式。</p><p>通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。<br>Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。</p><p>目前仅支持RabbitMQ、Kafka。<br>Spring官网：<a href="https://spring.io/projects/spring-cloud-stream#overview">https://spring.io/projects/spring-cloud-stream#overview</a><br>Stream中文手册：<a href="https://m.wang1314.com/doc/webapp/topic/20971999.html">https://m.wang1314.com/doc/webapp/topic/20971999.html</a></p><h2 id="1-2、设计思想"><a href="#1-2、设计思想" class="headerlink" title="1.2、设计思想"></a>1.2、设计思想</h2><p>通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。<img src="https://img-blog.csdnimg.cn/20210412195127763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="处理架构"><br>Binder可以生成Binding，Binding用来绑定消息容器的生产者和消费者，它有两种类型，INPUT和OUTPUT，INPUT对应于消费者，OUTPUT对应于生产者。<br>Stream中的消息通信方式遵循了发布-订阅模式，Topic主题进行广播，在RabbitMQ就是Exchange，在Kakfa中就是Topic。</p><h2 id="1-3、标准流程套路"><a href="#1-3、标准流程套路" class="headerlink" title="1.3、标准流程套路"></a>1.3、标准流程套路</h2><p><strong>Binder</strong>：很方便的连接中间件，屏蔽差异。<br><strong>Channel</strong>：通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置。<br><strong>Source</strong>和<strong>Sink</strong>：简单的可理解为参照对象是Spring Cloud Stream自身，<br>从Stream发布消息就是输出，接受消息就是输入。<br><strong>常用API和注解</strong><img src="https://img-blog.csdnimg.cn/2021041219541621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="2、构建"><a href="#2、构建" class="headerlink" title="2、构建"></a>2、构建</h1><h2 id="2-1、消息驱动的生产者"><a href="#2-1、消息驱动的生产者" class="headerlink" title="2.1、消息驱动的生产者"></a>2.1、消息驱动的生产者</h2><p><strong>添加依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-stream-provider</span><br><span class="line">  cloud:</span><br><span class="line">      stream:</span><br><span class="line">        binders: # 在此处配置要绑定的rabbitmq的服务信息；</span><br><span class="line">          defaultRabbit: # 表示定义的名称，用于于binding整合</span><br><span class="line">            type: rabbit # 消息组件类型</span><br><span class="line">            environment: # 设置rabbitmq的相关的环境配置</span><br><span class="line">              spring:</span><br><span class="line">                rabbitmq:</span><br><span class="line">                  host: localhost</span><br><span class="line">                  port: 5672</span><br><span class="line">                  username: guest</span><br><span class="line">                  password: guest</span><br><span class="line">        bindings: # 服务的整合处理</span><br><span class="line">          output: # 这个名字是一个通道的名称</span><br><span class="line">            destination: studyExchange # 表示要使用的Exchange名称定义</span><br><span class="line">            content-type: application&#x2F;json # 设置消息类型，本次为json，文本则设置“text&#x2F;plain”</span><br><span class="line">            binder: defaultRabbit # 设置要绑定的消息服务的具体设置</span><br></pre></td></tr></table></figure><p><strong>主运行类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StreamMQMain8801</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(StreamMQMain8801.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>发送消息的接口</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IMessageProvider</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="built_in">String</span> send() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@EnableBinding(Source.class)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">IMessageProviderImpl</span> <span class="title">implements</span> <span class="title">IMessageProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private MessageChannel output;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">sendMessage</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">String</span> serial = UUID.randomUUID().toString();</span><br><span class="line">        boolean send = output.send(MessageBuilder.withPayload(serial).build());</span><br><span class="line">        System.out.println(<span class="string">&quot;******serial******: &quot;</span> + serial);</span><br><span class="line">        <span class="keyword">if</span> (send) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;发送成功：&quot;</span>+serial;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;发送失败：&quot;</span>+serial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Controller控制层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private IMessageProvider messageProvider;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = <span class="string">&quot;/sendMessage&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> sendMessage()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> messageProvider.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:8801/sendMessage%E5%8F%AF%E4%BB%A5%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%EF%BC%8C%E5%9C%A8RabbitMQ%E4%B8%8A%E9%9D%A2%E7%9C%8B%E8%A7%81%E6%98%8E%E6%98%BE%E7%9A%84%E6%B6%88%E6%81%AF%E6%B3%A2%E5%8A%A8%E5%B3%B0">http://localhost:8801/sendMessage可以发送消息，在RabbitMQ上面看见明显的消息波动峰</a></p><h2 id="2-2、消息驱动的消费者"><a href="#2-2、消息驱动的消费者" class="headerlink" title="2.2、消息驱动的消费者"></a>2.2、消息驱动的消费者</h2><p><strong>添加依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-stream-consumer</span><br><span class="line">  cloud:</span><br><span class="line">      stream:</span><br><span class="line">        binders: # 在此处配置要绑定的rabbitmq的服务信息；</span><br><span class="line">          defaultRabbit: # 表示定义的名称，用于于binding整合</span><br><span class="line">            type: rabbit # 消息组件类型</span><br><span class="line">            environment: # 设置rabbitmq的相关的环境配置</span><br><span class="line">              spring:</span><br><span class="line">                rabbitmq:</span><br><span class="line">                  host: localhost</span><br><span class="line">                  port: 5672</span><br><span class="line">                  username: guest</span><br><span class="line">                  password: guest</span><br><span class="line">        bindings: # 服务的整合处理</span><br><span class="line">          input: # 这个名字是一个通道的名称</span><br><span class="line">            destination: studyExchange # 表示要使用的Exchange名称定义</span><br><span class="line">            content-type: application&#x2F;json # 设置消息类型，本次为对象json，如果是文本则设置“text&#x2F;plain”</span><br><span class="line">            binder: defaultRabbit # 设置要绑定的消息服务的具体设置</span><br></pre></td></tr></table></figure><p><strong>主运行类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StreamMQMain8802</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(StreamMQMain8802.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Controller控制层</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@EnableBinding(Sink.class)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ReceiveMessageListener</span> </span>&#123;</span><br><span class="line">    @Value(<span class="string">&quot;$&#123;server.port&#125;&quot;</span>)</span><br><span class="line">    private <span class="built_in">String</span> serverPort;</span><br><span class="line"></span><br><span class="line">    @StreamListener(Sink.INPUT)</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">input</span>(<span class="params">Message&lt;<span class="built_in">String</span>&gt; message</span>)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所接收到的消息为======&quot;</span> + message.getPayload() + <span class="string">&quot;\t    &quot;</span> + <span class="string">&quot;端口号&quot;</span> + serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：<a href="http://localhost:8801/sendMessage%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%9C%A88802%E7%AB%AF%E5%8F%A3%E5%8F%AF%E4%BB%A5%E6%8E%A5%E6%94%B6%E5%88%B0%E6%B6%88%E6%81%AF%EF%BC%8C%E9%81%BF%E5%85%8D%E4%BA%86%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%8C%E7%B1%BB%E4%BC%BC%E4%BA%8E%E4%B8%80%E4%B8%AATemplate%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%E3%80%82">http://localhost:8801/sendMessage发送信息，在8802端口可以接收到消息，避免了中间件的不同，类似于一个Template可以进行发送和接收消息。</a></p><h1 id="3、Stream的分组消费与持久化"><a href="#3、Stream的分组消费与持久化" class="headerlink" title="3、Stream的分组消费与持久化"></a>3、Stream的分组消费与持久化</h1><h2 id="3-1、分组消费"><a href="#3-1、分组消费" class="headerlink" title="3.1、分组消费"></a>3.1、分组消费</h2><p><strong>再次构建一个8803端口与8802类似，步骤省略</strong><br>可以发现，如果生产者发送一条消息，两个消费者会同时消费一条消息，因为他们会自动生成一个流水号将他们划分到不同组，所以这里我们需要使用配置方法将其配置到同一个组去避免重复消费。<br><strong>yml配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    stream:</span><br><span class="line">      bindings: </span><br><span class="line">        input: </span><br><span class="line">          group: 组名</span><br></pre></td></tr></table></figure><p>这样就将其创建到同一个组去，再次发送消息，一条消息只会被一个消费端消费，不会重复消费</p><h2 id="3-2、持久化"><a href="#3-2、持久化" class="headerlink" title="3.2、持久化"></a>3.2、持久化</h2><p>Stream默认开启持久化，即使消费端宕机了，之后生产者发送消息的时候服务端收不到，当消费端再次上线且组别没有发生变化的时候消费端还能消费到未消费的信息。这样自动实现了持久化。</p><h1 id="4、学习地址"><a href="#4、学习地址" class="headerlink" title="4、学习地址"></a>4、学习地址</h1><p>来源：哔哩哔哩尚硅谷：<a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Alibaba Sentinel</title>
      <link href="2021/04/30/SpringCloud%20Alibaba%20Sentinel%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%90%E6%B5%81/"/>
      <url>2021/04/30/SpringCloud%20Alibaba%20Sentinel%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Sentinel概述"><a href="#1、Sentinel概述" class="headerlink" title="1、Sentinel概述"></a>1、Sentinel概述</h1><h2 id="1-1、Sentinel是什么"><a href="#1-1、Sentinel是什么" class="headerlink" title="1.1、Sentinel是什么"></a>1.1、Sentinel是什么</h2><p>轻量级的流量控制、熔断降级Java库，就类似于Hystrix框架，是Alibaba的。<br>GitHub地址：<a href="https://github.com/alibaba/Sentinel">https://github.com/alibaba/Sentinel</a><br>下载地址：<a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a><br>中文文档地址：<a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">https://github.com/alibaba/Sentinel/wiki</a><br>英文文档地址：<a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel</a></p><h2 id="1-2、Sentinel能做什么"><a href="#1-2、Sentinel能做什么" class="headerlink" title="1.2、Sentinel能做什么"></a>1.2、Sentinel能做什么</h2><p><img src="https://img-blog.csdnimg.cn/20210420144157203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="特性"></p><h2 id="1-3、Sentinel安装过程"><a href="#1-3、Sentinel安装过程" class="headerlink" title="1.3、Sentinel安装过程"></a>1.3、Sentinel安装过程</h2><p><img src="https://img-blog.csdnimg.cn/20210420144310662.png" alt="安装部分"><br>下载Jar包到本地，前提保证有JDK1.8环境以及8080端口未被占用，运行java -jar sentinel-dashboard-(版本号).jar。之后访问：<a href="http://localhost:8080/">http://localhost:8080</a>即可访问到控制台。</p><h2 id="1-4、初始化演示工程"><a href="#1-4、初始化演示工程" class="headerlink" title="1.4、初始化演示工程"></a>1.4、初始化演示工程</h2><p>1.添加依赖（必须保证Nacos和Sentinel同时存在依赖环境）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">      &lt;!--SpringCloud ailibaba sentinel --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2.修改Yaml配置文件将服务注册进入Nacos并配置Sentinel控制台和暴露监控点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8401</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloudalibaba-sentinel-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        #Nacos服务注册中心地址</span><br><span class="line">        server-addr: localhost:8848</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        #配置Sentinel dashboard地址</span><br><span class="line">        dashboard: localhost:8080</span><br><span class="line">        #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span><br><span class="line">        port: 8719</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;*&#39;</span><br></pre></td></tr></table></figure><p>3.主启动类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainApp8401</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApp8401.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.业务类Controller</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    @GetMapping(<span class="string">&quot;/testA&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> testA()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;================测试A已经成功通过================&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/testB&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> testB()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;================测试B已经成功通过================&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.测试<br>先启动Nacos再启动Sentinel，登录Sentinel发现什么都没有，需要<strong>事先访问资源端点</strong>才能在控制台看到资源目录。所以得到结论：sentinel8080正在监控微服务8401</p><h1 id="2、Sentinel流控规则"><a href="#2、Sentinel流控规则" class="headerlink" title="2、Sentinel流控规则"></a>2、Sentinel流控规则</h1><h2 id="2-1、流控规则基本术语介绍"><a href="#2-1、流控规则基本术语介绍" class="headerlink" title="2.1、流控规则基本术语介绍"></a>2.1、流控规则基本术语介绍</h2><p><img src="https://img-blog.csdnimg.cn/20210420145248483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="介绍"></p><h2 id="2-2、流控模式"><a href="#2-2、流控模式" class="headerlink" title="2.2、流控模式"></a>2.2、流控模式</h2><h3 id="2-2-1、直接"><a href="#2-2-1、直接" class="headerlink" title="2.2.1、直接"></a>2.2.1、直接</h3><p><img src="https://img-blog.csdnimg.cn/20210420145538204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>默认的流控规则，配置一秒钟最大允许一次通过，表示1秒钟内查询1次就是OK，若超过次数1，就直接-快速失败，报默认错误。<br>快速点击访问<a href="http://localhost:8401/testA%EF%BC%8C**%E4%BC%9A%E6%8A%A5Blocked">http://localhost:8401/testA，**会报Blocked</a> by Sentinel (flow limiting)这个默认错误**。</p><h3 id="2-2-2、关联"><a href="#2-2-2、关联" class="headerlink" title="2.2.2、关联"></a>2.2.2、关联</h3><p><img src="https://img-blog.csdnimg.cn/20210420145654755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>当关联的资源达到阈值时，就限流自己，当关联资源/testB的qps阀值超过1时，就限流/testA的Rest访问地址，当关联资源到阈值后限制配置好的资源名。<br>使用PostMan进行线程组访问testB节点，再访问testA资源发现A资源已经被限制访问。</p><h3 id="2-2-3、链路"><a href="#2-2-3、链路" class="headerlink" title="2.2.3、链路"></a>2.2.3、链路</h3><p>使用多个请求去调用同一个微服务，所以会出现链路失败的情况。</p><h2 id="2-3、流控效果"><a href="#2-3、流控效果" class="headerlink" title="2.3、流控效果"></a>2.3、流控效果</h2><h3 id="2-3-1、直接-gt-快速失败"><a href="#2-3-1、直接-gt-快速失败" class="headerlink" title="2.3.1、直接-&gt;快速失败"></a>2.3.1、直接-&gt;快速失败</h3><p>默认的流控处理效果，出现<strong>Blocked by Sentinel (flow limiting)</strong> 异常，源码位于DefaultController这个控制层中可以发现里面有这条语句。</p><h3 id="2-3-2、预热"><a href="#2-3-2、预热" class="headerlink" title="2.3.2、预热"></a>2.3.2、预热</h3><p><img src="https://img-blog.csdnimg.cn/20210420150242835.png" alt="配置"></p><p>公式：阈值除以coldFactor(默认值为3),经过预热时长后才会达到阈值。默认coldFactor为3，即请求 QPS 从 threshold / 3 开始，经预热时长逐渐升至设定的 QPS 阈值。<br>源码：WarmUpController类中。<br>应用场景：秒杀系统在开启的瞬间，会有很多流量上来，预热方式就是为了保护系统，以慢慢增大吞吐量。</p><h3 id="2-3-3、排队等待"><a href="#2-3-3、排队等待" class="headerlink" title="2.3.3、排队等待"></a>2.3.3、排队等待</h3><p><img src="https://img-blog.csdnimg.cn/20210420150421797.png" alt="在这里插入图片描述"></p><p>匀速排队，阈值必须设置为QPS。<br><img src="https://img-blog.csdnimg.cn/20210420150353239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>源码在：com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController</p><h1 id="3、Sentinel降级规则"><a href="#3、Sentinel降级规则" class="headerlink" title="3、Sentinel降级规则"></a>3、Sentinel降级规则</h1><h2 id="3-1、基本介绍"><a href="#3-1、基本介绍" class="headerlink" title="3.1、基本介绍"></a>3.1、基本介绍</h2><p>Sentinel 熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，<br>让请求快速失败，避免影响到其它的资源而导致级联错误。</p><p>当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。<br>Sentinel的断路器是<strong>没有半开状态</strong>的，不像Hystrix是有半开状态。<br><img src="https://img-blog.csdnimg.cn/20210420150744245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-2、降级策略-RT"><a href="#3-2、降级策略-RT" class="headerlink" title="3.2、降级策略-RT"></a>3.2、降级策略-RT</h2><p><img src="https://img-blog.csdnimg.cn/20210420150845450.png" alt="在这里插入图片描述"><br>Java代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/testD&quot;</span>)</span><br><span class="line">public <span class="built_in">String</span> testD()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    log.info(<span class="string">&quot;testD 测试RT&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testD&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置<br><img src="https://img-blog.csdnimg.cn/20210420150937180.png" alt="在这里插入图片描述"><br>永远一秒钟打进来10个线程（大于5个了）调用testD，我们希望200毫秒处理完本次任务，<br>如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开(保险丝跳闸)微服务不可用，保险丝跳闸断电了。</p><h2 id="3-3、降级策略-异常比例"><a href="#3-3、降级策略-异常比例" class="headerlink" title="3.3、降级策略-异常比例"></a>3.3、降级策略-异常比例</h2><p><img src="https://img-blog.csdnimg.cn/20210420151057235.png" alt="在这里插入图片描述"><br>Java代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/testD&quot;</span>)</span><br><span class="line">public <span class="built_in">String</span> testD()</span><br><span class="line">&#123;</span><br><span class="line">    log.info(<span class="string">&quot;testD 测试RT&quot;</span>);</span><br><span class="line">    int age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testD&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置<br><img src="https://img-blog.csdnimg.cn/20210420151137928.png" alt="在这里插入图片描述"><br>如果异常超过百分之二十就断开断路器<br>单独访问一次，必然来一次报错一次(int age  = 10/0)，调一次错一次；开启jmeter后，直接高并发发送请求，多次调用达到我们的配置条件了。断路器开启(保险丝跳闸)，微服务不可用了，不再报错<strong>error（页面）</strong>而是服务降级了。</p><h2 id="3-4、降级策略-异常数"><a href="#3-4、降级策略-异常数" class="headerlink" title="3.4、降级策略-异常数"></a>3.4、降级策略-异常数</h2><p><img src="https://img-blog.csdnimg.cn/20210420151239463.png" alt="在这里插入图片描述"><br>Java代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/testE&quot;</span>)</span><br><span class="line">public <span class="built_in">String</span> testE()</span><br><span class="line">&#123;</span><br><span class="line">    log.info(<span class="string">&quot;testE 测试异常比例&quot;</span>);</span><br><span class="line">    int age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testE 测试异常比例&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置<br><img src="https://img-blog.csdnimg.cn/20210420151306642.png" alt="在这里插入图片描述"><br><a href="http://localhost:8401/testE%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE%E7%BB%9D%E5%AF%B9%E6%8A%A5%E9%94%99%EF%BC%8C%E5%9B%A0%E4%B8%BA%E9%99%A4%E6%95%B0%E4%B8%8D%E8%83%BD%E4%B8%BA%E9%9B%B6%EF%BC%8C">http://localhost:8401/testE，第一次访问绝对报错，因为除数不能为零，</a><br>我们看到error窗口，但是达到5次报错后，进入熔断后降级。就不会报错误页面而是报服务降级的页面。</p><h1 id="4、Sentinel热点key限流"><a href="#4、Sentinel热点key限流" class="headerlink" title="4、Sentinel热点key限流"></a>4、Sentinel热点key限流</h1><h2 id="4-1、热点key限流基本配置"><a href="#4-1、热点key限流基本配置" class="headerlink" title="4.1、热点key限流基本配置"></a>4.1、热点key限流基本配置</h2><p>何为热点<br>热点即经常访问的数据，很多时候我们希望统计或者限制某个热点数据中访问频次最高的TopN数据，并对其访问进行限流或者其它操作。</p><p>我们能不能自定?类似hystrix，某个方法出问题了，就找对应的兜底降级方法？<br>使用@SentinelResource可以实现，类似于Hystrix的自定义降级方法。</p><p><strong>Java代码配置自定义降级方法显示</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/testHotKey&quot;</span>)</span><br><span class="line">    @SentinelResource(value = <span class="string">&quot;testHotKey&quot;</span>, blockHandler = <span class="string">&quot;defaultHandler_testHotKey&quot;</span>)</span><br><span class="line">    public <span class="built_in">String</span> testHotKey(@RequestParam(value = <span class="string">&quot;p1&quot;</span>, required = <span class="literal">false</span>) <span class="built_in">String</span> p1,</span><br><span class="line">                             @RequestParam(value = <span class="string">&quot;p2&quot;</span>, required = <span class="literal">false</span>) <span class="built_in">String</span> p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;==============testHotKey&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="built_in">String</span> <span class="function"><span class="title">defaultHandler_testHotKey</span>(<span class="params"><span class="built_in">String</span> p1, <span class="built_in">String</span> p2, BlockException ble</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;==============defaultHandler_testHotKey，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时我们对第一个参数也就是p1进行限流，如果有它参与的请求那么久限制他的访问<br><img src="https://img-blog.csdnimg.cn/20210420151942837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-2、热点key参数例外项配置"><a href="#4-2、热点key参数例外项配置" class="headerlink" title="4.2、热点key参数例外项配置"></a>4.2、热点key参数例外项配置</h2><p>我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样，加入我们想要p1=3的时候，让他能够有更多的阈值。<br>在高级选项中打开这个并设置参数类型String，设置参数值为3，限定阈值为500。<br>这样传过来的参数p1只要等于3的时候就拥有500的上限。</p><h1 id="5、-SentinelResource注解详解"><a href="#5、-SentinelResource注解详解" class="headerlink" title="5、@SentinelResource注解详解"></a>5、@SentinelResource注解详解</h1><h2 id="5-1、基本限流配置存在的问题"><a href="#5-1、基本限流配置存在的问题" class="headerlink" title="5.1、基本限流配置存在的问题"></a>5.1、基本限流配置存在的问题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/byResource&quot;</span>)</span><br><span class="line">    @SentinelResource(value = <span class="string">&quot;byResource&quot;</span>, blockHandler = <span class="string">&quot;handleException&quot;</span>)</span><br><span class="line">    public CommonResult <span class="function"><span class="title">byResource</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;按资源名称限流测试OK&quot;</span>, <span class="keyword">new</span> Payment(2020L, <span class="string">&quot;serial001&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CommonResult <span class="function"><span class="title">handleException</span>(<span class="params">BlockException exception</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>, exception.getClass().getCanonicalName() + <span class="string">&quot;\t 服务不可用&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样限流之后，如果出现状况不会出现默认的页面会出现handleException中的结果。<br><strong>以上代码出现的问题</strong><br>1、依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。<br>2、每个业务方法都添加一个兜底的，那代码膨胀加剧。<br>3、全局统一的处理方法没有体现。</p><h2 id="5-2、全局限流配置"><a href="#5-2、全局限流配置" class="headerlink" title="5.2、全局限流配置"></a>5.2、全局限流配置</h2><p>编写一个类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CustomerBlockHandler</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> CommonResult <span class="function"><span class="title">handleException01</span>(<span class="params">BlockException exception</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>, <span class="string">&quot;自定义的限流处理信息，handleException01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> CommonResult <span class="function"><span class="title">handleException02</span>(<span class="params">BlockException exception</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>, <span class="string">&quot;自定义的限流处理信息，handleException02&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要在@SentinelResource中添加参数blockHandlerClass即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/rateLimit/customerBlockHandler&quot;</span>)</span><br><span class="line">    @SentinelResource(value = <span class="string">&quot;customerBlockHandler&quot;</span>,</span><br><span class="line">            blockHandlerClass = CustomerBlockHandler.class, blockHandler = <span class="string">&quot;handleException02&quot;</span>)</span><br><span class="line">    public CommonResult <span class="function"><span class="title">customerBlockHandler</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;按客户自定义限流处理逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样就可以指定是CustomerBlockHandler中的handleException02方法来处理被限流之后所出现的页面，避免代码耦合，解决全局统一与自定义。</p><h1 id="6、Sentinel服务熔断功能"><a href="#6、Sentinel服务熔断功能" class="headerlink" title="6、Sentinel服务熔断功能"></a>6、Sentinel服务熔断功能</h1><h2 id="6-1、Ribbon系列"><a href="#6-1、Ribbon系列" class="headerlink" title="6.1、Ribbon系列"></a>6.1、Ribbon系列</h2><p>1、创建服务提供者9003/9004，过程省略。<br>2、创建服务消费者84<br>①、Pom依赖文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--SpringCloud ailibaba sentinel --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>②、Yaml配置文件与之前的差不多不赘述<br>主要注册进入Nacos以及Sentinel中。<br>③、配置Ribbon的RestTemplate类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    public RestTemplate getRestTemplate()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④、Controller控制层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CircleBreakerController</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> final <span class="built_in">String</span> SERVICE_URL = <span class="string">&quot;http://nacos-payment-provider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line">    @RequestMapping(<span class="string">&quot;/consumer/fallback/&#123;id&#125;&quot;</span>)</span><br><span class="line">    @SentinelResource(value = <span class="string">&quot;fallback&quot;</span>, fallback = <span class="string">&quot;handlerFallback&quot;</span>, blockHandler = <span class="string">&quot;blockHandler&quot;</span>)</span><br><span class="line">    public CommonResult&lt;Payment&gt; <span class="function"><span class="title">fallback</span>(<span class="params">@PathVariable Long id</span>)</span> &#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span> + id, CommonResult.class, id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public CommonResult <span class="function"><span class="title">handlerFallback</span>(<span class="params">@PathVariable Long id, Throwable e</span>)</span> &#123;</span><br><span class="line">        Payment payment = <span class="keyword">new</span> Payment(id, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>, <span class="string">&quot;兜底异常handlerFallback,exception内容  &quot;</span> + e.getMessage(), payment);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public CommonResult <span class="function"><span class="title">blockHandler</span>(<span class="params">@PathVariable Long id, BlockException blockException</span>)</span> &#123;</span><br><span class="line">        Payment payment = <span class="keyword">new</span> Payment(id, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">445</span>, <span class="string">&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;</span> + blockException.getMessage(), payment);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>⑤、结论<br><strong>blockHandler</strong> 主要是管限流配置的，只配置了他，代码出现问题他管不着会返回错误页面，但是触发到限流条件了的话他会进行接管。<br><strong>fallback</strong> 主要管代码出现异常，代码500出现错误了之后直接返回fallback的友好页面。<br>若 <strong>blockHandler 和 fallback 都进行了配置</strong>，则被限流降级而抛出 BlockException 时只会进入 blockHandler 处理逻辑。</p><h2 id="6-2、Feign系列"><a href="#6-2、Feign系列" class="headerlink" title="6.2、Feign系列"></a>6.2、Feign系列</h2><p>1、添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud openfeign --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、修改上一个微服务的Yaml配置文件开启Sentinel对Feign的支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 激活Sentinel对Feign的支持</span><br><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: true </span><br></pre></td></tr></table></figure><p>3、带@FeignClient注解的业务接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value = <span class="string">&quot;nacos-payment-provider&quot;</span>, fallback = PaymentServiceImpl.class)</span><br><span class="line">public interface PaymentService &#123;</span><br><span class="line">    @GetMapping(value = <span class="string">&quot;/paymentSQL/&#123;id&#125;&quot;</span>)</span><br><span class="line">    public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(<span class="string">&quot;id&quot;</span>) Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、全局业务降级接口实现类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PaymentServiceImpl</span> <span class="title">implements</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult&lt;Payment&gt; <span class="function"><span class="title">paymentSQL</span>(<span class="params">Long id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>, <span class="string">&quot;服务降级返回，没有该流水信息&quot;</span>, <span class="keyword">new</span> Payment(id, <span class="string">&quot;errorSerial......&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、Controller控制层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">    private PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = <span class="string">&quot;/consumer/openfeign/&#123;id&#125;&quot;</span>)</span><br><span class="line">    public CommonResult&lt;Payment&gt; <span class="function"><span class="title">paymentSQL</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Long id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没有该id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paymentService.paymentSQL(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>6、主启动类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosMain84</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">            SpringApplication.run(OrderNacosMain84.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、测试：测试84调用9003，此时故意关闭9003微服务提供者，看84消费侧自动降级，不会被耗死。<br>结论：发现自动跳转到实现@FeignClient注解的业务接口的实现类上去了，不会被耗死，所以也有全局保护的功能。</p><h2 id="6-3、熔断框架比较"><a href="#6-3、熔断框架比较" class="headerlink" title="6.3、熔断框架比较"></a>6.3、熔断框架比较</h2><p><img src="https://img-blog.csdnimg.cn/20210420155045333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="7、Sentinel规则持久化"><a href="#7、Sentinel规则持久化" class="headerlink" title="7、Sentinel规则持久化"></a>7、Sentinel规则持久化</h1><p><strong>发现一个问题</strong>：一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化。所以我们需将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效。<br>1、修改8401的Pom文件（添加Sentinel整合Nacos的依赖）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-datasource-nacos&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、修改8401的Yaml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: localhost:8080 #配置Sentinel dashboard地址</span><br><span class="line">        port: 8719</span><br><span class="line">      datasource:</span><br><span class="line">        datasource1:</span><br><span class="line">          nacos:</span><br><span class="line">            server-addr: localhost:8848</span><br><span class="line">            dataId: cloudalibaba-sentinel-service</span><br><span class="line">            groupId: DEFAULT_GROUP</span><br><span class="line">            data-type: json</span><br><span class="line">            rule-type: flow</span><br></pre></td></tr></table></figure><p>3、在Nacos中添加Sentinel的配置规则<br><img src="https://img-blog.csdnimg.cn/20210420155539696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210420155528360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4、在Nacos中添加Sentinel的配置规则<br>启动8401端口之后，只要刷新一下Sentinel就可以看到规则已经出现在列表中了，快速访问<a href="http://localhost:8401/rateLimit/byUrl%E5%8F%91%E7%8E%B0%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99%E5%B7%B2%E7%BB%8F%E5%90%AF%E5%8A%A8%E4%BA%86%EF%BC%8C%E8%B6%85%E8%BF%87%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99%E5%B0%B1%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%BB%98%E8%AE%A4%E7%9A%84%E9%94%99%E8%AF%AF%E6%8F%90%E9%86%92%E3%80%82">http://localhost:8401/rateLimit/byUrl发现限流规则已经启动了，超过限流规则就会出现默认的错误提醒。</a><br>5、关闭8401服务之后规则消失，再次启动访问资源又回重新出现，达到持久化的目的。</p><h1 id="8、学习地址"><a href="#8、学习地址" class="headerlink" title="8、学习地址"></a>8、学习地址</h1><p>来源：哔哩哔哩尚硅谷：<a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Eureka与OpenFeign</title>
      <link href="2021/04/30/Eureka%E4%B8%8EOpenFeign/"/>
      <url>2021/04/30/Eureka%E4%B8%8EOpenFeign/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Eureka基础知识"><a href="#1、Eureka基础知识" class="headerlink" title="1、Eureka基础知识"></a>1、Eureka基础知识</h1><h2 id="1-1、什么是服务治理？"><a href="#1-1、什么是服务治理？" class="headerlink" title="1.1、什么是服务治理？"></a>1.1、什么是服务治理？</h2><p>Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理。在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。</p><h2 id="1-2、什么是服务注册？"><a href="#1-2、什么是服务注册？" class="headerlink" title="1.2、什么是服务注册？"></a>1.2、什么是服务注册？</h2><p>Eureka采用了CS的设计架构，Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。<br>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))<br><img src="https://img-blog.csdnimg.cn/2021041015073216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-3、Eureka两大组件"><a href="#1-3、Eureka两大组件" class="headerlink" title="1.3、Eureka两大组件"></a>1.3、Eureka两大组件</h2><p>Eureka包含两个组件：Eureka Server和Eureka Client<br>Eureka Server提供服务注册服务<br>各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p><p>EurekaClient通过注册中心进行访问<br>是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）</p><h1 id="2、单机Eureka构建步骤"><a href="#2、单机Eureka构建步骤" class="headerlink" title="2、单机Eureka构建步骤"></a>2、单机Eureka构建步骤</h1><h2 id="2-1、添加Eureka依赖"><a href="#2-1、添加Eureka依赖" class="headerlink" title="2.1、添加Eureka依赖"></a>2.1、添加Eureka依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--eureka-server--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-2、yaml配置文件"><a href="#2-2、yaml配置文件" class="headerlink" title="2.2、yaml配置文件"></a>2.2、yaml配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7001.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    #false表示不向注册中心注册自己。</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    service-url:</span><br><span class="line">      #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><h2 id="2-3、主启动类"><a href="#2-3、主启动类" class="headerlink" title="2.3、主启动类"></a>2.3、主启动类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaServer<span class="comment">//一定要添加上这个注解</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">EurekaMain7001</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4、访问"><a href="#2-4、访问" class="headerlink" title="2.4、访问"></a>2.4、访问</h2><p><a href="http://localhost:7001/">http://localhost:7001/</a><br>因为没有服务类加入进来所以列表是空的，接下来介绍如何将服务类加入进来。</p><h1 id="3、服务添加进Eureka步骤"><a href="#3、服务添加进Eureka步骤" class="headerlink" title="3、服务添加进Eureka步骤"></a>3、服务添加进Eureka步骤</h1><h2 id="3-1、引入依赖"><a href="#3-1、引入依赖" class="headerlink" title="3.1、引入依赖"></a>3.1、引入依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--eureka client--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="3-2、配置yaml文件"><a href="#3-2、配置yaml文件" class="headerlink" title="3.2、配置yaml文件"></a>3.2、配置yaml文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-provider-payment#服务名称</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: true#表示是否将自己注册进EurekaServer默认为true。</span><br><span class="line">    fetch-registry: true#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka#所加入的服务发现IP地址</span><br></pre></td></tr></table></figure><h2 id="3-3、主启动类"><a href="#3-3、主启动类" class="headerlink" title="3.3、主启动类"></a>3.3、主启动类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient<span class="comment">//应用Eureka客户端</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4、Eureka查看该服务"><a href="#3-4、Eureka查看该服务" class="headerlink" title="3.4、Eureka查看该服务"></a>3.4、Eureka查看该服务</h2><p><a href="http://localhost:7001/">http://localhost:7001/</a><br>可以在Instances currently registered with Eureka看到该服务已经注册进入。</p><h1 id="4、Eureka集群搭建"><a href="#4、Eureka集群搭建" class="headerlink" title="4、Eureka集群搭建"></a>4、Eureka集群搭建</h1><h2 id="4-1、复制Eureka的单机模块"><a href="#4-1、复制Eureka的单机模块" class="headerlink" title="4.1、复制Eureka的单机模块"></a>4.1、复制Eureka的单机模块</h2><p>修改yml中的端口号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7002</span><br></pre></td></tr></table></figure><h2 id="4-2、主类与单机一致，只需要将配置改为相互守望即可。"><a href="#4-2、主类与单机一致，只需要将配置改为相互守望即可。" class="headerlink" title="4.2、主类与单机一致，只需要将配置改为相互守望即可。"></a>4.2、主类与单机一致，只需要将配置改为相互守望即可。</h2><p><strong>7002端口的Eureka配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7002.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    #false表示不向注册中心注册自己。</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p><strong>7001端口的Eureka配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7001.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    #false表示不向注册中心注册自己。</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7002.com:2001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><h2 id="4-3、将客户端同时注册进入Eureka集群"><a href="#4-3、将客户端同时注册进入Eureka集群" class="headerlink" title="4.3、将客户端同时注册进入Eureka集群"></a>4.3、将客户端同时注册进入Eureka集群</h2><p>yml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka</span><br></pre></td></tr></table></figure><p>Eureka集群可以实现高可用。</p><h1 id="1、OpenFeign概述"><a href="#1、OpenFeign概述" class="headerlink" title="1、OpenFeign概述"></a>1、OpenFeign概述</h1><h2 id="1-1、OpenFeign是什么？"><a href="#1-1、OpenFeign是什么？" class="headerlink" title="1.1、OpenFeign是什么？"></a>1.1、OpenFeign是什么？</h2><p>Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。<br>它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡<br>GitHub地址：<a href="https://github.com/spring-cloud/spring-cloud-openfeign">https://github.com/spring-cloud/spring-cloud-openfeign</a></p><h2 id="1-2、Feign能干吗？"><a href="#1-2、Feign能干吗？" class="headerlink" title="1.2、Feign能干吗？"></a>1.2、Feign能干吗？</h2><p>Feign旨在使编写Java Http客户端变得更容易。<br>前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。</p><p>Feign集成了Ribbon<br>利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用</p><h1 id="2、OpenFeign使用"><a href="#2、OpenFeign使用" class="headerlink" title="2、OpenFeign使用"></a>2、OpenFeign使用</h1><h2 id="2-1、Pom文件，前提是Eureka已搭建成功"><a href="#2-1、Pom文件，前提是Eureka已搭建成功" class="headerlink" title="2.1、Pom文件，前提是Eureka已搭建成功"></a>2.1、Pom文件，前提是Eureka已搭建成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--openfeign--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>yml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><h2 id="2-2、主启动类"><a href="#2-2、主启动类" class="headerlink" title="2.2、主启动类"></a>2.2、主启动类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignMain80</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderFeignMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3、客户端的Service层接口"><a href="#2-3、客户端的Service层接口" class="headerlink" title="2.3、客户端的Service层接口"></a>2.3、客户端的Service层接口</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@FeignClient(value = <span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>)<span class="comment">//服务名称</span></span><br><span class="line">public interface PaymentFeignService &#123;</span><br><span class="line">    @GetMapping(<span class="string">&quot;/payment/get/&#123;id&#125;&quot;</span>)</span><br><span class="line">    public CommonResult getPaymentById(@PathVariable(<span class="string">&quot;id&quot;</span>) Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要与<strong>服务端</strong>的Controller进行对应</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/payment/get/&#123;id&#125;&quot;</span>)</span><br><span class="line">    public CommonResult <span class="function"><span class="title">getPaymentById</span>(<span class="params">@PathVariable(<span class="string">&quot;id&quot;</span>) Long id</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//业务逻辑省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="学习地址"><a href="#学习地址" class="headerlink" title="学习地址"></a>学习地址</h1><p>来源：<a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gateway网关学习笔记</title>
      <link href="2021/04/30/Gateway%E7%BD%91%E5%85%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/04/30/Gateway%E7%BD%91%E5%85%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="1-1、是什么"><a href="#1-1、是什么" class="headerlink" title="1.1、是什么"></a>1.1、是什么</h2><p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和 Project Reactor等技术。<br>Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能， 例如：熔断、限流、重试等。<br>SpringCloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架。<br>官网：<a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a></p><h2 id="1-2、做什么"><a href="#1-2、做什么" class="headerlink" title="1.2、做什么"></a>1.2、做什么</h2><p>反向代理、鉴权、流量控制、熔断、日志监控等等，相当于Servlet的过滤器。以下是<strong>架构图</strong>：<br><img src="https://img-blog.csdnimg.cn/20210412134605948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="架构图"></p><h2 id="1-3、三大核心概念"><a href="#1-3、三大核心概念" class="headerlink" title="1.3、三大核心概念"></a>1.3、三大核心概念</h2><h3 id="1-3-1、Route-路由"><a href="#1-3-1、Route-路由" class="headerlink" title="1.3.1、Route(路由)"></a>1.3.1、Route(路由)</h3><p>路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由</p><h3 id="1-3-2、Predicate-断言"><a href="#1-3-2、Predicate-断言" class="headerlink" title="1.3.2、Predicate(断言)"></a>1.3.2、Predicate(断言)</h3><p>参考的是Java8的java.util.function.Predicate<br>开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由。</p><h3 id="1-3-3、Filter-过滤"><a href="#1-3-3、Filter-过滤" class="headerlink" title="1.3.3、Filter(过滤)"></a>1.3.3、Filter(过滤)</h3><p>指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。</p><h1 id="2、Gateway配置过程"><a href="#2、Gateway配置过程" class="headerlink" title="2、Gateway配置过程"></a>2、Gateway配置过程</h1><h2 id="2-1、入门配置"><a href="#2-1、入门配置" class="headerlink" title="2.1、入门配置"></a>2.1、入门配置</h2><h3 id="2-1-1、通过配置文件进行配置"><a href="#2-1-1、通过配置文件进行配置" class="headerlink" title="2.1.1、通过配置文件进行配置"></a>2.1.1、通过配置文件进行配置</h3><p><strong>pom依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--gateway--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>主启动类</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">GateWayMain9527</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(GateWayMain9527.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>yml配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9527</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          uri: http:&#x2F;&#x2F;localhost:8001          #匹配后提供服务的路由地址</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;payment&#x2F;get&#x2F;**         # 断言，路径相匹配的进行路由</span><br><span class="line"></span><br><span class="line">        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          uri: http:&#x2F;&#x2F;localhost:8001          #匹配后提供服务的路由地址</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;payment&#x2F;lb&#x2F;**         # 断言，路径相匹配的进行路由</span><br></pre></td></tr></table></figure><p><strong>主要注意三点，一个是配置的url地址，另一个是断言匹配路径，还有就是注册进入服务发现Eureka中心。先启动8001端口，再启动9527端口变可以通过9527端口的/payment/get/id访问到8001端口，从而实现路由的功能。</strong></p><h3 id="2-1-1、通过注入RouteLocator的Bean配置"><a href="#2-1-1、通过注入RouteLocator的Bean配置" class="headerlink" title="2.1.1、通过注入RouteLocator的Bean配置"></a>2.1.1、通过注入RouteLocator的Bean配置</h3><p>加入依赖与主启动类与上面相同，不同的是添加一个Config配置类进入容器.<br>需求分析，通过9527端口的/guonei访问到百度新闻的国内新闻：<a href="http://news.baidu.com/guonei%E3%80%82">http://news.baidu.com/guonei。</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">GateWayConfig</span> </span>&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RouteLocator <span class="function"><span class="title">customRouteLocator</span>(<span class="params">RouteLocatorBuilder routeLocatorBuilder</span>)</span> &#123;</span><br><span class="line">        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();</span><br><span class="line">        routes.route(<span class="string">&quot;path_route_kevin&quot;</span>,</span><br><span class="line">                r -&gt; r.path(<span class="string">&quot;/guonei&quot;</span>)</span><br><span class="line">                        .uri(<span class="string">&quot;http://news.baidu.com/guonei&quot;</span>)).build();</span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器中放入一个RouteLocator类，生成一个路由，建立一个路径为/guonei的映射到uri为<a href="http://news.baidu.com/guonei%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%AE%BF%E9%97%AE%E7%99%BE%E5%BA%A6%E5%9B%BD%E5%86%85%E6%96%B0%E9%97%BB%E7%9A%84%E7%9B%AE%E7%9A%84%E3%80%82">http://news.baidu.com/guonei，实现访问百度国内新闻的目的。</a></p><h2 id="2-2、通过微服务名称实现动态路由"><a href="#2-2、通过微服务名称实现动态路由" class="headerlink" title="2.2、通过微服务名称实现动态路由"></a>2.2、通过微服务名称实现动态路由</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9527</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由</span><br><span class="line">      routes:</span><br><span class="line">        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          # uri: http:&#x2F;&#x2F;localhost:8001          #匹配后提供服务的路由地址</span><br><span class="line">          uri: lb:&#x2F;&#x2F;cloud-payment-service #匹配后提供服务的路由地址</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;payment&#x2F;get&#x2F;**         # 断言，路径相匹配的进行路由</span><br><span class="line"></span><br><span class="line">        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          # uri: http:&#x2F;&#x2F;localhost:8001          #匹配后提供服务的路由地址</span><br><span class="line">          uri: lb:&#x2F;&#x2F;cloud-payment-service #匹配后提供服务的路由地址</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;payment&#x2F;lb&#x2F;**         # 断言，路径相匹配的进行路由</span><br></pre></td></tr></table></figure><p>l<strong>b://serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri</strong></p><h2 id="2-3、Predicate断言的使用"><a href="#2-3、Predicate断言的使用" class="headerlink" title="2.3、Predicate断言的使用"></a>2.3、Predicate断言的使用</h2><h3 id="2-3-1、是什么？"><a href="#2-3-1、是什么？" class="headerlink" title="2.3.1、是什么？"></a>2.3.1、是什么？</h3><p>Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping基础架构的一部分。<br>Spring Cloud Gateway包括许多内置的Route Predicate工厂。所有这些Predicate都与HTTP请求的不同属性匹配。多个Route Predicate工厂可以进行组合。</p><p>Spring Cloud Gateway 创建 Route 对象时， 使用 RoutePredicateFactory 创建 Predicate 对象，Predicate 对象可以赋值给 Route。 Spring Cloud Gateway 包含许多内置的Route Predicate Factories。</p><p>所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通过逻辑and。<br>官网链接：<a href="https://docs.spring.io/spring-cloud-gateway/docs/3.0.3-SNAPSHOT/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/3.0.3-SNAPSHOT/reference/html/#gateway-request-predicates-factories</a></p><h2 id="2-4、Filter过滤器的使用"><a href="#2-4、Filter过滤器的使用" class="headerlink" title="2.4、Filter过滤器的使用"></a>2.4、Filter过滤器的使用</h2><h3 id="2-4-1、常用的GatewayFilter"><a href="#2-4-1、常用的GatewayFilter" class="headerlink" title="2.4.1、常用的GatewayFilter"></a>2.4.1、常用的GatewayFilter</h3><p>yml配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">     filters:</span><br><span class="line">            - AddRequestParameter&#x3D;X-Request-Id,1024 #过滤器工厂会在匹配的请求头加上一对请求头，名称为X-Request-Id值为1024</span><br></pre></td></tr></table></figure><h3 id="2-4-2、自定义过滤器"><a href="#2-4-2、自定义过滤器" class="headerlink" title="2.4.2、自定义过滤器"></a>2.4.2、自定义过滤器</h3><p>自定义全局GlobalFilter，只需要继承两个接口即可：GlobalFilter, Ordered。并加入到容器中去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">    public <span class="class"><span class="keyword">class</span> <span class="title">MyLogGateWayFilter</span> <span class="title">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; <span class="function"><span class="title">filter</span>(<span class="params">ServerWebExchange exchange, GatewayFilterChain chain</span>)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;***************   come in MyLogGateWayFilter：&quot;</span>+<span class="keyword">new</span> <span class="built_in">Date</span>()+<span class="string">&quot;***************&quot;</span>);</span><br><span class="line">        <span class="built_in">String</span> uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (uname == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户名为非法用户┭┮﹏┭┮&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int <span class="function"><span class="title">getOrder</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须带有参数才能够访问：<a href="http://localhost:9527/payment/lb?uname=z3%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%B8%A6%E5%B0%B1%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E3%80%82">http://localhost:9527/payment/lb?uname=z3，如果不带就访问不了。</a></p><h1 id="3、学习地址"><a href="#3、学习地址" class="headerlink" title="3、学习地址"></a>3、学习地址</h1><p>哔哩哔哩尚硅谷来源：<a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC学习笔记</title>
      <link href="2021/04/30/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/04/30/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>第一章SpringMVC概述<br>springvc:是基于spring的一个框架，实际上就是spring的一个模块，专门是做web开发的。理解是servlet的一个升级</p><p>web开发底层是servlet ,框架是在servlet基础上面加入一些功能，让你做web开发方便。</p><p>SpringMVC就是一个Spring。Spring是容器，ioc能够管理对象，使用<bean>，@Component，@Repository，@Service，@Controller，SpringMVC能够创建对象，放入到容器中（SpringMVC容器），SpringMVC容器中放的是控制器对象。</p><p>       我们要做的是使用@Controller创建控制器对象，把对象放入到SpringMVC容器中，把创建的对象作为控制器使用，这个容器对象能接受用户的请求，显示处理结果，就当做是一个servlet使用（类似但并不是）。</p><p>       使用@Controller注解创建的是一个普通类的对象，不是Servlet。SpringMVC赋予了控制器对象一些额外的功能。</p><p>Web开发底层是servlet，SpringMVC中有个对象是Servlet：DispatherServlet（中央调度器）</p><p>DispatherServlet：负责接收用户所有的请求，用户把请求给了DispatherServlet，之后DispathServlet把请求转发给我们的Controller对象，最后是Controller对象处理请求。</p><p>Index.jsp—DispatherServlet(Servlet)—转发，分配给—Controller对象(@Controller注解创建的对象)</p><p>第二章Springmvc请求的处理流程<br>1).发起请求some.do—</p><p>2).tomcat(web.xml—url-pattern知道 *.do的请求是给中央调度DispatcherServlet)—</p><p>3)DispatcherServlet(根据springmvc.xml配置知道some.do—dosome())——-4)DispatcherServlet把some.do转发给MyController.doSome()方法</p><p>5)框架执行dosome()把得到ModelAndView进行处理，转发到show.jsp</p><p>上面的过程简化的方式</p><p>       Some.do—DispatcherServlet—MyController</p><p>Springmvc执行过程源代码分析</p><p>tomcat启动，创建容器的过程<br>通过load-on-start标签指定的1，创建DispatcherServlet对象，DispatcherServlet它的父类是集成HttpServlet的，它是一个serlvet，在被创建时，会执行init()方法。在init方法中<br>//创建容器，读取配置文件<br>webApplicationContext ctx=new ClassPathXmlApplicationContext(“springmvc.xml”)；<br>//把容器对象放入到ServletContext中<br>getServletContext().setAttribute(key,ctx);</p><p>上面创建容器作用：创建@Controller注解所在的类的对象。创建MyController对象中，这个对象放入到springmvc的容器中，容器是map，类似map.put(“myController”, MyController对象)</p><p>请求的处理过程<br>1）执行serv的service()</p><p>Protected void service(HttpServletRequest request,HttpServletResponse response)</p><p>Protected void doService(HttpServletRequest request,HttpServletResponse response)</p><p>DispatcherServlet.doDispatch(request,response){</p><p>调用MyController的dosom()方法;</p><p>}</p><p>       复习springmvc框架以及如何接收用户的参数</p><p>没有加入Java到JSON转换的时候其中内存中的对象</p><p>text/plain;charset=ISO-8859-1</p><p>发起的请求是由哪些服务器程序处理的。</p><p>Tomcat本身能处理静态资源的访问，像html，图片，js文件都是静态资源。</p><p> 表示静态资源和未映射的请求都给default处理</p><p>Default这个servlet作用：</p><p>处理静态资源<br>处理未映射到其他servlet的请求</p><p>复习前两天的内容：</p><p>解决请求中post方式有中文乱码，使用过滤器解决问题。CharacterEncodingFilter</p><p>逐个接收中，请求中参数名和形参名不一样，使用注解@RequestParam解决问题</p><p>使用Java对象接收请求参数时，要求请求中参数名和属性名一样。</p><p>Springmvc处理器方法的形参还可以用Map、List等集合类型，数组都可以。</p><p>处理器方法的返回值：</p><p>       表示请求的处理结果</p><p>ModelAndView，表示数据和视图，对视图执行forward<br>String：表示视图的，可以逻辑名称，完整视图路径，对视图执行forward<br>Void：返回值本身不能表示数据和视图，可以相应ajax请求<br>对象Object：表示数据的，可以响应ajax请求。<br>Springmvc处理器返回对象，转为json响应ajax步骤：①加入处理java转为json转换的工具库：使用jackson。②在springmvc配置文件加入注解驱动&lt;mvc：annotation-dirver&gt;。③在处理器方法上面加入@Requestbody。</p><p>url-pattren设置中央调度器的url-pattern是“/”：表示静态资源访问失败都是404，动态资源可以正常访问（例如网页的请求）。</p><p>              第一种解决静态资源访问的方案：在spring的配置文件中1）<a href="mvc:default-servelt-handler">mvc:default-servelt-handler</a> 2）<a href="mvc:annotation-driven">mvc:annotation-driven</a>。（原理：给程序内存中增加一个处理器对象，DefaultHttpRequestHandler，让这个对象来处理静态资源的访问）</p><p>             </p><p>在jsp，html中使用的地址，都是在前端页面中的地址，都是相对地址</p><p>地址分类：</p><p>绝对地址，带有协议名称的是绝对地址，<a href="http://www.baidu.com,ftp//202.122.23.1">http://www.baidu.com，ftp://202.122.23.1</a><br>相对地址，没有协议开头的，例如：user/some.do，/user/some.do。相对地址不能独立的使用，必须有一个参考地址，通过参考地址+相对地址本身才能够指定资源。<br>参考地址<br>在你的页面中的，访问地址不加“/”</p><p>访问的是：<a href="http://localhost:8080/ch06_path/index.jsp">http://localhost:8080/ch06_path/index.jsp</a></p><p>路径：<a href="http://localhost:8080/ch06_path/">http://localhost:8080/ch06_path/</a></p><p>资源：index.jsp</p><p>在index.jsp发起user/some.do请求，访问地址变为：<a href="http://localhost:8080/ch06_path/user/some.do">http://localhost:8080/ch06_path/user/some.do</a></p><p>当你的地址    没有斜杠开头，例如 user/some.do，当你点击链接时，访问地址是当前页面的地址再加上你链接的地址。</p><p><a href="http://localhost:8080/ch06_path/">http://localhost:8080/ch06_path/</a> + user/some.do</p><p>index.jsp 访问user/some.do，返回后现在的地址：<a href="http://localhost:8080/ch06_path/user/some.do">http://localhost:8080/ch06_path/user/some.do</a></p><p>路径<a href="http://localhost:8080/ch06_path/user/">http://localhost:8080/ch06_path/user/</a></p><p>资源：some.do</p><p>在index.jsp在user/some.do，就变为<a href="http://localhost:8080/ch06_path/user/user/some.do">http://localhost:8080/ch06_path/user/user/some.do</a></p><p>       解决方案：</p><p>加入EL表达式也就是下面介绍的那个。<br>加入一个base标签，是html语言中的标签。表示当前页面中访问地址的基地址。表示你的页面中所有没有“/”开头的地址，都是以base标签中的地址作为参考地址，使用base中的地址+user/some.do组成访问地址</p><p>2）在你的页面加上斜杠“/”</p><p>       访问的是：<a href="http://localhost:8080/ch06_path/index.jsp">http://localhost:8080/ch06_path/index.jsp</a></p><p>       路径：<a href="http://localhost:8080/ch06_path/">http://localhost:8080/ch06_path/</a></p><p>点击       /user/some.do 访问地址变为<a href="http://localhost:8080/user/some.do">http://localhost:8080/user/some.do</a>   参考地址是       你的服务器地址，也就是<a href="http://localhost:8080/">http://localhost:8080</a></p><p>如果你的资源不能加入${pageContext.request.contextPath}（这个叫做EL表达式）</p><p><a href="/ch06_path/user/some.do">发起user/first.do的get请求</a></p><p>如果你的资源不能访问，有一个/是绝对的所以我们需要加入${pageContext.request.contextPath}这个EL表达式.</p><p>Index,jsp—addStudent.jsp—student/addStudent.do(Service的方法dao的方法)—result.jsp</p><p>第四章 SpringMVC核心技术<br>SpringMVC框架采用的是统一，全局的异常处理。</p><p>把Controller中的所有异常处理都集中到一个地方。采用的是aop的思想。把业务逻辑和异常处理代码分开，解耦合。</p><p>使用两个注解</p><p>1.@ExceptionHandler</p><p>2.@ControllerAdvice</p><p>拦截器：</p><p>1）拦截器是SpringMVC中的一种，需要实现HandlerInterceptor接口</p><p>2）拦截器和过滤器类似，功能方向侧重点不同。过滤器是用来过滤器请求参数，设置编码字符集等工作。</p><p>3）拦截器是拦截用户请求，做请求做判断处理。</p><p>4）拦截器是全局的，可以对多个Controller做拦截。一个项目中可以有0个或多个拦截器，他们在一起拦截用户请求。拦截器常用在：用户登录处理，权限检查，记录日志。</p><p>拦截器的使用步骤：</p><p>定义类实现HandlerInterceptor接口<br>在SpringMVC配置文件中声明拦截器，让框架知道拦截器的存在。<br>拦截器的执行时间：</p><p>       1）在请求处理之前，也就是Controller类中的方法执行之前先被拦截。</p><p>       2）在控制器方法执行之后也会执行拦截器。</p><p>       3）在请求处理完成后也会执行拦截器。</p><p>拦截器原理图</p><p>拦截器：看做是多个Controller中公用的功能，集中到拦截器统一处理，使用的是AOP的思想。掌握第一个preHandle()方法</p><p>============================================================</p><p>多个拦截器：</p><p>第一个拦截器preHandle=true，第二个拦截器preHandle=true</p><p>11111111拦截器的MyInterceptor的preHandle()</p><p>22222222拦截器的MyInterceptor的preHandle()</p><p>===================执行MyController中的doSome方法==============</p><p>22222222拦截器的MyInterceptor的postHandle()</p><p>11111111拦截器的MyInterceptor的postHandle()</p><p>22222222拦截器的MyInterceptor的afterCompletion()</p><p>111111111111拦截器的MyInterceptor的afterCompletion()</p><p>第一个拦截器preHandle=true，第二个拦截器preHandle=false</p><p>11111111拦截器的MyInterceptor的preHandle()</p><p>22222222拦截器的MyInterceptor的preHandle()</p><p>111111111111拦截器的MyInterceptor的afterCompletion()</p><p>第一个拦截器preHandle= false，第二个拦截器preHandle=true</p><p>11111111拦截器的MyInterceptor的preHandle()</p><p>拦截器和过滤器的区别</p><p>过滤去是Servlet中的对象，拦截器是框架中的对象。<br>过滤器是实现Filter接口对象，拦截器是实现HandlerInterceptor<br>过滤器是用来设置request，Response的参数，属性的，侧重对数据过滤的。拦截器是用来验证请求的，能截断请求。<br>过滤器是在拦截器之前先执行的。<br>过滤器是Tomcat服务器创建的对象。拦截器是SPringMVC容器中创建的对象。<br>过滤器是一个执行时间点，而拦截器是有三个执行时间点。<br>过滤器可以处理jsp，js，html等等。拦截器是侧重拦截对Controller的对象，如果你的请求不能被中央调度器DispatcherServlet接收，这请求不会执行拦截器的内容。<br>过滤器拦截普通类方法执行，过滤器过滤Servlet请求响应。</p><p>用拦截器验证用户身份</p><p>Ch12</p><p>SpringMVC的执行流程（理解）<br>ApplicationContext ctx = new ClassPathXmlApplication ( “beans.xml”) ;studentservice service = (studentService) ctx.getBean ( “service”) ;</p><p>SpringMVC内部请求的处理流程：也就是SpringMVC接收请求，到处理完成的过程</p><p>用户发起请求some.do<br>DispatcherServlet接收请求some.do，把请求转交给处理器映射器。<br>处理器映射器：SpringMVC框架中的一种对象，框架把视线了HandlerMapping接口的类都叫做映射器（多个）。</p><p>处理器映射器作用：根据请求，从SpringMVC容器对象中获取处理器对象（MyController controller=ctx.getBean(“some.do”)）</p><p>                             框架把找到的处理器对象放到一个叫做处理器执行链(HandlerExecutionChain)的类保存</p><p>HandlerExecutionChain：类中保存着：1.处理器对象(MyController)；2.项目中的拦截器List<HandlerIntercept></p><ol start="3"><li>DispatcherServlet把2中的HandlerExecutionchain中的处理器对象交给了处理器适配器对象（多个)处理器适配器:springmvc框架中的对象，需要实现HandlerAdapter接口。I</li></ol><p>处理器适配器作用:执行处理器方法（调用MyController.doSome()得到返回值ModelAndView)</p><p>4．DispatcherServlet把3中获取的ModelAndView交给视图解析器对象。</p><p>视图解析器：SpringMVC的对象，需要实现ViewResoler接口（可以有多个）</p><p>视图解析器作用：组成视图完整路径，使用前缀，后缀。并创建View对象。</p><p>View是一个接口，表示视图，在框架中jsp，html不是string表示，而是使用View和他的实现类表示视图。</p><p>InternalResourceView:视图类，表示jsp文件，视图解析器会创建InternalResourceView类对象。这个对象的里面，有一个属性url=/WEB-INF/view/show.jsp</p><p>5．DispatcherServlet把4步骤中创建的view对象获取到，调用view类自己的方法，把Model数据放入到request作用域。执行对象视图的forward。请求结束。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架整合过程</title>
      <link href="2021/03/29/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%BF%87%E7%A8%8B/"/>
      <url>2021/03/29/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="创建Maven的Web项目"><a href="#创建Maven的Web项目" class="headerlink" title="创建Maven的Web项目"></a>创建Maven的Web项目</h1><p>创建Maven项目，点击Create from archetype，勾选org.apache.maven.archetypes:maven-archetype-webapp，写上项目名称以及Groupld，选择Maven库以及Maven Home，点击完成。<br>创建Java、Resource目录，项目结构如下：<br><img src="https://img-blog.csdnimg.cn/20210124221653919.png" alt="在这里插入图片描述"><br>创建bean实体包、Controller控制层包、dao持久化数据库操作包、Service服务包以及其目录下的ServiceImpl服务接口实现包。<img src="https://img-blog.csdnimg.cn/20210124221823903.png" alt="在这里插入图片描述"></p><h1 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h1><h6 id="创建jdbc-properties数据库连接文件"><a href="#创建jdbc-properties数据库连接文件" class="headerlink" title="创建jdbc.properties数据库连接文件"></a>创建jdbc.properties数据库连接文件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/数据库名称?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line">jdbc.username=用户名</span><br><span class="line">jdbc.passwd=密码</span><br></pre></td></tr></table></figure><h6 id="创建Mybatis-xml配置文件"><a href="#创建Mybatis-xml配置文件" class="headerlink" title="创建Mybatis.xml配置文件"></a>创建Mybatis.xml配置文件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--settings：控制mybatis全局行为--&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;!--设置mybatis输出日志--&gt;</span><br><span class="line">        &lt;setting name=<span class="string">&quot;logImpl&quot;</span> value=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">    &lt;!--设置别名--&gt;</span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;package name=<span class="string">&quot;实体类所在的包名&quot;</span>/&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line">    &lt;!-- sql mapper(sql映射文件)的位置--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;package name=<span class="string">&quot;mapper文件所在的包名在src/java/dao路径下&quot;</span>/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h6 id="创建Spring的ApplicationContext-xml配置文件"><a href="#创建Spring的ApplicationContext-xml配置文件" class="headerlink" title="创建Spring的ApplicationContext.xml配置文件"></a>创建Spring的ApplicationContext.xml配置文件</h6><p>其中需要声明数据源、声明SqlSessionFactory、扫描dao对象、服务层包的bean对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xmlns:mvc=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--spring配置文件：声明service，dao，工具类对象。--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--去声明数据源，连接数据库--&gt;</span><br><span class="line">    &lt;context:property-placeholder location=<span class="string">&quot;classpath:jdbc.&#x27;properties存放的位置&#x27;&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;dataSource&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span><br><span class="line">          init-method=<span class="string">&quot;init&quot;</span> destroy-method=<span class="string">&quot;close&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;jdbc.passwd&#125;&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--声明sqlSessionFactoryBean创建SqlSessionFactory--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;configLocation&quot;</span> value=<span class="string">&quot;classpath:&#x27;mybatis.xml存放的位置&#x27;&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--声明mybatis扫描器创建dao对象--&gt;</span><br><span class="line">    &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> value=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;basePackage&quot;</span> value=<span class="string">&quot;dao存放的引用路径&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--声明service的注解@Service所在的包名位置--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=<span class="string">&quot;service存放的引用路径&quot;</span>/&gt;</span><br><span class="line">    &lt;!--事务配置：注解的配置，aspectj的配置都在后面配置--&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h6 id="创建SpringMVC的DispatcherServlet-xml配置文件"><a href="#创建SpringMVC的DispatcherServlet-xml配置文件" class="headerlink" title="创建SpringMVC的DispatcherServlet.xml配置文件"></a>创建SpringMVC的DispatcherServlet.xml配置文件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xmlns:mvc=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;!--springmvc配置文件，声明Controller和其它web相关的对象--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--声明组件扫描器--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=<span class="string">&quot;controller所在的包名&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--声明springmvc框架中的视图解析器，帮助开发人员设置视图文件的路径--&gt;</span><br><span class="line">    &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br><span class="line">        &lt;!--前缀：视图文件的路径--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;prefix&quot;</span> value=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br><span class="line">        &lt;!--后缀：表示视图文件的扩展名，使用的<span class="built_in">Set</span>注入方式，赋值所以是用的value进行赋值--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;suffix&quot;</span> value=<span class="string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--声明注解驱动，做ajax和静态资源都需要用到注解驱动--&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h1 id="修改web-xml配置文件"><a href="#修改web-xml配置文件" class="headerlink" title="修改web.xml配置文件"></a>修改web.xml配置文件</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;4.0&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--中央调度器DispatcherServlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;web&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line">            &lt;param-value&gt;classpath:conf/DispatcherServlet.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;load-on-startup&gt;<span class="number">1</span>&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;web&lt;/servlet-name&gt;</span><br><span class="line">        &lt;!--将所有以.do结尾的处理都交给中央处理器解决--&gt;</span><br><span class="line">        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册spring的监听器--&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:conf/applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &lt;!--注册字符集过滤器，解决<span class="title">POST</span>乱码的问题--&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">characterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">filter</span>-<span class="title">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">CharacterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;!--设置项目中使用的字符编码--&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">utf</span>-8&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;!--强制请求对象（<span class="title">HTTPServletRequest</span>）使用<span class="title">enconding</span>编码的值--&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">forceRequestEncoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">true</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;!--强制应答对象（<span class="title">HTTPServletResponse</span>）使用<span class="title">enconding</span>编码的值--&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">forceResponseEncoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">true</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">characterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">web</span>-<span class="title">app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来就可以自己写业务逻辑代码了，或者使用EasyCode插件进行对应的逆向工程生成代码。这就是学习动力节点的B站相关视频总结出来的，感谢大家看到这儿，有问题欢迎指正，谢谢！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习笔记</title>
      <link href="2021/03/29/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/29/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章概述"><a href="#第一章概述" class="headerlink" title="第一章概述"></a>第一章概述</h1><p>框架怎么学：框架是一个软件，其他人写好的软件。<br>1）    知道框架能做什么，mybatis—访问数据库，对表中的数据执行增删改查<br>2）    框架的语法，框架要完成一个功能，需要一定的步骤支持的<br>3）    框架的内部实现，框架的内部怎么做。原理是什么？<br>4）    通过学习，可以实现一个框架。（写框架，实现框架）</p><h1 id="第二章控制反转IOC"><a href="#第二章控制反转IOC" class="headerlink" title="第二章控制反转IOC"></a>第二章控制反转IOC</h1><p>Spring的第一个核心思想。IOC（控制反转），是一个理论，概念，思想。描述：把对象的创建，赋值，管理工作都交给代码之外的容器实现。也就是对象的创建是有其它外部资源完成。<br>控制：创建对象，对象的属性赋值，对象之间的关系管理。<br>反转：把原来的开发人员管理，创建对象的权限转移给代码之外的容器实现。由容器代替工作人员管理对象，创建对象，给属性赋值<br>正转：由开发人员在代码中，使用new构造方法创建对象，开发人员主动管理对象。<br>为什么要使用ioc：目的就是减少对代码的改动，也能实现不同的功能。实现解耦合。<br>Java中创建对象有哪些方式：<br>1.构造方法，new Student（）<br>2.反射<br>3.序列化<br>4.克隆<br>5.Ioc：容器创建对象<br>6.动态代理</p><p>IOC的体现：<br>    Servlet 1：创建类继承HttpServelt<br>           2：在web.xml中注册servlet，使用<servlet-name>myservlet</servlet-name><br><servlet-class>com.bjpwernode.controller.MyServlet</servlet-class><br>           3：没有创建servlet对象，没有MyServlet myservlet=new MyServlet()<br>           4：Servlet是Tomcat服务器它不是你创建的。Tomcat也称为容器。<br>            Tomcat作为容器：里面存放servlet对象，Listener，Filter对象<br>IOC的技术实现，<br>    DI是ioc的技术实现，DI（Dependency Injection）是依赖注入，只需要在程序中提供要使用的对象名称就可以，至于对象如何在容器中创建，赋值，查找都由容器内部实现。<br>Spring是使用的di实现了ioc的功能，spring底层创建对象，使用的反射机制。<br>Spring是一个容器，管理对象，给属性赋值，底层是反射创建对象。</p><p>Junit：单元测试，一个工具类库，做测试方法使用的。<br>    单元：指定的是方法，一个类中有很多方法，一个方法称为一个单元。</p><ol><li>需要加入junit依赖。<dependency><!--      单元测试-->   <groupId>junit</groupId>   <artifactId>junit</artifactId>   <version>4.11</version>   <scope>test</scope></li><li>   创建测试作用的类：叫做测试类。<br>src/test/java目录中创建类</li><li>   创建测试方法<br>1）    public方法<br>2）    没有返回值void<br>3）    方法名称自定义，建议名称是test+你要测试的方法名称</li></ol><p> <br>4）    方法没有参数<br>5）    方法上面加入@Test，这样的方法是可以单独执行，不需要使用main方法。<br>什么样的对象放入容器中：dao类，service类，controller类，工具类<br>                        Spring中的对象默认都是单例，在容器中叫此名称对象仅一个</p><ol><li>   使用xml配置文件，使用bean标签</li><li>注解<br>不放到spring容器中的对象：实体类对象，实体类数据来自于数据库的。<pre><code>                     Servlet，listener，filter等。</code></pre>核心技术：IOC（控制反转）：1.理论，思想，概念：知道开发人员在容器中，代码之外管理对象，给属性赋值，管理依赖。<pre><code>                     2.IOC技术实现的DI（依赖注入）：开发人员在项目中只需要提供对象的名称，对象的创建查找赋值都由容器自己实现                     3.spring使用的DI的技术，底层使用的是反射机制                     4.DI给属性赋值：1set注入，2property方法赋值；引用类型注入属性名和ref的bean的id                                     2构造注入：constructor-arg的index和name进行对应构造方法的赋值</code></pre></li></ol><p>使用spring框架的步骤：加入依赖，创建类：接口、实现类、没有接口的类，创建spring的配置文件xml，使用<bean>声明对象，在使用容器中的对象，通过ApplicationContext接口和他的实现类ClassPathXmlApplcationContext的方法getBean（）就可以拿到容器。</p><p>1、    多个配置优势<br>a)    每个文件的大小比一个文件要小很多。效率高<br>b)    避免多人竞争带来的冲突<br>如果你的项目有多个模块（相关的功能在一起），一个模块一个配置文件。<br>    多文件的分配方式<br>a)    按功能模块，一个模块一个配置文件。<br>b)    按类的功能，数据库相关的配置一个文件配置文件，做事务的功能一个配置文件，做service功能的一个配置文件等</p><p>2、    基于注解的di：通过注解完成java对象创建，属性赋值。<br>使用注解的步骤：<br>    1、加入maven的依赖spring-context，在你加入spring-context的同时，<br>，间接加入spring-aop的依赖。使用注解必须使用aop的依赖。<br>    2、在类中加入spring 的注解（多个不同功能的注解）<br>    3、在spring的配置文件中，加入一个组件扫描器的标签，说明注解在你的项目中的位置<br>学习的注解：<br>    1、@Component，创建对象<br>    2、@Respotory，创建dao对象，用来访问数据库的。<br>    3、@Service，创建Service对象，处理业务逻辑的，可以有事务功能。<br>    4、@Controller，创建控制器对象，接受请求，显示处理结果。<br>    5、@Value，简单类型的属性赋值<br>    6、@Autowired，spring框架中引用类型的赋值注解，支持byName，byTyp默认是byType<br>    7、@Resource，jdk中的注解，使用自动注入给引用赋值，支持byName，byType，默认是byName<br>    8、注解的使用步骤：<br>        1、加入依赖：spring-context，简介加入spring-aop<br>        2、在类中加入注解<br>        3、在spring的配置文件中，加入组件扫描器的标签&lt;context:component-scan base-package=’包名’&gt;</p><p>Ioc能实现业务之间的解耦合，例如service和dao对象之间的解耦合。</p><h1 id="第三章AOP切面编程"><a href="#第三章AOP切面编程" class="headerlink" title="第三章AOP切面编程"></a>第三章AOP切面编程</h1><p>1．动态代理<br>    实现方式：JDK动态代理，使用JDK中的Proxy，Method，InvocationHanderl创建代理对象。JDK动态代理要求目标类必须实现接口<br>    Cglib动态代理：第三方的工具库，创建代理对象，原理是继承。通过继承目标类，创建子类，子类就是代理对象。要求目标类不能是final的，方法也不能是final<br>3.    动态代理的作用：<br>在目标类源代码不改变的情况下增加功能<br>减少代码的重复<br>专注业务逻辑代码<br>解耦合，让你的业务功能和日志，事务非业务功能分离<br>4.    AOP：面向切面编程，基于动态代理的，可以使用jdk，cglib两种代理方式。Aop就是动态代理的规范化，把动态代理的实现步骤，方式都定义好了，让开发人员用一种统一的方式，就用动态代理。<br>5.    AOP(Aspect Orient Programming)：面向切面编程<br>Aspect：切面，给你的目标类增加的功能，就是切面。上面的日志、事务<br>切面的特点：一般是非业务方法，独立使用<br>Orient：面向<br>Programming：编程<br>    怎么理解面向切面编程？<br>        1）需要在分析项目功能时，找出切面。<br>        2）合理的安排切面的执行时间（目标方法前，还是目标方法后）<br>        3）合理的安全切面执行位置，在哪个类具体增强什么功能。<br>    术语：<br>        1）Aspect：切面，表示增强的功能，代码，完成某个功能，非业务功能，常见的切面功能有日志，事务，统计信息，参数检查，权限验证。<br>        2）JoinPoint：连接点，连接业务和切面的位置。某类的业务方法<br>        3）Pointout：切入点，指多个连接点方法的集合。多个方法<br>        4）目标对象：给哪个类的方法增加功能，这个类就是目标对象<br>        5）Advice：通知，通知表示切面功能执行的时间。<br>说一个切面有三个关键的要素：<br>        1）切面的功能代码，切面干什么<br>        2）切面的执行位置，使用Pointcut表示切面执行的位置<br>        3）切面的执行时间，使用Advice表示时间，在目标方法之前还是目标方法之后<br>5、Aop的实现<br>    Aop是一个规范，是对动态代理的一个规范化，一个标准。<br>    Aop的技术实现框架：<br>        1、spring：spring内部实现了aop规范，能做aop的工作<br>                   Spring主要在事务处理使用aop<br>                   项目开发中很少使用spring 的aop实现，因为spring的aop比较笨重。<br>        2、aspectJ：一个开源的专门做aop的框架。Spring框架中集成了aspectJ框架，通过spring就能使用aspectJ的功能。<br>                    aspectJ框架实现aop的两种方式：</p><ol><li>   使用xml文件配置：配置全局事务</li><li>   使用注解，我们在项目中要做aop的功能，一般都用注解，aspectJ有5个注解。</li><li>学习aspectJ框架的使用<br>  1）切面的执行时间，这个执行时间在规范中他叫做Advice（通知，增强），在aspectJ框架中使用注解表示的。也可以使用xml配置文件中的标签<pre><code>  1）@Before  2）@AfterReturning  3）@Around  4）@AfterThrowing  5）@After</code></pre>  2）表示切面执行的位置，使用的是切入点表达式。</li></ol><h1 id="第四章Spring集成Mybatis"><a href="#第四章Spring集成Mybatis" class="headerlink" title="第四章Spring集成Mybatis"></a>第四章Spring集成Mybatis</h1><p>用的技术：ioc。<br>为什么ioc：能把Mybatis和spring集成到一起，像一个框架，是因为ioc能创建对象。<br>可以吧Mybatis框架中的对象交给spring统一创建，开发人员从spring中获取对象。<br>开发人员就不用同时面对两个或多个框架，就面对一个spring框架</p><p>Mybatis使用步骤：对象</p><ol><li>   定义dao接口，studentDao</li><li>   定义mapper文件 studentDao.xml</li><li>   定义mabatis的主配置文件 mybatis.xml文件</li><li>   创建dao 的代理对象，StudentDao dao=SqlSession.getMapper(StudentDao.class);<br>List<Student> students=dao.selectStudents();</li></ol><p>要使用dao对象，需要使用getMapper()方法，<br>怎么能使用getMapper()方法，需要哪些条件</p><ol><li>   获取SqlSession对象，需要使用SqlSessionFactory的openSession()方法。</li><li>   创建SqlSessionFactor对象。通过读取mybatis 的主配置文件，能创建SqlSessionFactory对象<br>需要SqlSessionFactory对象，使用Factory能获取SqlSession，有了SqlSession就能有dao，目的就是获取dao对象。Factory创建需要读取主配置文件。<br>主配置文件：</li><li>数据库信息</li><li>   Mapper文件的位置</li></ol><p>通过以上的说明，我们需要让spring创建以下对象<br>1.独立的连接池类的对象，使用阿里的druid连接池<br>2.SqlSessionFactory对象<br>3.创建出dao对象<br>需要学习就是上面三个对象的创建语法，使用xml的bean标签。</p><p>复习Aop：<br>    1.@Before：前置通知，在目标方法之前先执行切面的功能<br>    2.@AfterReturning后置通知，在目标方法之后执行的，能够获取到目标方法的返回值<br>    3.@Around环绕通知，在目标方法前和后都能增强功能，控制目标方法的访问，修改返回值<br>    4.@AterThrowing异常通知，在目标方法抛出异常后执行的通知<br>    5.@After最终通知，总是会被执行的代码<br>    6.@Pointcut定义和管理切入点的辅助注解<br>    7.代理的使用方法（1.如果目标有接口，框架使用jdk 的动态代理。如果目标类没有接口使用的是cglib动态代理。3.有接口也可以强制使用cglib动态代理。）</p><p>复习整合mybatis：<br>    使用spring的ioc核心技术，把mybatis框架中使用的对象交给spring统一创建和管理。（Spring是容器，存放项目中要使用的各种对象，例如Service对象，Dao对象，工具类对象等等。）<br>    1.交给spring的mybatis对象：1.数据源DataSource，使用阿里公司的Druid连接池<br>    2.SqlSessionFactory独享，使用的SqlSessionFactoryBean在内部创建的SqlSessionFactory<br>    3.Dao代理对象，使用的MapperScanConfigure，在这个类的内部，调用getMapper()，创建接口的Dao对象。</p><h1 id="第五章-Spring的事务处理"><a href="#第五章-Spring的事务处理" class="headerlink" title="第五章 Spring的事务处理"></a>第五章 Spring的事务处理</h1><ol><li>   什么是事务<br>讲mysql的时候，提出了事务，事务是指一组sql语句的集合，集合中有多条sql语句可能是insert，update，select，delete，我们希望这些多个sql语句都能成功，或者都失败，这些sql语句的执行是一直的，作为一个整体执行。</li><li>   在什么时候想到使用事务<br>当我的操作，涉及到多个表，或者是多个sql语句的insert，update，delete。需要保证这些语句都是成功才能完成我的功能，或者都失败，保证操作是符合要求的。<br>在java代码中写程序，控制事务，此时事务应该放在哪里呢？事务应该放在service类的业务方法上，因为业务方法会调用多个dao方法，执行多个sql语句</li><li>   通常使用JDBC访问数据库，还是mybatis访问数据库怎么处理事务<br>Jdbc访问数据库，处理事务 Connection conn；conn.commit()；conn.rollback();<br>Mybatis访问数据库，处理事务，SqlSession.commit()；SqlSession.rollback();<br>Hibernate访问数据库，处理事务，Session.commit()；Session.rollback()；</li><li>3问题中事务的处理方式，有什么不足<br>1）不同的数据库访问技术，处理事务的对象，方法不同，需要了解不同数据库访问技术使用事务的原理。<br>2）掌握多种数据库中事务的处理逻辑。什么时候提交事务，什么时候回滚事务。<br>3）处理事务的多种方法。<pre><code> 总结：就是多种数据库的访问技术，有不同的事务处理的机制，对象，方法</code></pre></li><li>   怎么解决不足<br>Spring提供一种处理事务的统一模型，能使用统一步骤，方式完成多种不同数据库访问技术的事务处理。<br>使用spring的事务处理机制，可以完成JDBC访问数据库的事务处理<br>使用spring的事务处理机制，可以完成mybatis访问数据的事务处理<br>使用spring的事务处理机制，可以完成hibernate访问数据库的事务处理</li><li>处理事务，需要怎么做，做什么<br>Spring处理事务的模型，使用的步骤都是固定的。把事务使用的信息提供给spring就可以了。<br>1）事务内部提交，回滚事务，使用的事务管理器对象，代替你完成commit，rollback。事务管理器是一个接口和他的众多实现类。<pre><code> 接口：PlatformTransactionManager，定义了事务重要方法commit，rollback 实现类：spring把每一种数据库访问技术对应的事务处理类都创建好了。 Mybatis访问数据库—spring创建好的DataSourceTransactionManager Hibernate访问数据库—spring创建DataSourceTransactionManager</code></pre>怎么使用：你需要告诉spring你用的哪种数据库访问技术，怎么告诉spring呢？声明数据库访问技术对于的事务管理器实现类，在spring的配置文件使用<bean>声明就可以了。例如：你要使用mybatis访问数据库，你应该在xml配置文件中<bean id=”XXX” class=”…DataSourceTransactionManager”>2）你的业务方法需要什么样的事务，说明需要事务的类型。 说明方法需要的事务： 2）事务的超时时间：表示一个方法最长的执行时间，如果方法执行时超过了，事务就会回滚。单位是秒，整数值，默认是-1。3）事务的传播行为：控制业务方法是不是有事务的，是什么样的事务的。7个传播行为，表示你的业务方法调用时，业务在方法之间是如果使用的。PROPAGATION_REQUIRED PROPAGATION_REQUIRES_NEW PROPAGATION_SUPPORTS 3）事务提交事务，回滚事务的时机 1）当你的业务方法，执行成功，没有异常抛出，当方法执行完毕，spring的方法执行后提交事务。事务管理器commit 2）当你的业务方法抛出运行异常，spring执行回滚，调用事务管理器的rollback运行时异常的定义：RuntimeException和他的子类都是运行时异常，例如NullPointException，NumberFormatException 3）当你的业务方法抛出非运行时异常，主要是受异常时，提交事务     受查异常：在你写代码中，必须处理的异常。例如IOExcetion，SQLException总结soring的事务</li><li>   管理事务的是事务管理和他的实现类</li><li>   Spring的事务是一个统一的模型<br>1）指定要使用的事务管理器实现类，使用<bean><br>2）指定哪些类，哪些方法需要加入事务的功能<br>3）指定方法需要的隔离级别，传播行为，超时时间<br>你需要告诉spring，你的项目类的信息，方法的名称，方法的事务传播行为。<br>Spring框架中提供的事务处理方案</li><li>适合中小项目使用的，注解方案。<br>spring框架自己用aop实现给业务方法增加事务的功能，使用@Transactional注解增加事务。Transactional注解是spring框架自己注解，放在public方法的上面，表示当前方法具有事务。可以给注解的属性赋值，表示具体的隔离级别，传播行为，异常信息等等。<br> 使用@Transactional的步骤</li><li>   需要声明事务管理器对象<bean id=”XX” class=”DataSourceTransactionMannager”></li><li>开启事务注解驱动，告诉spring框架，我要使用注解的方式管理事务。<br>Spring使用aop机制，创建@Transactional所在的类代理对象，给方法加入事务的功能。Spring给业务加入事务：<pre><code> 在你的业务执行之前，先开启事务，在业务方法之后提交或回滚事务，使用aop的环绕通知   3.在你的方法上面加入@Trancational注解</code></pre></li></ol><p>2.适合大型项目，有很多的类，方法，需要大量的配置事务，使用aspectj框架功能，在spring配置文件中声明类，方法需要的事务。这种方式业务方法和事务配置完全分离。<br>    实现步骤：都是在xml配置文件中实现。<br>        1）要使用的是aspectj框架，需要加依赖</p><pre><code>    2）声明事务管理器对象        &lt;bean id=”XXX” class=”DataSourceTransactionManager”&gt;    3）声明方法需要的事务类型（配置方法的事务属性【隔离级别，传播行为，超时】）    4）配置aop：指定哪些类要创建代理。</code></pre><h1 id="第六章Web项目使用ApplicationContext"><a href="#第六章Web项目使用ApplicationContext" class="headerlink" title="第六章Web项目使用ApplicationContext"></a>第六章Web项目使用ApplicationContext</h1><p>1.之前做的是javase项目有main方法的，执行代码是执行main方法，<br>    在main里面创建的容器对象<br>    ApplicationContext ctx=new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>2.web项目是在tomcat服务器上创建的，tomcat一启动，项目一直运行。</p><p>需求：<br>Web项目中容器对象只需要创建一次，把容器对象放到全局作用域ServletContext中。<br>怎么实现：<br>    使用监听器    当全局作用域对象被创建时    创建容器    存入ServletContext<br>    监听器的作用：<br>    1）创建容器对象，执行ApplicationContext ctx=new ClassPathApplicationContext(“applicationContext.xml”)<br>    2）把容器对象放入ServletContext，    ServletContext.setAttribute(key,ctx)<br>监听器可以自己创建，也可以使用框架中创建好的ContextLoaderListener（知道用法）</p><p>private wabApplicationcontext context;<br>public interface webApplicationcontext extends ApplicationContext<br>ApplicationContext：javase项目中使用的容器对象<br>webApplicationcontext：web项目中使用的容器对象<br>把创建的容器对象，放入到全局作用域</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记</title>
      <link href="2021/03/29/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/29/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>中文官网地址：<a href="http://www.redis.cn/">http://www.redis.cn</a><br>中文API文档地址：<a href="http://redisdoc.com/">http://redisdoc.com</a></p><h1 id="一、部署Redis"><a href="#一、部署Redis" class="headerlink" title="一、部署Redis"></a>一、部署Redis</h1><p>1.安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum -y install wget </span><br><span class="line">[root@localhost ~]# wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-6.0.6.tar.gz</span><br><span class="line">[root@localhost ~]# tar xzf redis-6.0.6.tar.gz</span><br><span class="line">[root@localhost ~]# cd redis-redis-6.0.6</span><br><span class="line">[root@localhost ~]# make   #提示报错选装GCC：yum install gcc-c++</span><br></pre></td></tr></table></figure><p>2.开启进程守护</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-6.0.6]# vi  redis.conf</span><br><span class="line"></span><br><span class="line"># Note that Redis will write a pid file in &#x2F;var&#x2F;run&#x2F;redis.pid when daemonized.</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><p>3.开启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">[root@localhost bin]# redis-server  &#x2F;redis-6.0.6&#x2F;redis.conf</span><br><span class="line">[root@localhost bin]# redis-cli  -p 6379</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p>4.关闭服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown</span><br><span class="line">not connected&gt; exit</span><br></pre></td></tr></table></figure><p>5.安装目录文件声明<br>redis-benchmark:性能测试工具，测试性能<br>redis-check-aof：修复有问题的AOF文件，<br>redis-check-dump：修复有问题的dump.rdb文件<br>redis-cli：客户端，操作入口<br>redis-sentinel：redis集群使用<br>redis-server：Redis服务器启动命令</p><p>参考于：<a href="https://blog.csdn.net/yangliuhbhd/article/details/81317689">https://blog.csdn.net/yangliuhbhd/article/details/81317689</a></p><h1 id="二、Redis常用命令"><a href="#二、Redis常用命令" class="headerlink" title="二、Redis常用命令"></a>二、Redis常用命令</h1><p><strong>Redis五大数据类型String（字符串）、Hash（哈希类似Java的Map）、List（列表）、Set（集合）、Zset（有序集合）</strong></p><p><strong>①String</strong><br>1.添加：set [key] [value]。带生命周期添加：setex [key] [秒数] [value]。带判断存在添加：setnx [key] [value]。<br>2.查询：keys [*]<br>3.删除：DEL [key]。使用FLUSHDB：清除当前数据库，FLUSHALL：清除所有数据库<br>4.移动：MOVE [key] [所移数据库名]<br>5.设置过期时间：EXPIRE [key名] [秒数]，查看过期时间ttl [key名]，如果为-1表示永不过期，-2表示已过期。其它时间为倒数秒数，已经过期的数据就被删除了，不会再keys *中查询到。<br>6.只增加数字不增字符串：INCR/DECR [key名]，增/减一。同理INCRBY/DECRBY [key名] [数字]。<br>7.定点查看字符串：GETRANGE [key名] [前下标] [后下标] ，截取下标添加字符串命令：SETRANGE [key名] [始标] [内容]。<br>8.追加：APPEND [key名] [追加数据]，查询长度：STRLEN [key名]<br>9.批量新增：mset [key] [value] [key] [value]……。批量获取：mget [key] [key] [key]。带判断的新增有序集合（如果数据库已存在都不会成功）：msetnx [key] [value] [key] [value]……。</p><p><strong>②List</strong><br>1.列表LIST相关添加：分为LPUSH和RPUSH，LPUSH [key] [v1] [v2] [v3]……，分为左右进入，如果你是使用左边进的话LPUSH就是逆着出LRANGE，如果你是RPUSH就是顺着出来LRANGE。可以这样理解，当使用LRANGE时是从左到右进行输出，使用LPUSH是从中间往左边插入，使用RPUSH是从中间往右边输入。只有RPUSH是怎么进怎么出。<br>2.创建LIST列表，命令：lpush [key名] [数组]，查看：LRANGE [LISTkey名] 0 -1，查看类型type [key名]。<br>3.列表出栈命令：lpop [key]和rpop [key]，一个是从左边出栈，一个是从右边出栈。<br>4.通过下标获取list中的值，LINDEX [list] [下标值]，是从左到右数的。下标从0开始。获取长度：LLEN [list]。<br>5.删除N个value：LREM [list] [所删除的个数] [所删除的数字]，如果删除的个数大于本身存在的个数，他就会把存在的全部删了，不会报错。<br>6.截取出其中一段赋值给本身：LTRIM [list] [始标] [末标]。<br>7.右出栈左进栈：RPOPLPUSH [list01] [list02] 。就是把后面的list01的右边最后一个添加到list02的左边第一个。<br>8.通过下标更改某一个值：lset [key] [index] [value]。在某个地方前/后插值：LINSERT [key] [before/after] [本身存在value1] [新值value2]。</p><p><strong>③Set</strong><br>1.添加：sadd [set名] [value] [value] ……。如果有重复的，集合默认把重复的忽略进行添加不重复的值。<br>2.查询：SMEMBERS [set名]。查看一个值是否在集合中：SMEMBERS [set名] [value]。查看元素个数SCARD [set名]。<br>3.删除集合中的值：SREM [set] [value]。<br>4.随机出值个数：SRANDMEMBER [set] [个数]。可用来抽奖。随机出栈：spop [set]。<br>5.移动一个值到另外的集合中：SMOVE [set源] [set目标] [所移动值]。<br>6.差集：SDIFF [set1集合] [set2集合] ……。所得出的数字是以set1集合为目标，不在后面任何一个集合中的数字出现。<br>7.交集：SINTER [set1集合] [set2集合] ……。所得出的数字是在这些集合中都有的数字。<br>8.并集：SUNION [set1集合] [set2集合] ……。所得出的数字是在这些全部数字但是不重复。</p><p><strong>④Hash（KV模式不变，但是V又是一个键值对）</strong><br>1.添加hash：hset [hash-key] [value-key] [value]。表示前面是添加符号，value-key表示的是value的key名字，最后面才是真正的value。<br>2.批量添加hash：hmset [hash-key] [value-key1][value1] [value-key2][value2] ……。所添加的就是一key为名的hash。批量获得hash：hmget [hash-key] [value-key1] [value-key2] 就可获得他们的value。第二种批量获得是：HGETALL [hash-key] 。会批量的得到前面是key后面的value的hash。<br>3.删除hash中某个value-key的value：hdel [hash-key] [value-key]。<br>4.获得hash的长度：hlen [hash-key]。<br>5.检测value-key是否存在hash中：HEXITS [hash-key] [value-key]。返回1为存在，返回0位不存在。<br>6.获取hash中每个keys的值：HKEYS [hash-key]。获取hash中每个value的值：HVALUES [hash-key]<br>7.使hash中数字key的value增减：HINCRBY [hash-key] [value-key] [所增长数字]。如果是浮点就是：HINCRBYFLOAT [hash-key] [value-key] [所增长数字]。<br>8.带判断存在的填充进入hash：HSETNX [hash-key] [value-key] [value]。</p><p><strong>⑤Zset有序集合（相当于在set集合基础之上加一个score值）</strong><br>1.添加有序集合：zadd [zset-key] [score1] [value1] [score2] [value2] ……。意思为后面的每个score和value是绑定到一起的是一个value。<br>2.序列输出：ZRANGE [zset-key] [0始标] [-1终标]。带有分数的序列输出：ZRANGE [zset-key] [始标] [终标] withscores。<br>3.输出范围的序列：ZRANGEBYSCORE [zset-key] [始分] [终分]。不包含命令：ZRANGEBYSCORE [zset-key] （[始分] （[终分]。在范围前加一个“（”表示不包含这个数。从范围序列中再进行筛选：ZRANGEBYSCORE [zset-key] [始分] [终分] limit [始标] [所取个数]。<br>4.删除某个值：ZREM [zset-key] [value]。把分数和value是一起删除的。<br>5.统计个数：ZCARD [zset-key]：分数和value是一体的，所以只有value的个数。<br>6.统计范围scores的个数：ZCOUNT [zset-key] [始分] [终分]。<br>7.顺序统计排名（以0开始）：ZRANK [zset-key] [value]。根据值输出对应分数：ZSCORE [zset-key] [value]。<br>8.逆序统计排名：ZREVRANK [zset-key] [value]。逆序获得名次。逆序统计名次输出：ZREVRANGE [zset-key] [0始标] [-1终标]。</p><h1 id="三、Redis如何持久化"><a href="#三、Redis如何持久化" class="headerlink" title="三、Redis如何持久化"></a>三、Redis如何持久化</h1><p>1.RDB、AOF。<br>2.RDB、AOF在指定的时间间隔内将内存中的数据集快照写入磁盘，<br>也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。Redis会单独创建（ fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。Fork的作用是赋值一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。<img src="https://img-blog.csdnimg.cn/20210129110414469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.在redis.conf配置文件中，系统会默默的给您生成三个策略，把dump.rdb保存到你的磁盘当中，这就是实现的持久化。<br>4.redis数据库中，运维会帮您把dump.rdb进行远程备份。当您使用FLUSHALL的时候清空了数据库在使用SHUTDOWN的时候他就将已经清空了的数据库保存下来了。所以这样下次就不能自动加载dump.rdb进行自动回复，需要下载dump.rdb进行恢复。简单来说：每次使用SHUTDOWN也会保存一次dump.rdb但是没有意义。如果有一个重要的数据需要保存，所以马上备份就是直接使用save命令，全部阻塞只管保存。bgsave是异步请求，一边保存一边接受新的增删。<br>5.RDB是非常紧凑文件，在保存文件父进程fork出子进程工作全由子进程做，所以RDB持久化方式可以最大化redis的性能。与AOF相比，恢复大的数据集时，RDB更快。缺点：丢失数据风险大，fork过程耗时间不能及时响应。<br>6.AOF：Append Only File：是在redis.conf配置文件append中默认关闭，我们将它开启之后它就会每次记录写入的操作。<br>7.AOF和RDB能够同时存在的，Redis启动时先读取AOF，如果AOF出现问题那么Redis启动被拒绝。如何解决？使用redis-check-aof自动帮你删除掉不符合它语法逻辑的，截断后面的。<br>8.重写原理，Redis会记录上次重写时的AOF大小，默认配置是当AOF大小是上次rewrite后大小的已被且文件大于64M时触发。但是现在至少的3GB起步了。<br>9.AOF文件是一个只进行追加的日志文件，Redis可以在AOF文件体积变得过大时，自动后台进行重写。AOF文件有序保存了对数据库写入操作，以Redis协议的格式保存，因此AOF文件的内容非常让人容易读懂。缺点：对于RDB来说AOF文件要大很多，根据fsync策略，AOF速度慢于RDB。<br>10.最终的性能建议：RDB作为后备策略，主要使用AOF来进行数据持久化。</p><h1 id="四、事务"><a href="#四、事务" class="headerlink" title="四、事务"></a>四、事务</h1><p>1.开启事务：MULTI。通常返回OK，之后进行的每个命令返回的都是QUEUED，最后使用EXEC就会返回一个队列为前面所执行的每一个结果输出。放弃事务不提交：DISCARD。<br>2.全体连坐：中间有一个出错了的话（注意是在加入队列的时候就报错(error)，相当于Java的编译时报错，这样的出错叫做全体连坐），事务提交不上去，所以就没有这一条事务，对应原子性。<br>3.冤头债主：中间有一个是出错了（但是他出错在加入队列的时候是能够加进去的，返回QUEUED而不是报错信息）这样最后提交事务EXEC那么错误的那条报错，其它的是能够提交上去的。<br>4.表锁：使用的时候整表锁住，一致性最高，并发性极差。行锁：加锁力度小一点，一致性一般，并发性较好。<br>5.悲观锁：相当于表锁，把整张表都锁住，每次使用都上锁，知道下一个拿到锁之后才能进行修改。乐观锁：相当于GitHub的Push推送，需要将最新版本号Pull下来之后在进行修改后在Push，这样在保证并发性的同时并保持一致性，策略：提交的版本必须大于记录当前版本才能执行更新。<br>6.Watch监控（类似于乐观锁）：假设一个信用卡时间，我这次使用了几块钱，下次就要换几块钱。使用balance和debt进行验证，初始为100和0。我们开始使用watch监控到balance之后，如果balance没有在其他线程进行修改那么它开启事务MULTI之后再进行decrby balance 20，incrby debt 20。最终提交exec那么它会出结果为80和20。  但是，如果在watch监控balance之后，另外一个线程去改变了balance的量之后，我们再进行之前的事务操作，事务就会失败。<br>7.UNwatch取消监控：第六条Watch监控失效之后，你所监控的key被修改了，那么需要使用UNwatch取消监控。之后在使用watch监控最新的版本，来进行开启事务MULTI，进行提交EXEC事务。这样就会成功。<br>8.一旦执行了EXEC或UNwatch之前被监控的所有key都被结算了。所以要重新监控。<br>9.了解redis有消息发布订阅。订阅：SUBSCRIBE [key1] [key2] [key3]……。另一个线程发布：PUBLISH [key名] [消息]。模糊订阅：PSUBSCRIBE [key]*，另一个线程发布：PUBLISH [key只要包含前一个key中的] [消息]。都会被接收到。</p><h1 id="五、主从复制"><a href="#五、主从复制" class="headerlink" title="五、主从复制"></a>五、主从复制</h1><p>1.Master用来写，Slave用来读。复制三个redis.conf，分别在redis后面加上端口号6379/80/81，之后进行配置他们的pidfile以及端口号和日志文件输出和dump+端口号。<br>2.分别使用三个配置文件开启端口号79 80 81的数据库，之后在使用info replication可以查看当前端口数据库是主还是从。之后从数据库使用SLAVEOF [ip地址] [端口号]来进行跟随主。并且在跟随主之前的数据都会被拷贝过来。<br>3.只有主机才能写，从机器只能读权限，所以他们写不了东西上去。<br>4.如果主机倒了，那么从机还是从机，不能变为主机，使用info replication还是从机。主机修复了之后从机依然跟随主机，不会发生任何改变，依然能够查询到主机添加的数据。<br>5.如果从机倒了，再进行端口打开连接，info replication那么他就从从机身份变成了主机身份，但是他是另外的一个主机身份，并不能查到之前主机数据库中的数据。除非写进了配置文件，不然都要重新连接主机。<br>6.一个主机可以有多个从机，但是一个从机只能有一个主机，从机可以跟随另外的一个从机，那么另外的中间从机它又是主机又是从机，但是它本身是不能写的所以这就形成了一个类似的链表结构。<br>7.中途变更转向：会清除之前的数据，重新读取新的主机的数据。<br>8.反客为主：SLAVEOF on noe。可以将主机已经下线的从机又变为新的主机。<br>9.哨兵模式：反客为主自动版。配置哨兵：sentinel monitor host6379 127.0.0.1 6379 1意思是代表监视6379的主机，如果SHUTDOWN了就后面跟随的从机器，谁的票数大于1就是谁是新主机。开启哨兵：redis-sentinel [sentinel.conf路径]。现在主机倒了，另外的从机会进行投票选出新的主机，而且不影响运行。但是如果倒掉的主机又重新连接上了，哨兵会将主机安排跟随新上位的从机。</p><h1 id="六、IDEA中如何使用Jedis"><a href="#六、IDEA中如何使用Jedis" class="headerlink" title="六、IDEA中如何使用Jedis"></a>六、IDEA中如何使用Jedis</h1><p>1.在IDEA中常用命令使用方法，先New一个Jedis(“ip地址”,”端口号”);之后方法基本上都是与命令行是差不多的。<br>2.IDEA中开启事务：jedis.multi();提交事务：jedis.exec();开始监控：jedis.watch(‘keys名’);<br>3.模拟网络阻塞时被监控目标被修改情况：在watch之后使用一个线程睡眠，与此同时在linux界面上去修改这个被监控的值，这样事务不会被提交。<br>4.测试主从复制，new Jedis两个不同的端口号。之后从机.slaveof(“IP地址”，端口号)，主机set值之后从机可以get到。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus</title>
      <link href="2021/03/29/MyBatisPlus/"/>
      <url>2021/03/29/MyBatisPlus/</url>
      
        <content type="html"><![CDATA[<p>@<a href="MybatisPlus%E7%AC%94%E8%AE%B0">TOC</a></p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-MyBatisPlus介绍"><a href="#1-MyBatisPlus介绍" class="headerlink" title="1.MyBatisPlus介绍"></a>1.MyBatisPlus介绍</h2><p>MyBatis-Plus( 简称 MP),是一个 MyBatis 的增强工具包，只做增强不做改变. 为简化开<br>发工作、提高生产率而生，我们的愿景是成为 Mybatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。</p><h2 id="2-代码及文档发布地址"><a href="#2-代码及文档发布地址" class="headerlink" title="2.代码及文档发布地址"></a>2.代码及文档发布地址</h2><p>官方地址:<br><a href="http://mp.baomidou.com/">http://mp.baomidou.com</a><br>代码发布地址:<br>Github: <a href="https://github.com/baomidou/mybatis-plus">https://github.com/baomidou/mybatis-plus</a><br>Gitee: <a href="https://gitee.com/baomidou/mybatis-plus">https://gitee.com/baomidou/mybatis-plus</a><br>文档发布地址:<br><a href="https://mp.baomidou.com/guide/">https://mp.baomidou.com/guide/</a><br>代码地址：<br><a href="https://github.com/ZKQevin/MybatisPlus">https://github.com/ZKQevin/MybatisPlus</a><br>学习地址：<br><a href="https://www.bilibili.com/video/BV1Ds411E76Y">https://www.bilibili.com/video/BV1Ds411E76Y</a></p><h1 id="二、集成MP"><a href="#二、集成MP" class="headerlink" title="二、集成MP"></a>二、集成MP</h1><h2 id="1-创建数据库表"><a href="#1-创建数据库表" class="headerlink" title="1.创建数据库表"></a>1.创建数据库表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 创建库 </span><br><span class="line">CREATE DATABASE mp; </span><br><span class="line">-- 使用库 </span><br><span class="line">USE mp; </span><br><span class="line">-- 创建表 </span><br><span class="line">CREATE TABLE tbl_employee( </span><br><span class="line">id INT(11) PRIMARY KEY AUTO_INCREMENT, </span><br><span class="line">last_name VARCHAR(50), </span><br><span class="line">email VARCHAR(50), </span><br><span class="line">gender CHAR(1),</span><br><span class="line"> age int </span><br><span class="line"> ); </span><br><span class="line">INSERT INTO tbl_employee(last_name,email,gender,age) VALUES(&#39;Tom&#39;,&#39;tom@qq.com&#39;,1,22); </span><br><span class="line">INSERT INTO tbl_employee(last_name,email,gender,age) VALUES(&#39;Jerry&#39;,&#39;jerry@qq.com&#39;,0,25); </span><br><span class="line">INSERT INTO tbl_employee(last_name,email,gender,age) VALUES(&#39;Black&#39;,&#39;black@qq.com&#39;,1,30); </span><br><span class="line">INSERT INTO tbl_employee(last_name,email,gender,age) VALUES(&#39;White&#39;,&#39;white@qq.com&#39;,0,35);</span><br></pre></td></tr></table></figure><h2 id="2-创建JavaBean实体类"><a href="#2-创建JavaBean实体类" class="headerlink" title="2.创建JavaBean实体类"></a>2.创建JavaBean实体类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private <span class="built_in">String</span> lastName;</span><br><span class="line">    private <span class="built_in">String</span> email;</span><br><span class="line">    private Integer gender;</span><br><span class="line">    private Integer age;</span><br><span class="line">    <span class="comment">//省略get和set以及ToString方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-添加依赖"><a href="#3-添加依赖" class="headerlink" title="3.添加依赖"></a>3.添加依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--单元测试依赖--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;4.11&lt;&#x2F;version&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--mp依赖</span><br><span class="line">           MybatisPlus 会自动维护Mybatis以及Mybatis-spring相关的依赖--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mybatis-plus&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;3.1.2&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--log4j--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.2.17&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--c3p0--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.mchange&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;0.9.5.2&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--mysql--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;5.1.38&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!--spring--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;4.3.13.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-orm&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;4.3.24.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="4-引入数据源配置部分省略"><a href="#4-引入数据源配置部分省略" class="headerlink" title="4.引入数据源配置部分省略"></a>4.引入数据源配置部分省略</h2><h1 id="三、通用CRUD"><a href="#三、通用CRUD" class="headerlink" title="三、通用CRUD"></a>三、通用CRUD</h1><p>1)基于 Mybatis<br>需要编写 EmployeeMapper 接口，并手动编写 CRUD 方法<br>提供 EmployeeMapper.xml 映射文件，并手动编写每个方法对应的 SQL 语句.<br>2)基于 MybatisPlus<br>只需要创建 EmployeeMapper 接口, 并继承 BaseMapper 接口.这就是使用 M<br>(泛型指定的就是当前Mapper接口所操作的实体类)需要完成的所有操作，甚至不需要创建 SQL 映射文件。</p><h2 id="1-插入操作"><a href="#1-插入操作" class="headerlink" title="1.插入操作"></a>1.插入操作</h2><p> <strong>①.生成ID策略</strong><br><img src="https://img-blog.csdnimg.cn/20210204142803599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>②.开启驼峰命名转换以及对应数据库表</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@TableName(value = <span class="string">&quot;tbl_employee&quot;</span>)<span class="comment">//对应数据库名</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TableId:</span></span><br><span class="line"><span class="comment">     *  value：指定表中的主键列的列明，如果实体属性名与类名一直，可以省略不指定，</span></span><br><span class="line"><span class="comment">     *  type：指定主键策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @TableId(value = <span class="string">&quot;id&quot;</span>,type = IdType.AUTO)</span><br><span class="line">    private Integer id;</span><br><span class="line">    private <span class="built_in">String</span> lastName;</span><br><span class="line">    private <span class="built_in">String</span> email;</span><br><span class="line">    private Integer gender;</span><br><span class="line">    private Integer age;</span><br><span class="line">    @TableField(exist = <span class="literal">false</span>)<span class="comment">//忽略数据库没有的值salary</span></span><br><span class="line">    private Integer salary;</span><br><span class="line">    <span class="comment">//省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③.获取插入的ID值</strong><br>在<strong>mybatis</strong>的Mapper映射文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id&#x3D;&quot;insert&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt;&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure><p>在<strong>MybatisPlus</strong>中，直接在Java后台获取到不需要写Mapper</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer key=employee.getId();</span><br></pre></td></tr></table></figure><p><strong>④.插入对象出现空值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">testCommonInsert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化Employee对象</span></span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setLastName(<span class="string">&quot;MP&quot;</span>);</span><br><span class="line">        employee.setEmail(<span class="string">&quot;kevin@qq.com&quot;</span>);</span><br><span class="line">        Integer result = employeeMapper.insert(employee);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时插入结果为：MP,<a href="mailto:&#x6b;&#101;&#x76;&#105;&#x6e;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;">&#x6b;&#101;&#x76;&#105;&#x6e;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;</a>，null，null。<br><strong>结论</strong>：insert方法在插入时，会根据实体类的每个属性进行非空判断，只有非空的属性对应的字段才会出现到SQL语句中</p><h2 id="2-更新操作"><a href="#2-更新操作" class="headerlink" title="2.更新操作"></a>2.更新操作</h2><p>通过ID进行更新操作，传入一个对相同会进行自动判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testCommonUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setId(<span class="number">6</span>);</span><br><span class="line">        employee.setLastName(<span class="string">&quot;MybatisPlus&quot;</span>);</span><br><span class="line">        employee.setEmail(<span class="string">&quot;MybatisPlus@qq.com&quot;</span>);</span><br><span class="line">        employee.setGender(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//可以写一个构造方法，new Employee(6,&quot;Name&quot;,&quot;email&quot;,0,20)</span></span><br><span class="line">        <span class="comment">//如果出现非空会MybatisPlus会进行自动判断，不会出现在SQL语句中</span></span><br><span class="line">        employee.setAge(<span class="number">20</span>);</span><br><span class="line">        Integer result = employeeMapper.updateById(employee);</span><br><span class="line">        System.out.println(<span class="string">&quot;result：&quot;</span>+result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-查询操作"><a href="#3-查询操作" class="headerlink" title="3.查询操作"></a>3.查询操作</h2><p><strong>①.通过ID查询</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testCommonSelect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = employeeMapper.selectById(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Employee=&quot;</span>+employee);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>②.通过实体查询单条数据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.setId(<span class="number">4</span>);</span><br><span class="line">employee.setLastName(<span class="string">&quot;DSM&quot;</span>);</span><br><span class="line">Employee result = employeeMapper.selectOne(employee);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p><strong>③.传入多个ID查询多条记录</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; idList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">idList.add(<span class="number">4</span>);</span><br><span class="line">idList.add(<span class="number">5</span>);</span><br><span class="line">idList.add(<span class="number">6</span>);</span><br><span class="line">List&lt;Employee&gt; employees = employeeMapper.selectBatchIds(idList);</span><br><span class="line">System.out.println(employees);</span><br></pre></td></tr></table></figure><p><strong>④.使用HashMap封装对象查询</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; columnMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      columnMap.put(<span class="string">&quot;last_name&quot;</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">      columnMap.put(<span class="string">&quot;gender&quot;</span>,<span class="number">1</span>);</span><br><span class="line">      List&lt;Employee&gt; result = employeeMapper.selectByMap(columnMap);</span><br><span class="line">      System.out.println(result);</span><br></pre></td></tr></table></figure><p><strong>⑤.分页查询</strong><br>查询第三页，每一页显示两条数据，MybatisPlus会进行自动分页处理，底层使用的Mybatis的RowBounds方法进行处理，内存进行处理，所以SQL是看不到的。后续会使用MybatisPlus的插件进行物理分页</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IPage&lt;Employee&gt; result = employeeMapper.selectPage(<span class="keyword">new</span> Page&lt;&gt;(<span class="number">3</span>, <span class="number">2</span>), <span class="literal">null</span>);</span><br><span class="line">        System.out.println(result);</span><br></pre></td></tr></table></figure><h2 id="3-删除操作"><a href="#3-删除操作" class="headerlink" title="3.删除操作"></a>3.删除操作</h2><p><strong>①.通过id进行删除</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testCommonDelete</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Integer result = employeeMapper.deleteById(<span class="number">8</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result：&quot;</span>+result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>②.根据条件删除</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; columnMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      columnMap.put(<span class="string">&quot;last_name&quot;</span>,<span class="string">&quot;MP&quot;</span>);</span><br><span class="line">      columnMap.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;kevin@qq.com&quot;</span>);</span><br><span class="line">      Integer result = employeeMapper.deleteByMap(columnMap);</span><br><span class="line">      System.out.println(<span class="string">&quot;result&quot;</span>+result);</span><br></pre></td></tr></table></figure><p><strong>③.批量删除数据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; idList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      idList.add(<span class="number">12</span>);</span><br><span class="line">      idList.add(<span class="number">13</span>);</span><br><span class="line">      Integer result = employeeMapper.deleteBatchIds(idList);</span><br><span class="line">      System.out.println(<span class="string">&quot;result&quot;</span>+result);</span><br></pre></td></tr></table></figure><h2 id="4-MybatisPlus启动注入SQL原理分析"><a href="#4-MybatisPlus启动注入SQL原理分析" class="headerlink" title="4.MybatisPlus启动注入SQL原理分析"></a>4.MybatisPlus启动注入SQL原理分析</h2><p>问题: xxxMapper 继承了 BaseMapper, BaseMapper 中提供了通用的 CRUD 方法, 方法来源于 BaseMapper, 有方法就必须有 SQL, 因为 MyBatis 最终还是需要通过 SQL 语句操作数据。</p><h1 id="四、条件构造器"><a href="#四、条件构造器" class="headerlink" title="四、条件构造器"></a>四、条件构造器</h1><h2 id="1-QueryWrapper（条件查询构造器）"><a href="#1-QueryWrapper（条件查询构造器）" class="headerlink" title="1.QueryWrapper（条件查询构造器）"></a>1.QueryWrapper（条件查询构造器）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public Employee <span class="function"><span class="title">testQueryWrapperSelect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//1.我们需要分页查询tbl_employee表中，年龄在16-50之间性别为男性姓名为MP的所有用户</span></span><br><span class="line">        IPage&lt;Employee&gt; employeeIPage = employeeMapper.selectPage(<span class="keyword">new</span> Page&lt;Employee&gt;(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> QueryWrapper&lt;Employee&gt;()</span><br><span class="line">                        .between(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="number">50</span>)</span><br><span class="line">                        .eq(<span class="string">&quot;gender&quot;</span>, <span class="number">1</span>)</span><br><span class="line">                        .eq(<span class="string">&quot;last_name&quot;</span>, <span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        List&lt;Employee&gt; employees1=employeeIPage.getRecords();</span><br><span class="line">        employees1.forEach((value)-&gt; System.out.println(value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.查询tbl_employee表中，性别为女并且名字中带有“Tom”或者邮箱中带有“a“</span></span><br><span class="line">        List&lt;Employee&gt; employees2 = employeeMapper.selectList(<span class="keyword">new</span> QueryWrapper&lt;Employee&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;gender&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                .like(<span class="string">&quot;last_name&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">                .or()   <span class="comment">//SQL:(gender = ? AND last_name LIKE ? OR email LIKE ? )</span></span><br><span class="line">                <span class="comment">//.orNew()  //SQL:(gender = ? AND last_name LIKE ?) OR (email LIKE ? );貌似新版本已经取消orNew()了</span></span><br><span class="line">                .like(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        employees2.forEach(value -&gt; System.out.println(value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.使用last。查询为女的，根据age进行排序（asc/desc），进行分页</span></span><br><span class="line">        List&lt;Employee&gt; employees3 = employeeMapper.selectList(<span class="keyword">new</span> QueryWrapper&lt;Employee&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;gender&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                .orderByDesc(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">                .last(<span class="string">&quot;limit 1,3&quot;</span>));</span><br><span class="line">        employees3.forEach(value -&gt; System.out.println(value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.使用Condition分页查询tbl_employee表中，年龄在16-50之间性别为男性姓名为MP的所有用户（了解Condition即可）</span></span><br><span class="line">        <span class="comment">//employeeMapper.selectPage(new Page&lt;Employee&gt;(1,2),Connection.create().eq(&quot;gender&quot;,1));</span></span><br><span class="line">     <span class="comment">//5.另一种分页,获取每行存在list集合中，并且每行的字段都放在map集合中。key:value=columnName:value</span></span><br><span class="line">    Page&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt;&gt; page=employeeMapper.selectMapsPage(<span class="keyword">new</span> Page&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt;&gt;(<span class="number">1</span>,<span class="number">3</span>),</span><br><span class="line">                                                                <span class="keyword">new</span> QueryWrapper&lt;Employee&gt;().lambda()</span><br><span class="line">                                                                .between(Employee::getAge,<span class="number">15</span>,<span class="number">50</span>)</span><br><span class="line">                                                                .eq(Employee::getGender,<span class="number">1</span>)</span><br><span class="line">                                                                .eq(Employee::getLastName,<span class="string">&quot;MP&quot;</span>));</span><br><span class="line">    List&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt;&gt; emps=page.getRecords();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt; map:emps)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">String</span> key:map.keySet())&#123;</span><br><span class="line">            System.out.print(key+<span class="string">&quot;---&gt;&quot;</span>+map.get(key)+<span class="string">&quot;; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-UpdateWrapper（修改构造器）"><a href="#2-UpdateWrapper（修改构造器）" class="headerlink" title="2.UpdateWrapper（修改构造器）"></a>2.UpdateWrapper（修改构造器）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testUpdateWrapperSelect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setLastName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        employee.setEmail(<span class="string">&quot;Jack@sina.com&quot;</span>);</span><br><span class="line">        employee.setGender(<span class="number">0</span>);</span><br><span class="line">        Integer update = employeeMapper.update(employee, <span class="keyword">new</span> UpdateWrapper&lt;Employee&gt;()</span><br><span class="line">                        .eq(<span class="string">&quot;last_name&quot;</span>,<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">                        .eq(<span class="string">&quot;age&quot;</span>,<span class="number">44</span>));</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-UpdateWrapper（删除构造器）"><a href="#3-UpdateWrapper（删除构造器）" class="headerlink" title="3.UpdateWrapper（删除构造器）"></a>3.UpdateWrapper（删除构造器）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testDeleteWrapper</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Integer <span class="keyword">delete</span> = employeeMapper.delete(<span class="keyword">new</span> UpdateWrapper&lt;Employee&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;last_name&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        System.out.println(<span class="keyword">delete</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>本次教学只是常用的罗列出来，还有很多构造器方法在文档之中，需要自己学<br>MP：多个Wrapper    Condition 条件构造器<br>Mybatis MBG：xxxExample→Criteria：QBC(Query By Criteria) Hibernate、通用Mapper</p><h1 id="五、ActiveReccord（活动记录）"><a href="#五、ActiveReccord（活动记录）" class="headerlink" title="五、ActiveReccord（活动记录）"></a>五、ActiveReccord（活动记录）</h1><p><strong>1）概述</strong><br>Active Record(活动记录)，是一种领域模型模式，特点是一个模型类对应关系型数据库中的一个表，而模型类的一个实例对应表中的一行记录。<br>ActiveRecord 一直广受动态语言（ PHP 、 Ruby 等）的喜爱，而 Java 作为准静态语言，对于 ActiveRecord 往往只能感叹其优雅，所以 MP 也在 AR 道路上进行了一定的探索。</p><h2 id="1-使用AR：继承Model-lt-实体类-gt"><a href="#1-使用AR：继承Model-lt-实体类-gt" class="headerlink" title="1.使用AR：继承Model&lt;实体类&gt;"></a>1.使用AR：继承Model&lt;实体类&gt;</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Model</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//省略getset方法以及实体类属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-AR插入操作"><a href="#2-AR插入操作" class="headerlink" title="2.AR插入操作"></a>2.AR插入操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testARInsert</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setLastName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        employee.setEmail(<span class="string">&quot;Jack@qq.com&quot;</span>);</span><br><span class="line">        employee.setGender(<span class="number">1</span>);</span><br><span class="line">        employee.setAge(<span class="number">20</span>);</span><br><span class="line">        boolean insert = employee.insert();</span><br><span class="line">        System.out.println(<span class="string">&quot;Result=&quot;</span>+insert);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-AR修改操作"><a href="#3-AR修改操作" class="headerlink" title="3.AR修改操作"></a>3.AR修改操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testARUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="number">16</span>,<span class="string">&quot;JKL&quot;</span>,<span class="string">&quot;JKL@qq.com&quot;</span>,<span class="number">0</span>,<span class="number">15</span>);</span><br><span class="line">        System.out.println(employee.updateById());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-AR删除操作"><a href="#4-AR删除操作" class="headerlink" title="4.AR删除操作"></a>4.AR删除操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testARDelete</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        <span class="comment">//通过id删除数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过ID删除结果=&quot;</span>+employee.deleteById(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据条件删除数据(在逻辑上删除不存在的数据也是返回True)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过条件删除结果=&quot;</span>+employee.delete(<span class="keyword">new</span> QueryWrapper&lt;Employee&gt;().eq(<span class="string">&quot;last_name&quot;</span>,<span class="string">&quot;jack&quot;</span>)));</span><br></pre></td></tr></table></figure><h2 id="5-AR查询操作"><a href="#5-AR查询操作" class="headerlink" title="5.AR查询操作"></a>5.AR查询操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testARSelect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        <span class="comment">//通过id查询</span></span><br><span class="line">        System.out.println(employee.selectById(<span class="number">16</span>));</span><br><span class="line">        <span class="comment">//查询所有操作</span></span><br><span class="line">        System.out.println(employee.selectAll());</span><br><span class="line">        <span class="comment">//使用Wrapper以及AR进行模糊查询</span></span><br><span class="line">        employee.selectList(<span class="keyword">new</span> QueryWrapper&lt;Employee&gt;().like(<span class="string">&quot;last_name&quot;</span>,<span class="string">&quot;J&quot;</span>)).forEach(value -&gt; &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-AR分页复杂操作"><a href="#6-AR分页复杂操作" class="headerlink" title="6.AR分页复杂操作"></a>6.AR分页复杂操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testARPage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        <span class="comment">//selectpage方法将返回对象封装到一个Page对象中，如果要得到需要使用getRecord()方法。</span></span><br><span class="line">        IPage&lt;Employee&gt; employeeIPage = employee.selectPage(<span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>), <span class="keyword">new</span> QueryWrapper&lt;Employee&gt;().like(<span class="string">&quot;last_name&quot;</span>, <span class="string">&quot;T&quot;</span>));</span><br><span class="line">        employeeIPage.getRecords().forEach(value -&gt; &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h2><p>AR 模式提供了一种更加便捷的方式实现 CRUD 操作，其本质还是调用的 Mybatis 对应的方法，类似于<strong>语法糖</strong>。指计算机语言中添加的某种语法，这种语法对原本语言的功能并没有影响。可以更方便开发者使用，可以避免出错的机会，让程序可读性更好。</p><h1 id="六、代码生成器"><a href="#六、代码生成器" class="headerlink" title="六、代码生成器"></a>六、代码生成器</h1><p><strong>1）简介</strong><br>MP 提供了大量的自定义设置，生成的代码完全能够满足各类型的需求。AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。<br><strong>2）MP 的代码生成器 和 Mybatis MBG代码生成器的对比</strong><br>MP 的代码生成器都是基于 java 代码来生成。MBG 基于 xml 文件代码生成<br>MyBatis 的代码生成器可生成: 实体类、Mapper 接口、Mapper 映射文件</p><p>MP的代码生成器可生成: 实体类(可以选择是否支持 AR)、Mapper 接口、Mapper 映射文件、 Service 层、Controller层。IDEA的EasyCode也是可以进行生成。<br><strong>3）表及字段命名策略选择</strong><br>在MybatisPlus中，我们建议<strong>数据库表名</strong> 和 <strong>表字段名</strong>采用<strong>驼峰</strong>命名方式， 如果采用下划线命名方式，请开启全局下划线开关（版本2.3默认开启），如果表名字段名命名方式不一致请注解指定，我们建议最好保持一致（<strong>约定大于配置</strong>）</p><p>这么做的原因是为了避免在对应实体类时产生的性能损耗，这样字段不用做映射就能直接和实体类对应。当然如果项目里不用考虑这点性能损耗，那么你采用下滑线也是没问题的，只需要在生成代码时配置<strong>dbColumnUnderline</strong>(map-underscore-to-camel-case)属性就可以。</p><h2 id="1-使用添加依赖"><a href="#1-使用添加依赖" class="headerlink" title="1.使用添加依赖"></a>1.使用添加依赖</h2><p>添加 模板引擎 依赖和日志依赖，MyBatis-Plus 支持 <strong>Velocity</strong>（默认）、<strong>Freemarker</strong>、<strong>Beetl</strong>，用户可以选择自己熟悉的模板引擎，如果都不满足要求，可以采用自定义模板引擎。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Apach Velocity模版依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.velocity&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;velocity&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--sfl4j日志依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.7&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.7&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-生成器代码"><a href="#2-生成器代码" class="headerlink" title="2.生成器代码"></a>2.生成器代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testGenerator</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//1.全局策略配置</span></span><br><span class="line">        GlobalConfig config = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        config.setActiveRecord(<span class="literal">true</span>)<span class="comment">//是否支持AR模式</span></span><br><span class="line">                .setAuthor(<span class="string">&quot;kevin&quot;</span>)<span class="comment">//作者</span></span><br><span class="line">                .setOutputDir(<span class="string">&quot;D:\\Spring\\Spring-couse\\MyBatisPlus03\\src\\main\\java&quot;</span>)<span class="comment">//输出路径</span></span><br><span class="line">                .setFileOverride(<span class="literal">true</span>)<span class="comment">//文件覆盖</span></span><br><span class="line">                .setIdType(IdType.AUTO)<span class="comment">//主键策略</span></span><br><span class="line">                .setServiceName(<span class="string">&quot;%sService&quot;</span>)<span class="comment">//设置生成service接口名字的首字母是否为I（默认会生成I开头的IStudentService）</span></span><br><span class="line">                .setBaseResultMap(<span class="literal">true</span>)<span class="comment">//自动SQL映射文件，生成基本的ResultMap</span></span><br><span class="line">                .setBaseColumnList(<span class="literal">true</span>);<span class="comment">//生成基本的SQL片段</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.数据源配置</span></span><br><span class="line">        DataSourceConfig dataSourceConfig = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dataSourceConfig.setDbType(DbType.MYSQL)<span class="comment">//设置数据库类型</span></span><br><span class="line">                .setDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)<span class="comment">//数据库驱动名</span></span><br><span class="line">                .setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&quot;</span>)<span class="comment">//数据库地址</span></span><br><span class="line">                .setUsername(<span class="string">&quot;root&quot;</span>)<span class="comment">//数据库名字</span></span><br><span class="line">                .setPassword(<span class="string">&quot;123&quot;</span>);<span class="comment">//数据库密码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        strategy.setCapitalMode(<span class="literal">true</span>)<span class="comment">//全局大写命名</span></span><br><span class="line">                .setDbColumnUnderline(<span class="literal">true</span>)<span class="comment">//指定表明 字段名是否使用下划线</span></span><br><span class="line">                .setNaming(NamingStrategy.underline_to_camel)<span class="comment">//数据库表映射到实体的命名策略</span></span><br><span class="line">                .setTablePrefix(<span class="string">&quot;tbl_&quot;</span>)<span class="comment">//前置命名</span></span><br><span class="line">                .setInclude(<span class="string">&quot;tbl_employee&quot;</span>);<span class="comment">//生成的表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.包名策略</span></span><br><span class="line">        PackageConfig packageConfig = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        packageConfig.setParent(<span class="string">&quot;org.example&quot;</span>)<span class="comment">//所放置的包</span></span><br><span class="line">                .setMapper(<span class="string">&quot;mapper&quot;</span>)<span class="comment">//Mapper包</span></span><br><span class="line">                .setService(<span class="string">&quot;service&quot;</span>)<span class="comment">//服务层包</span></span><br><span class="line">                .setController(<span class="string">&quot;controller&quot;</span>)<span class="comment">//控制层</span></span><br><span class="line">                .setEntity(<span class="string">&quot;beans&quot;</span>)<span class="comment">//实体类</span></span><br><span class="line">                .setXml(<span class="string">&quot;mapper&quot;</span>);<span class="comment">//映射文件</span></span><br><span class="line">        <span class="comment">//5.整合配置</span></span><br><span class="line">        AutoGenerator autoGenerator = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line">        autoGenerator.setGlobalConfig(config)</span><br><span class="line">                .setDataSource(dataSourceConfig)</span><br><span class="line">                .setStrategy(strategy)</span><br><span class="line">                .setPackageInfo(packageConfig);</span><br><span class="line">        <span class="comment">//6.执行</span></span><br><span class="line">        autoGenerator.execute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-关于服务层自动注入"><a href="#3-关于服务层自动注入" class="headerlink" title="3.关于服务层自动注入"></a>3.关于服务层自动注入</h2><p>Service层的接口自动继承了了<strong>IService</strong>接口，里面有一些常用操作的接口<br>Service层的实现类不仅实现了Service层的接口，并且还继承了ServiceImpl类，该类也实现了IService接口。所以我们的serviceimpl不需要写一些简单具体操作的实现。并且也不需要自动注入mapper，在ServiceImpl中已经帮我们注入了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务层接口</span></span><br><span class="line">public interface EmployeeService <span class="keyword">extends</span> IService&lt;Employee&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务层实现类</span></span><br><span class="line">@Service</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">EmployeeMapper</span>, <span class="title">Employee</span>&gt; <span class="title">implements</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不用再进行Mapper的注入</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * EmployeeServiceImpl  集成了ServiceImpl</span></span><br><span class="line"><span class="comment">     * 1.在ServiceImpl中已经完成Mapper对象的注入，直接在EmployeeServiceImpl中进行使用</span></span><br><span class="line"><span class="comment">     * 2.在ServiceImpl中野帮我们提供了常用的CRUD方法，基本的一些CRUD方法在Service中不需要我们自己定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被继承的接口</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected M baseMapper;<span class="comment">//已自动注入Mapper</span></span><br><span class="line">    <span class="comment">//各种方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、插件拓展"><a href="#七、插件拓展" class="headerlink" title="七、插件拓展"></a>七、插件拓展</h1><h2 id="1-Mybatis插件机制简介"><a href="#1-Mybatis插件机制简介" class="headerlink" title="1.Mybatis插件机制简介"></a>1.Mybatis插件机制简介</h2><p><strong>1）插件机制</strong><br>Mybatis通过插件(Interkeptor)可以做到拦截四太对象相关方法的执行,根据需求，完成相关数据的动态改变。<br>Executor<br>StatementHandler<br>ParameterHandler<br>ResultSetHandler<br><strong>2）插件原理</strong><br>四太对象的每个对象在创建时，都会执行interceptorChain.pluginAll()，会经过每个插件对象的plugin()方法，目的是为当前的四太对象创建代理。代理对象就可以拦截到四太对象相关方法的执行，因为要执行四太对象的方法需要经过代理。<br><strong>3）注册插件</strong>：在Spring配置文件下sqlSessionFactory的bean标签下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注册插件--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;plugins&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">            &lt;!--注册分页插件--&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;com.baomidou.mybatisplus.plugins.PaginationInterceptor&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">                &lt;!--注册执行分析插件--&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;com.baomidou.mybatisplus.plugins.SqlExplainInterceptor&quot;&gt;</span><br><span class="line">                    &lt;!--停止全表操作--&gt;</span><br><span class="line">                    &lt;property name&#x3D;&quot;stopProceed&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;bean&gt;</span><br><span class="line">                &lt;!--注册性能分析插件--&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;com.baomidou.mybatisplus.plugins.PerformanceInterceptor&quot;&gt;</span><br><span class="line">                    &lt;property name&#x3D;&quot;format&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;!--是否进行格式化--&gt;</span><br><span class="line">                    &lt;property name&#x3D;&quot;maxTime&quot; value&#x3D;&quot;5&quot;&#x2F;&gt; &lt;!--最长执行时间，毫秒级--&gt;</span><br><span class="line">                &lt;&#x2F;bean&gt;</span><br><span class="line">                &lt;!--注册乐观锁插件--&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;com.baomidou.mybatisplus.plugins.OptimisticLockerInterceptor&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><p>还可以在Mybatis配置文件下configuration标签下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">        &lt;plugin interceptor&#x3D;&quot;com.baomidou.mybatisplus.plugins.PaginationInterceptor&quot; &#x2F;&gt;</span><br><span class="line">        …………</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br></pre></td></tr></table></figure><h2 id="2-分页插件"><a href="#2-分页插件" class="headerlink" title="2.分页插件"></a>2.分页插件</h2><p> 测试分页插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testPage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Page&lt;Employee&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    List&lt;Employee&gt; employees = employeeMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    employees.forEach(value -&gt; System.out.println(value));</span><br><span class="line">    System.out.println(<span class="string">&quot;总条数：&quot;</span>+page.getTotal());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前页码：&quot;</span>+page.getCurrent());</span><br><span class="line">    <span class="comment">//将查询的结果封装page对象中</span></span><br><span class="line">        page.setRecords(employees);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样就会看到在SQL中出现Limit限制语句是真正的进行了分页操作。我们还可以对查询到的数据进行封装为一个Page对象</p><h2 id="3-执行分析插件"><a href="#3-执行分析插件" class="headerlink" title="3.执行分析插件"></a>3.执行分析插件</h2><p>注册插件之后如果使用的对全表的操作，程序会自动摧毁此次请求。在测试阶段使用，不建议在生产阶段使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testSQLExplain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        employeeMapper.delete(<span class="literal">null</span>);<span class="comment">//全表删除操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-性能分析插件"><a href="#4-性能分析插件" class="headerlink" title="4.性能分析插件"></a>4.性能分析插件</h2><p>注册插件之后如果所执行的SQL超过执行时间之后那么此条SQL抛出异常。在测试阶段使用，不建议在生产阶段使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testPerformance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="string">&quot;marry&quot;</span>,<span class="string">&quot;marry@qq.com&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        employeeMapper.insert(employee);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-乐观锁插件"><a href="#5-乐观锁插件" class="headerlink" title="5.乐观锁插件"></a>5.乐观锁插件</h2><p><strong>1）实现原理</strong>：取出记录的时候获取当前Version版本号更新的时候带上Version，执行更新时，set version=youVersion+1 where versior=yourVersion。如果Version不对，就更新失败。必须使用@Version注解<br><strong>2）使用方法</strong>：在Spring配置文件ApplicationContext.xml配置文件中注册插件。在实体类和数据库添加字段Version。<br>在实体类上添加@Version注解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Version</span><br><span class="line">private Integer version;</span><br><span class="line"><span class="comment">//省略Get和Set方法</span></span><br></pre></td></tr></table></figure><p>测试方法，如果此时Version不与数据库中一致并不会报错只是不会更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testOptimisticLocker</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();<span class="comment">//更新操作</span></span><br><span class="line">        employee.setId(<span class="number">21</span>);</span><br><span class="line">        employee.setLastName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        employee.setVersion(<span class="number">2</span>);</span><br><span class="line">        employeeMapper.updateById(employee);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="八、自定义全局操作"><a href="#八、自定义全局操作" class="headerlink" title="八、自定义全局操作"></a>八、自定义全局操作</h1><p><strong>简介</strong><br>根据 MybatisPlus的 AutoSgllniector,可以自定义各种你想要的sal ,注入到全局中，相当于自定义Mxbatisplus自动注入的方法。</p><p>之前需要在xml中进行配置的SQL语句,现在通过扩展AutoSallnjector在加载mybatis,环境时就注入。</p><h2 id="1-AutoSqlInjector注入自定义SQL"><a href="#1-AutoSqlInjector注入自定义SQL" class="headerlink" title="1.AutoSqlInjector注入自定义SQL"></a>1.AutoSqlInjector注入自定义SQL</h2><p>1).Mapper中定义业务方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface EmployeeMapper <span class="keyword">extends</span> BaseMapper&lt;Employee&gt;&#123;</span><br><span class="line">    Integer deleteByName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2).定义MySqlInjector（新建一个injector包，MySqlInjector类）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MySqlInjector</span> <span class="keyword">extends</span> <span class="title">AutoSqlInjector</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展Inject方法，完成自定义全局操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">inject</span>(<span class="params">Configuration configuration, MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo table</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//将EmployeeMapper中定义的方法，处理成对应的MappedStatement对象，加入到configuration对象中。</span></span><br><span class="line">        <span class="comment">//注入的SQL语句</span></span><br><span class="line">        <span class="built_in">String</span> sql = <span class="string">&quot;delete from &quot;</span> + table.getTableName() + <span class="string">&quot; where name=JKL&quot;</span>;</span><br><span class="line">        <span class="comment">//注入的方法名    一定要与EmployeeMapper接口中的方法名一致</span></span><br><span class="line">        <span class="built_in">String</span> method = <span class="string">&quot;deleteByName&quot;</span>;</span><br><span class="line">        <span class="comment">//构造SqlSource对象</span></span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="comment">//构造一个删除的MappedStatement</span></span><br><span class="line">        <span class="built_in">this</span>.addDeleteMappedStatement(mapperClass, method, sqlSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3).自定义的MySqlInjector配置到ApplicationContext.xml全局策略中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义MybatisPlus的全局策略配置，在版本2.3以后就不用管了默认把数据库下划线变成驼峰就可以插入和主键策略问题--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;globalConfiguration&quot; class&#x3D;&quot;com.baomidou.mybatisplus.entity.GlobalConfiguration&quot;&gt;</span><br><span class="line">        &lt;!-- 在2.3版本以后，dbColumnUnderline 默认值就是true --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dbColumnUnderline&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!--注入自定义全局操作--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;sqlInjector&quot; ref&#x3D;&quot;mySqlInjector&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!--定义自定义注入器--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;mySqlInjector&quot; class&#x3D;&quot;org.example.injector.MySqlInjector&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>4).定义测试类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testMySqlInjector</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Integer i = employeeMapper.deleteByName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Result=&quot;</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-自定义注入器引用之逻辑删除"><a href="#2-自定义注入器引用之逻辑删除" class="headerlink" title="2.自定义注入器引用之逻辑删除"></a>2.自定义注入器引用之逻辑删除</h2><p><strong>假删除、逻辑删除</strong>：并不会真正的从数据库中讲数据删除掉，而是将当前被删除的这条数据中的一个逻辑删除字段置为删除操作。<strong>举例</strong>：tbl_user  logic_flag=1（可用），logic_flag=-1（不可用）。<br>1)新增数据表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tbl_user( </span><br><span class="line">id INT(11) PRIMARY KEY AUTO_INCREMENT, </span><br><span class="line">NAME VARCHAR(50),</span><br><span class="line">logic_flag INT(11)</span><br><span class="line"> ); </span><br></pre></td></tr></table></figure><p>实体类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private <span class="built_in">String</span> name;</span><br><span class="line">    @TableLogic(<span class="comment">/*value = &quot;1&quot;,delval = &quot;-1&quot;*/</span>) <span class="comment">//逻辑删除字段属性，可以使用注解属性</span></span><br><span class="line">    private Integer logicFlag;</span><br><span class="line">    <span class="comment">//省略get和set方法</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>2)在Spring配置文件ApplicationContext.xml进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义MybatisPlus的全局策略配置，在版本2.3以后就不用管了默认把数据库下划线变成驼峰就可以插入和主键策略问题--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;globalConfiguration&quot; class&#x3D;&quot;com.baomidou.mybatisplus.entity.GlobalConfiguration&quot;&gt;</span><br><span class="line">        &lt;!--注入逻辑删除--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;sqlInjector&quot; ref&#x3D;&quot;logicSqlInjector&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!--注入逻辑删除全局value配置，也可以在实体类上面进行配置--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;logicDeleteValue&quot; value&#x3D;&quot;-1&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;logicNotDeleteValue&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!--逻辑删除--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;logicSqlInjector&quot; class&#x3D;&quot;com.baomidou.mybatisplus.mapper.LogicSqlInjector&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>3)测试类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testLogicDelete</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.out.println(userMapper.deleteById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(userMapper.selectById(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所执行的SQL：UPDATE tbl_user SET logic_flag=-1 WHERE id=? </p><h1 id="九、公共字段自动填充"><a href="#九、公共字段自动填充" class="headerlink" title="九、公共字段自动填充"></a>九、公共字段自动填充</h1><h2 id="1-元数据处理器接口"><a href="#1-元数据处理器接口" class="headerlink" title="1.元数据处理器接口"></a>1.元数据处理器接口</h2><p>com.baomidou.mybatisplus.mapper.MetaObjectHandler<br>inserFill(MetaObject metaObject)<br>updateFill(MetaObject metaObject)<br><strong>metaobject:元对象</strong>，是Mybatis.提供的一个用于更加方便，更加优雅的访问对象的属性,给对象的属性设置值的一个对象.还会用于包装对象．支持对object 、Map、Collection等对象进行包装。本质上metaObjet获取对象的属性值或者是给对象的属性设置值，最终是要通过<strong>Reflector</strong>获取到属性的对应方法的<strong>Invoker</strong>，最终invoke。</p><h2 id="2-开发步骤"><a href="#2-开发步骤" class="headerlink" title="2.开发步骤"></a>2.开发步骤</h2><p>1)创建包MyMetaObjectHandler并创建类MyMetaObjectHandler继承MetaObjectHandler。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">extends</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">insertFill</span>(<span class="params">MetaObject metaObject</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//获取到需要被填充的字段的值</span></span><br><span class="line">        <span class="built_in">Object</span> fieldValue = getFieldValByName(<span class="string">&quot;name&quot;</span>, metaObject);</span><br><span class="line">        <span class="keyword">if</span> (fieldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;******************满足填充条件******************&quot;</span>);</span><br><span class="line">            setFieldValByName(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Kevin&quot;</span>, metaObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">updateFill</span>(<span class="params">MetaObject metaObject</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//获取到需要被填充的字段的值</span></span><br><span class="line">        <span class="built_in">Object</span> fieldValue = getFieldValByName(<span class="string">&quot;name&quot;</span>, metaObject);</span><br><span class="line">        <span class="keyword">if</span> (fieldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;******************满足填充条件******************&quot;</span>);</span><br><span class="line">            setFieldValByName(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>, metaObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)在Spring配置文件ApplicationContext.xml中进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;globalConfiguration&quot; class&#x3D;&quot;com.baomidou.mybatisplus.entity.GlobalConfiguration&quot;&gt;</span><br><span class="line">        &lt;!--注入公共字段填充处理器--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;metaObjectHandler&quot; ref&#x3D;&quot;myMetaObjectHandler&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!--公共字段填充处理器--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;myMetaObjectHandler&quot; class&#x3D;&quot;org.example.MyMetaObjectHandler.MyMetaObjectHandler&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>3)编写测试类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">testMetaObjectHandler</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">//user.setName(&quot;lucy&quot;);//不定义名字，自动进行填充</span></span><br><span class="line">        user.setLogicFlag(<span class="number">1</span>);</span><br><span class="line">        user.setId(<span class="number">5</span>);</span><br><span class="line">        userMapper.updateById(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意一个问题</strong>：如果更新操作您本不想更新那个字段这儿也会给您默认进行填充，所以使用的时候需要进行注意这个问题。</p><h1 id="十、Oracle主键Sequence"><a href="#十、Oracle主键Sequence" class="headerlink" title="十、Oracle主键Sequence"></a>十、Oracle主键Sequence</h1><p>MySQL：支持主键自增。IdType.Auto<br>Oracle：序列（Sequence）<br>1)实体类配置主键Sequence    @KeySequence(value=”序列名”,class=xxx.class逐渐属性类型)<br>2)全局MP主键生成策略为idType.INPUT<br>3)全局mp中配置Oracle主键Sequence<br>com.baomidou.mybatisplus.incrementer.OracleKeyGenerator<br>4)可以将@keySequence定义在父类中,可实现多个子类对应的多个表公用一个Sequence</p><h1 id="十一、IDEA插件EasyCode使用"><a href="#十一、IDEA插件EasyCode使用" class="headerlink" title="十一、IDEA插件EasyCode使用"></a>十一、IDEA插件EasyCode使用</h1><p>1.安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击File&gt;Settinds&gt;Plugins然后在Plugins里搜索easycode点击Install安装插件</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210205213156343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2.搭建一个Maven的Web项目。生成之后需要手动创建在main下创Java目录并且创建包。这里创建包com.kevin（后面使用到）<br><img src="https://img-blog.csdnimg.cn/20210205213332141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.导入数据库<br><img src="https://img-blog.csdnimg.cn/20210205213632705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.配置数据库连接以及设置时区。<br><img src="https://img-blog.csdnimg.cn/20210205213735826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击Set time zone之后跳转到Advanced之后再点击回General<br><img src="https://img-blog.csdnimg.cn/20210205213852371.png" alt="在这里插入图片描述"><br>5.右键点击需要生成的数据库表<br><img src="https://img-blog.csdnimg.cn/20210205214050159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>6.选择所放置的包（com.java），确定路径正确之后一路点击yes就可以了<br><img src="https://img-blog.csdnimg.cn/20210205220542602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>7.完成之后结构图<br><img src="https://img-blog.csdnimg.cn/20210205220613453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDQ5Mzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
